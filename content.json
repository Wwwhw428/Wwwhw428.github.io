{"meta":{"title":"Wwwhw's BLOG","subtitle":"","description":"","author":"Wang Haowen","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"算法笔记","slug":"算法笔记","date":"2021-01-21T12:55:20.000Z","updated":"2021-01-22T03:28:50.173Z","comments":true,"path":"2021/01/21/算法笔记/","link":"","permalink":"http://example.com/2021/01/21/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","excerpt":"","text":"TOPKTOPK即数组中最大的k个数或，数组中最小的k个数。 1.用堆排序的思想解决取最小的k个数 对数组前k个元素进行堆调整。 将第k + 1个元素与堆顶元素比较，若nums[k + 1] &lt; nums[0]则互换并堆调整。 依次向后比较。 最后堆中剩下的就是最小的k个数。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;int&gt; smallestK(vector&lt;int&gt;&amp; arr, int k) &#123; vector&lt;int&gt; res; if (k == 0) &#123; return res; &#125; //先对前k个元素进行堆排 for (int i = (k / 2) - 1; i &gt;= 0; i--) &#123; heapAdjust(arr, i, k); &#125; //当k后的数组元素小于堆顶元素时，互换，堆调整 for (int i = k; i &lt; arr.size(); i++) &#123; if (arr[i] &lt; arr[0]) &#123; swap(arr[i], arr[0]); heapAdjust(arr, 0, k); &#125; &#125; for (int i = 0; i &lt; k; i++) &#123; res.push_back(arr[i]); &#125; return res; &#125; //堆调整 void heapAdjust(vector&lt;int&gt;&amp; vec, int start, int maxindex) &#123; int ch = 2 * start + 1; while (ch &lt; maxindex) &#123; if (ch + 1 &lt; maxindex &amp;&amp; vec[ch] &lt; vec[ch + 1]) &#123; ch++; &#125; if (vec[ch] &gt; vec[start]) &#123; swap(vec[ch], vec[start]); start = ch; ch = 2 * start + 1; &#125; else &#123; break; &#125; &#125; &#125;&#125;; 使用优先级队列实现堆调整 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; smallestK(vector&lt;int&gt;&amp; arr, int k) &#123; vector&lt;int&gt; res; if (k == 0) &#123; return res; &#125; priority_queue&lt;int&gt; que; for (int i = 0; i &lt; k; i++) &#123; que.push(arr[i]); &#125; for (int i = k; i &lt; arr.size(); i++) &#123; if (arr[i] &lt; que.top()) &#123; que.pop(); que.push(arr[i]); &#125; &#125; while (!que.empty()) &#123; res.push_back(que.top()); que.pop(); &#125; return res; &#125;&#125;; 2.快排思想 先尽量找到中间值，对数组进行一趟快排。 一趟快排过后，黄色中间区域为==哨兵值的元素，i左侧为小于哨兵的区域即为最小的i-l个数。 若i - L== k，则直接返回前k个数。 若i - L &lt; k,则再对黄色及黄色右边进行快排。 若i - L &gt; k,则在对黄色左边区域进行快排。","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Linux笔记","slug":"Linux笔记","date":"2021-01-21T11:55:42.000Z","updated":"2021-01-21T11:55:44.373Z","comments":true,"path":"2021/01/21/Linux笔记/","link":"","permalink":"http://example.com/2021/01/21/Linux%E7%AC%94%E8%AE%B0/","excerpt":"","text":"终端aa/代表根目录 ~代表当前用户的家目录 ls显示当前目录下所有文件 bin文件夹存储二进制文件（可执行文件） dev root超级用户的家目录 tmp存放临时文件，会被定期清理 etc存放配置文件 home除了root用户以外的目录的家目录在这里 clear傻瓜式清屏 ctrl+l也是清屏 history历史指令 相对路径：从当前文件夹开始描述 绝对路径：从根目录开始描述 pwd打印当前路径 蓝色的是文件夹 红色的是压缩包 绿色的是可执行文件 ..父级路径 ./当前目录 第一个位置为- 普通文件类型； d 文件夹类型；c 字符设备文件 b 块设备文件；l 软连接（像快捷方式）；p 管道文件；s 套接字","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"LeetCode刷题记录：27.移除元素","slug":"LeetCode刷题记录：27.移除元素","date":"2021-01-20T10:53:35.000Z","updated":"2021-01-20T10:56:21.546Z","comments":true,"path":"2021/01/20/LeetCode刷题记录：27.移除元素/","link":"","permalink":"http://example.com/2021/01/20/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/","excerpt":"","text":"法一 i,j分别从数组两端开始扫描， i扫描到值等于val元素时停下， j扫描到值等于val元素时length--,扫描到值不等于val的元素时停下 nums[i],nums[i]互换，length--。 1234567891011121314151617181920212223242526272829class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int length = nums.size(); if (length == 0) &#123; return 0; &#125; int i = 0, j = length - 1; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; nums[i] != val) &#123; i++; &#125; while (i &lt; j &amp;&amp; nums[j] == val) &#123; j--; length--; &#125; if (i &lt; j) &#123; swap(nums[i], nums[j]); i++; j--; length--; &#125; &#125; if (i == j &amp;&amp; nums[i] == val) &#123; length--; &#125; return length; &#125;&#125;; 法二 双指针，快慢指针 i，j同时先后扫描当nums[j] != val时将nums[j]赋值给nums[i]并且i++, j++。 当j扫描到数组尾部结束 1234567891011121314151617class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int length = nums.size(); if (length == 0) &#123; return 0; &#125; int i = 0, j = 0; while (j &lt; length) &#123; if (nums[j] != val) &#123; nums[i++] = nums[j]; &#125; j++; &#125; return i; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"双指针","slug":"LeetCode/双指针","permalink":"http://example.com/categories/LeetCode/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"LeetCode刷题记录：925.长按键入","slug":"LeetCode刷题记录：925.长按键入","date":"2021-01-20T09:10:35.000Z","updated":"2021-01-20T09:16:37.427Z","comments":true,"path":"2021/01/20/LeetCode刷题记录：925.长按键入/","link":"","permalink":"http://example.com/2021/01/20/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A925.%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5/","excerpt":"","text":"思路： 先判断两个字符串首字母是否相同，不同直接返回false i指向name第二个字符，j指向typed第二个字符先后扫描 i，j所指字符相同时i++,j++ i，j所指字符不同时，看j所指字符是不是长按造成的重复，即typed[j] == typed[j - 1] i，j所指字符不同时，且j所指字符不是长按造成的重复返回false 若j先扫描完，则typed内必不含name 若i先扫完，j向后扫描，若扫描到非长按造成的重复字符时返回false12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool isLongPressedName(string name, string typed) &#123; if(name[0] != typed[0])&#123; return false; &#125; int i = 1,j = 1; while (i &lt; name.size() &amp;&amp; j &lt; typed.size()) &#123; if (name[i] == typed[j]) &#123; i++; j++; &#125; else if (name[i] != typed[j] &amp;&amp; typed[j] == typed[j - 1]) &#123; j++; &#125; else &#123; return false; &#125; &#125; if(j == typed.size() &amp;&amp; i &lt; name.size())&#123; return false; &#125; while(j &lt; typed.size())&#123; if(typed[j] != typed[j - 1])&#123; return false; &#125; j++; &#125; return true; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"双指针","slug":"LeetCode/双指针","permalink":"http://example.com/categories/LeetCode/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"LeetCode刷题记录：844. 比较含退格的字符串","slug":"LeetCode刷题记录：844.比较含推个的字符串","date":"2021-01-19T15:39:35.000Z","updated":"2021-01-19T15:43:07.909Z","comments":true,"path":"2021/01/19/LeetCode刷题记录：844.比较含推个的字符串/","link":"","permalink":"http://example.com/2021/01/19/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A844.%E6%AF%94%E8%BE%83%E5%90%AB%E6%8E%A8%E4%B8%AA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"法一：双指针 双指针，两个指针分别再两个字符串的最后一位 用skip记录该跳过几个字符 每当遇到#时skip++，遇到字符且skip不为0时跳过并且skip– 比较两个指针所指字符是否相同 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: bool backspaceCompare(string S, string T) &#123; int i = S.length() - 1, j = T.length() - 1; int skipS = 0, skipT = 0; while (i &gt;= 0 || j &gt;= 0) &#123; while (i &gt;= 0) &#123; if (S[i] == &#x27;#&#x27;) &#123; skipS++, i--; &#125; else if (skipS &gt; 0) &#123; skipS--, i--; &#125; else &#123; break; &#125; &#125; while (j &gt;= 0) &#123; if (T[j] == &#x27;#&#x27;) &#123; skipT++, j--; &#125; else if (skipT &gt; 0) &#123; skipT--, j--; &#125; else &#123; break; &#125; &#125; if (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; if (S[i] != T[j]) &#123; return false; &#125; &#125; else &#123; if (i &gt;= 0 || j &gt;= 0) &#123; return false; &#125; &#125; i--, j--; &#125; return true; &#125;&#125;; 法二：栈","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：26. 删除排序数组中的重复项","slug":"LeetCode刷题记录：26.删除排序数组中的重复项","date":"2021-01-19T12:07:35.000Z","updated":"2021-01-19T15:38:50.128Z","comments":true,"path":"2021/01/19/LeetCode刷题记录：26.删除排序数组中的重复项/","link":"","permalink":"http://example.com/2021/01/19/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A26.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","excerpt":"","text":"两个指针i,j一开始都为1，j向后扫描当nums[j - 1] != nums[j]时给i赋值i++ 12345678910111213141516class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) &#123; return 0; &#125; int i = 1, j = 1; while (j &lt; nums.size()) &#123; if (nums[j - 1] != nums[j]) &#123; nums[i++] = nums[j]; &#125; j++; &#125; return i; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：1260.二维网格迁移","slug":"LeetCode刷题记录：1260.二维网格迁移","date":"2021-01-19T11:45:35.000Z","updated":"2021-01-19T11:47:43.251Z","comments":true,"path":"2021/01/19/LeetCode刷题记录：1260.二维网格迁移/","link":"","permalink":"http://example.com/2021/01/19/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A1260.%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E8%BF%81%E7%A7%BB/","excerpt":"","text":"创建一个新的二维数组 第i行第j列元素应移到第((k + j) / n + i) % m第(k + j) % n列 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; shiftGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) &#123; int m = grid.size(); //行数 int n = grid[0].size(); //列数 vector&lt;vector&lt;int&gt;&gt; res; res.resize(m); for (int i = 0; i &lt; m; i++) &#123; res[i].resize(n); &#125; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; res[((k + j) / n + i) % m][(k + j) % n] = grid[i][j]; &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：1672.最富有客户的资产总量","slug":"LeetCode刷题记录：1672. 最富有客户的资产总量","date":"2021-01-19T08:28:35.000Z","updated":"2021-01-19T08:29:56.315Z","comments":true,"path":"2021/01/19/LeetCode刷题记录：1672. 最富有客户的资产总量/","link":"","permalink":"http://example.com/2021/01/19/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A1672.%20%E6%9C%80%E5%AF%8C%E6%9C%89%E5%AE%A2%E6%88%B7%E7%9A%84%E8%B5%84%E4%BA%A7%E6%80%BB%E9%87%8F/","excerpt":"","text":"扫描每一行找出最大值 1234567891011121314151617class Solution &#123;public: int maximumWealth(vector&lt;vector&lt;int&gt;&gt;&amp; accounts) &#123; int max = 0; int temp = 0; for (int i = 0; i &lt; accounts.size(); i++) &#123; temp = 0; for (int j = 0; j &lt; accounts[0].size(); j++) &#123; temp += accounts[i][j]; &#125; if (temp &gt; max) &#123; max = temp; &#125; &#125; return max; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：832.反转图像","slug":"LeetCode刷题记录：832.反转图像","date":"2021-01-19T08:21:35.000Z","updated":"2021-01-19T08:22:47.686Z","comments":true,"path":"2021/01/19/LeetCode刷题记录：832.反转图像/","link":"","permalink":"http://example.com/2021/01/19/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A832.%E5%8F%8D%E8%BD%AC%E5%9B%BE%E5%83%8F/","excerpt":"","text":"对每一行逆序的同时进行取反 123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; int i, j, k,temp; for (i = 0; i &lt; A.size(); i++) &#123; j = 0; k = A[0].size() - 1; while (j &lt; k) &#123; temp = A[i][j]; A[i][j] = !A[i][k]; A[i][k] = !temp; j++; k--; &#125; if (j == k) &#123; A[i][k] = !A[i][k]; &#125; &#125; return A; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：287.寻找重复数","slug":"LeetCode刷题记录：287.寻找重复数","date":"2021-01-19T07:54:35.000Z","updated":"2021-01-19T07:55:54.486Z","comments":true,"path":"2021/01/19/LeetCode刷题记录：287.寻找重复数/","link":"","permalink":"http://example.com/2021/01/19/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A287.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/","excerpt":"","text":"法一 使用哈希表 1234567891011121314class Solution &#123;public: int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; map&lt;int, int&gt; mp; for (int i = 0; i &lt; nums.size(); i++) &#123; //边存边判断 if (mp[nums[i]] &gt; 0) &#123; return nums[i]; &#125; mp[nums[i]]++; &#125; return 0; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：867.转置矩阵","slug":"LeetCode刷题记录：867.转置矩阵","date":"2021-01-18T16:49:35.000Z","updated":"2021-01-18T16:51:01.751Z","comments":true,"path":"2021/01/19/LeetCode刷题记录：867.转置矩阵/","link":"","permalink":"http://example.com/2021/01/19/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A867.%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/","excerpt":"","text":"将每一列的第i个行存入temp 将temp插入到trans中 temp清空 循环 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; transpose(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; int row = A.size(); //行数 int column = A[0].size(); //列数 vector&lt;vector&lt;int&gt;&gt; trans; vector&lt;int&gt; temp; //将每一列的第i个行存入temp,再将temp插入到trans中 for (int j = 0; j &lt; column; j++) &#123; for (int i = 0; i &lt; row; i++) &#123; temp.push_back(A[i][j]); &#125; trans.push_back(temp); temp.clear(); &#125; return trans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：747.至少是其他数字两倍的最大数","slug":"LeetCode刷题记录：747.至少是其他数字两倍的最大数","date":"2021-01-18T16:15:35.000Z","updated":"2021-01-19T07:53:17.807Z","comments":true,"path":"2021/01/19/LeetCode刷题记录：747.至少是其他数字两倍的最大数/","link":"","permalink":"http://example.com/2021/01/19/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A747.%E8%87%B3%E5%B0%91%E6%98%AF%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E4%B8%A4%E5%80%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0/","excerpt":"","text":"先找出最大值，再与其他元素依次比较 当遇到元素*2大于最大值的情况返回-1 否则返回最大值的索引 当数组只有一个元素时返回0 1234567891011121314151617181920212223class Solution &#123;public: int dominantIndex(vector&lt;int&gt;&amp; nums) &#123; int length = nums.size(); if (length == 1) &#123; return 0; &#125; //找出最大值 int max = 0; for (int i = 0; i &lt; length; i++) &#123; if (nums[max] &lt; nums[i]) &#123; max = i; &#125; &#125; //遍历数组看是否有元素*2大于最大值的情况 for (int i = 0; i &lt; length; i++) &#123; if (i != max &amp;&amp; nums[i] * 2 &gt; nums[max]) &#123; return -1; &#125; &#125; return max; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：1266. 访问所有点的最小时间","slug":"LeetCode刷题记录：1266.访问所有点的最小时间","date":"2021-01-18T12:33:35.000Z","updated":"2021-01-18T12:43:03.313Z","comments":true,"path":"2021/01/18/LeetCode刷题记录：1266.访问所有点的最小时间/","link":"","permalink":"http://example.com/2021/01/18/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A1266.%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4/","excerpt":"","text":"切比雪夫距离 当当前位置x，y均与目标点不同时，需斜向移动目标点与当前点横纵坐标差值的绝对值中最小的数个单位，再横向或纵向移动剩余位置。移动次数之和正好是目标点与当前点横纵坐标差值的绝对值中最大的数。 时间复杂度低，当空间消耗较多 12345678910class Solution &#123;public: int minTimeToVisitAllPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; int count = 0; //记录步数 for (int i = 1; i &lt; points.size(); i++) &#123; count += max(abs(points[i][0] - points[i - 1][0]), abs(points[i][1] - points[i - 1][1])); &#125; return count; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：1588.所有奇数长度子数组的和","slug":"LeetCode刷题记录：1588.所有奇数长度字数组的和","date":"2021-01-18T09:13:35.000Z","updated":"2021-01-18T12:42:55.692Z","comments":true,"path":"2021/01/18/LeetCode刷题记录：1588.所有奇数长度字数组的和/","link":"","permalink":"http://example.com/2021/01/18/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A1588.%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%97%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/","excerpt":"","text":"法一： 从头开始扫描，扫描到一个数时，找到每一个以该元素作为开始的奇数子数组并计入。 12345678910111213141516class Solution &#123;public: int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) &#123; int length = arr.size(); int length = arr.size(); int sum = 0; for (int i = 0; i &lt; length; i++) &#123; for (int j = 0; i + j &lt; length; j += 2) &#123; for (int k = 0; k &lt;= j; k++) &#123; sum += arr[i + k]; &#125; &#125; &#125; return sum; &#125;&#125;; 法二：第i个数左边有i个数，右边有length-i-1（length为数组长度）个数。只有当左右都选奇数个或者都选偶数个时，加上自身个数才为奇数 123456789101112131415161718class Solution &#123;public: int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) &#123; int length = arr.size(); int count = 0, sum = 0; for (int i = 0; i &lt; length; i++) &#123; //奇，i两边各选奇数个数情况的数量 count = i / 2 + i % 2; count *= (length - i - 1) / 2 + (length - i - 1) % 2; sum += arr[i] * count; //偶，i两边各选偶数个数情况的数量 count = i / 2 + 1; count *= (length - i - 1) / 2 + 1; sum += arr[i] * count; &#125; return sum; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：35.搜索插入位置","slug":"LeetCode刷题记录：35.搜索插入位置","date":"2021-01-17T16:10:35.000Z","updated":"2021-01-18T17:02:20.247Z","comments":true,"path":"2021/01/18/LeetCode刷题记录：35.搜索插入位置/","link":"","permalink":"http://example.com/2021/01/18/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A35.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"由于序列是有序的，当目标值大于数组最后一个元素时表明数组中没有等于目标值的元素，插入位置为数组长度 由于序列是有序的，当目标值小于数组第一个元素时表明数组中没有等于目标值的元素，插入位置为0 使用折半查找法进行查找，找到目标值位置或插入位置 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int low, high, mid; low = 0; high = nums.size() - 1; //目标值大于数组最后一个元素和目标值小于数组第一个元素情况 if (target &gt; nums[high]) &#123; return high + 1; &#125; else if (target &lt; nums[low]) &#123; return low; &#125; else &#123; //折半查找法进行查找，找到目标值位置或插入位置 while (low &lt;= high) &#123; mid = (low + high) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target) &#123; low = mid + 1; &#125; else &#123; high = mid - 1; &#125; &#125; return low; &#125; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：66.加一","slug":"LeetCode刷题记录：66.加一","date":"2021-01-17T15:31:35.000Z","updated":"2021-01-18T08:10:03.334Z","comments":true,"path":"2021/01/17/LeetCode刷题记录：66.加一/","link":"","permalink":"http://example.com/2021/01/17/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A66.%E5%8A%A0%E4%B8%80/","excerpt":"","text":"12345678910111213141516171819class Solution &#123;public: std::vector&lt;int&gt; plusOne(std::vector&lt;int&gt;&amp; digits) &#123; int length = digits.size(); int i = length - 1; //加一之后某一位需要进位则该位前每一位都为9 for (i = length - 1; i &gt;= 0 &amp;&amp; digits[i] == 9; i--) &#123; digits[i] = 0; &#125; //当最高位加一后仍需进位（即i == -1）时，在数组头插入1 if (i == -1) &#123; digits.insert(digits.begin(), 1); &#125; else &#123; digits[i]++; &#125; return digits; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"C++学习笔记3","slug":"C++学习笔记3","date":"2021-01-16T02:05:56.000Z","updated":"2021-01-22T02:49:53.922Z","comments":true,"path":"2021/01/16/C++学习笔记3/","link":"","permalink":"http://example.com/2021/01/16/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/","excerpt":"","text":"模板模板函数1template(模板)&lt;class/typename name&gt; 在模板函数定义中typename和class作用相同。 1234567891011121314151617181920#include&lt;iostream&gt;#include&quot;mystring.h&quot;using namespace std;template&lt;class T&gt; void add(T a, T b) &#123; cout &lt;&lt; a + b &lt;&lt; endl;&#125; //template(模板)&lt;class/typename name&gt; T就是一个泛型template&lt;class T,class H&gt; void add1(T a, H b) &#123; //参数类型可以不同也可以相同 cout &lt;&lt; a + b &lt;&lt; endl;&#125; //泛型编程int main() &#123; mystring str1 = &quot;123456&quot;; mystring str2 = &quot;asdqwe&quot;; add(10, 20); add(15.1, 61.8); add(str1, str2); add1(10, 35.99); add1(10, 30); return 0;&#125; 输出结果 1234563076.9123456asdqwe45.9940 模板类1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;string&gt;#include&quot;mystring.h&quot;using namespace std;template&lt;class Type&gt; class List &#123; Type val; List* next;public: List(Type v) &#123; this-&gt;val = v; &#125;&#125;;int main() &#123; List&lt;int&gt; L(32); //要加&lt;&gt;，声明Type的类型 List&lt;double&gt; L(15.5); return 0;&#125; list容器 123456789101112131415#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;int main() &#123; list&lt;int&gt; lis; list&lt;double&gt; lss; lis.push_back(10); //将10放在链表最后 lis.push_front(20); //将20放在链表前面 lis.pop_back(); //删除最后一个节点 lis.pop_front(); //删除第一个节点 cout &lt;&lt; lis.size() &lt;&lt; endl; return 0;&#125; STL迭代器1容器名&lt;元素类型&gt;::iterator it = values.begin(); list容器 实际上就是个双链表。 使用时需包含头文件#include&lt;list&gt; list类定义在std中，是个class template 创建一个有n个元素的list，每个元素的值都是相应类型的默认值。 1std::list&lt;elemtype&gt; values(n); 创建一个自定义的list。 1std::list&lt;int&gt; a1&#123; 1,2,3,4,5 &#125;; 创建一个有n个值为10的list。 1std::list&lt;int&gt; values(n,10); 拷贝其他list创建新的list，保证新旧容器元素类型一样 12std::list&lt;int&gt; values(10);std::list&lt;int&gt; values2(values); 拷贝其他类型容器中指定区域内的元素，eg:数组。 12int c[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;std::list&lt;int&gt; values(c,c+10); 用迭代器遍历list123456789101112#include&lt;iostream&gt;#include&lt;list&gt;int main() &#123; int c[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;; std::list&lt;int&gt; values(c,c+10); for (std::list&lt;int&gt;::iterator it = values.begin(); it != values.end(); it++) &#123; std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 输出结果 121 2 3 4 5 6 7 8 9 10 vector容器定义sort规则1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;struct Node&#123; int num; int score; Node(int n, int s) &#123; num = n; score = s; &#125;&#125;;//定义比较规则：按分数降序，当分数相同时，学号小的在前bool Comp(const Node &amp;a, const Node &amp;b) &#123; return a.score &gt; b.score || a.score == b.score &amp;&amp; a.num &lt; b.num;&#125;int main() &#123; vector&lt;Node&gt; v; v.push_back(Node(1, 45)); v.push_back(Node(2, 67)); v.push_back(Node(3, 49)); v.push_back(Node(4, 79)); v.push_back(Node(5, 86)); v.push_back(Node(6, 13)); v.push_back(Node(7, 46)); v.push_back(Node(8, 86)); v.push_back(Node(9, 47)); sort(v.begin(), v.end(), Comp); for (vector&lt;Node&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; it-&gt;num &lt;&lt; &#x27; &#x27; &lt;&lt; it-&gt;score &lt;&lt; endl; &#125; return 0;&#125; 输出结果 123456789105 868 864 792 673 499 477 461 456 13 map容器map初始化 1map&lt;type1, type2&gt; mp; map遍历123456789101112char firstUniqChar(string s) &#123; map&lt;char, int&gt; mp; for (int i = 0; i &lt; len; i++) &#123; mp[s[i]]++; &#125; for (map&lt;char, int&gt;::iterator it = mp.begin(); it != mp.end(); it++) &#123; if (it-&gt;second == 1) &#123; return it-&gt;first; &#125; &#125; return &#x27; &#x27;;&#125; 优先级队列123456789101112131415int main() &#123; //优先级队列，默认将数据调整成最大堆 priority_queue&lt;int&gt; pq; pq.push(3); pq.push(9); pq.push(8); pq.push(2); pq.push(1); while (!pq.empty()) &#123; cout &lt;&lt; pq.top() &lt;&lt; endl; pq.pop(); &#125; return 0;&#125; 123456789101112131415int main() &#123; //优先级队列，最小堆 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq; pq.push(3); pq.push(9); pq.push(8); pq.push(2); pq.push(1); while (!pq.empty()) &#123; cout &lt;&lt; pq.top() &lt;&lt; endl; pq.pop(); &#125; return 0;&#125; auto自动识别类型，增强for循环 123for (auto val : res)&#123; cout &lt;&lt; vall &lt;&lt; &quot; &quot;;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"笔记","slug":"C-C/笔记","permalink":"http://example.com/categories/C-C/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"}]},{"title":"C++学习笔记2","slug":"C++学习笔记2","date":"2021-01-15T11:45:56.000Z","updated":"2021-01-19T02:29:29.577Z","comments":true,"path":"2021/01/15/C++学习笔记2/","link":"","permalink":"http://example.com/2021/01/15/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/","excerpt":"","text":"封装作用防止数据被随意修改 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;class Student &#123; int age; int score; int weight;public: void setAge(int age); int getAge();&#125;;void Student::setAge(int age) &#123; this-&gt;age = age;&#125;int Student::getAge() &#123; return age;&#125;int main() &#123; Student stu; stu.setAge(10); cout &lt;&lt; stu.getAge() &lt;&lt; endl;&#125; 输出结果 1210 继承 继承允许我们依据另一个类来定义一个类，达到了重用代码功能和提高执行效率的效果。 当创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。 继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。 定义派生类可以从多个基类继承数据和函数,使用一个类派生列表来指定基类 1class derived-class: access-specifier base-class 访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;using namespace std;//基类——人class People&#123;private: int age; int weight;public: //成员函数声明 void setAge(int age); void setWeight(int weight); int getAge(); int getWeight();&#125;;//成员函数定义void People::setAge(int age) &#123; this-&gt;age = age;&#125;void People::setWeight(int weight) &#123; this-&gt;weight = weight;&#125;int People::getAge() &#123; return age;&#125;int People::getWeight() &#123; return weight;&#125;//人的派生类——学生class Student :public People&#123;private: int number;public: //成员函数声明 void setNumber(int number); int getNumber();&#125;;//成员函数定义void Student::setNumber(int number) &#123; this-&gt;number = number;&#125;int Student::getNumber() &#123; return number;&#125;int main() &#123; Student s; s.setAge(20); int age = s.getAge(); cout &lt;&lt; age &lt;&lt; endl;&#125; 输出结果 1220 有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。 1.public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private 2.protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private 3.private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private 但无论哪种继承方式，上面两点都没有改变： 1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问； 2.protected 成员可以被派生类访问。 继承方式/基类成员 public成员 protected成员 private成员 public继承 public protected 不可见 protected继承 protected protected 不可见 private继承 private private 不可见 函数隐藏 如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名（只要函数名相同），那么就会隐藏从基类继承过来的成员。就是在派生类中使用该成员，实际上使用的是派生类新增的成员，而不是从基类继承的。 使用基类的成员函数。 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;//基类——人class People&#123;private: int age;public: //成员函数声明 int getAge();&#125;;//成员函数定义int People::getAge() &#123; cout &lt;&lt; &quot;People&quot; &lt;&lt; endl; return 0;&#125;//人的派生类——学生class Student: public People&#123;public: //成员函数声明 int getAge();&#125;;//成员函数定义int Student::getAge() &#123; cout &lt;&lt; &quot;student&quot; &lt;&lt; endl; return 0;&#125;int main() &#123; Student s; s.getAge();&#125; 输出结果 1student 若想使用People类的getAge()则主函数中s.getAge();应改为s.People::getAge(); 基类和派生类的构造析构顺序12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;class People &#123;public: People() &#123; cout &lt;&lt; &quot;people&quot; &lt;&lt; endl; &#125; ~People() &#123; cout &lt;&lt; &quot;~people&quot; &lt;&lt; endl; &#125;&#125;;class Student : public People&#123;public: Student() &#123; cout &lt;&lt; &quot;Student&quot; &lt;&lt; endl; &#125; ~Student() &#123; cout &lt;&lt; &quot;~Student&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; Student stu; return 0;&#125; 输出结果 12345peoplestudent~student~people 多继承类轻易不用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;using namespace std;//基类——人class People&#123;private: int age; int weight;public: //成员函数声明 void setAge(int age); void setWeight(int weight); int getAge(); int getWeight();&#125;;//成员函数定义void People::setAge(int age) &#123; this-&gt;age = age;&#125;void People::setWeight(int weight) &#123; this-&gt;weight = weight;&#125;int People::getAge() &#123; return age;&#125;int People::getWeight() &#123; return weight;&#125;//基类——动物class Animal&#123;public: //成员函数声明 void eat();&#125;;//成员函数定义void Animal::eat() &#123; cout &lt;&lt; &quot;吃 吃 吃&quot; &lt;&lt; endl;&#125;//人的派生类——学生class Student: public People,public Animal&#123;private: int number;public: //成员函数声明 void setNumber(int number); int getNumber();&#125;;//成员函数定义void Student::setNumber(int number) &#123; this-&gt;number = number;&#125;int Student::getNumber() &#123; return number;&#125;int main() &#123; Student s; s.setAge(20); int age = s.getAge(); cout &lt;&lt; age &lt;&lt; endl; s.eat();&#125; 输出结果 12320吃 吃 吃 虚继承 为什么存在 现象:假如我们有类A是父类，类B和类C继承了类A，而类D既继承类B又继承类C(这种菱形继承关系)。当我们实例化D的对象的时候，每个D的实例化对象中都有了两·份完全相同的A的数据。因为保留多份数据成员的拷贝，不仅占用较多的存储空间，还增加了访问这些成员时的困难，容易出错，而实际上，我们并不需要有多份拷贝。 解决方法1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;//基类——人class People &#123; //抽象类public: int age; //成员函数声明 void doWork() &#123; cout &lt;&lt; &quot;吃饭 睡觉&quot; &lt;&lt; endl; &#125;&#125;;class Worker : virtual public People &#123;&#125;;class Farmer : virtual public People &#123;&#125;;class MigrantWorker : virtual public Worker, virtual public Farmer &#123;&#125;;int main() &#123; MigrantWorker m; m.age = 10; //虚继承解决访问不明确的问题 return 0;&#125; new和malloc的区别 new/delete是C++运算符，需要编译器支持。malloc/free是库函数，需要头文件支持。 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。 new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void ，需要通过强制类型转换将void指针转换成我们需要的类型。 new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。 new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现)。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存(通常底层使用free实现)。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。 123456789101112int main() &#123; int* a = (int *)malloc(4); free(a); int* b = new int; delete b; int* c = new int[10]; delete[]c; return 0;&#125; 1234567891011121314151617181920class People&#123; int age;public: //成员函数声明 People() &#123; cout &lt;&lt; &quot;people&quot; &lt;&lt; endl; &#125; ~People() &#123; cout &lt;&lt; &quot;~people&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; People *p = (People *)malloc(sizeof(People)); free(p); People *n = new People; delete n; return 0;&#125; 输出结果 123people~people 虚析构常常把析构函数设置成虚函数 什么要加虚析构？如果不是虚析构，子类析构不会运行，有可能发生内存泄漏 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;//基类——人class People &#123; //抽象类 int age;public: //成员函数声明 People() &#123; cout &lt;&lt; &quot;people&quot; &lt;&lt; endl; &#125; //如果不是虚析构，子类析构不会运行。,有可能发生内存泄漏 virtual ~People() &#123; cout &lt;&lt; &quot;~people&quot; &lt;&lt; endl; &#125;&#125;;//人的派生类——学生class Student : public People &#123;public: virtual void play() &#123; cout &lt;&lt; &quot;打游戏&quot; &lt;&lt; endl; &#125; ~Student() &#123; cout &lt;&lt; &quot;~student&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; People *p = new Student; delete p; cout &lt;&lt; sizeof(People) &lt;&lt; endl; return 0;&#125; 输出结果 12345people~student~people8 为什么默认的析构函数不是虚析构？虚函数会在类中产生一个虚指针，浪费空间 类一个变量没有时sizeof()得1，用来占位。 类的大小和结构体一样，字节对齐。虚指针也占空间。 vs里默认32位。 纯虚函数 纯虚函数即虚函数等于0 包含纯虚函数的类是抽象类，抽象类不允许实例化 子类如果不重写父类的纯虚函数，那么这个子类也是抽象类 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;//基类——人class People &#123; //抽象类 int age;public: //成员函数声明 virtual void play() = 0; //纯虚函数&#125;;//人的派生类——学生class Student : public People &#123;public: virtual void play() &#123; cout &lt;&lt; &quot;打游戏&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; //People p; //不允许实例化 Student s; return 0;&#125; 多态多态的实现在满足函数重写/函数覆盖的条件下，父类指针指向子类对象，调用子类成员函数。 函数重写/函数覆盖通过虚函数实现函数覆盖 父类定义虚函数 子类实现虚函数功能 函数隐藏：指针变量类型是谁就调用谁的成员函数 函数覆盖：函数重写 new谁调用谁的成员函数 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;//基类——人class People &#123; int age;public: //成员函数声明 void eat() &#123; cout &lt;&lt; &quot;eat&quot; &lt;&lt; endl; &#125; virtual void play() &#123; cout &lt;&lt; &quot;play&quot; &lt;&lt; endl; &#125;&#125;;//人的派生类——学生class Student: public People &#123;public: void eat() &#123; cout &lt;&lt; &quot;eat meat&quot; &lt;&lt; endl; &#125; virtual void play() &#123; cout &lt;&lt; &quot;打游戏&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; People *p = new Student; p-&gt;eat; //函数隐藏 p-&gt;play(); //函数覆盖/函数重写 delete p; return 0;&#125; 输出结果 123eat打游戏 重载操作符※ 类外重载需两个参数，重复的话优先类内的 操作符函数参数数量和操作数数量相同，类内有this指针作为其中一个参数，类外没有this指针所以需要自己往函数里传参。 不允许重载的运算符：. * :: sizeof ?: 必须放在类内重载的运算符：() &#123;&#125; - &gt; = 当对象创建完之后再=才调用重载操作符函数，否则调用拷贝构造函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;using namespace std;class People &#123; int age;public: People(int a) &#123; age = a; &#125; People() &#123; age = 1; &#125; //=运算符重载(默认产生) People&amp; operator=(const People&amp; aa) &#123; this-&gt;age = aa.age; return *this; //eg:p3 = p2 = p1 //返回引用类型是因为，如果不是引用类型会运行拷贝构造函数， //即拷贝构造函数第三种调用时机， &#125; void operator=(const char* str) &#123; //c++中char*表示字符串必须加const cout &lt;&lt; str &lt;&lt; endl; //引用可加可不加，看需求 &#125; void operator+=(const People&amp; aa) &#123; this-&gt;age += aa.age; &#125; void operator++() &#123; //++p &#125; void operator++(int) &#123; //p++ &#125; int getAge();&#125;;int People::getAge() &#123; return age;&#125;void operator+=(People&amp; aa, int n) &#123;&#125;int main() &#123; People p1 = 10; //重载构造函数,相当于构造函数 People p2; //需要有一个无参的构造函数 People p3; p2 = p1; //&lt;===&gt; p2.operator=(p1); p3 = p2 = p1; //p2 = p1的返回值是p2 cout &lt;&lt; p2.getAge() &lt;&lt; endl; p3 = 20; //先People p = 20; 再p3.operator=(p); 即新创建了一个对象 p3 = &quot;你好&quot;; //函数重载 p2 += p1; return 0;&#125; 字符串 C++中操作字符串的头文件是cstring C++编译器会在初始化数组时，自动把 \\0放在字符串的末尾。 函数 目的 strcpy(s1,s2) 复制字符串 s2 到字符串 s1。 strcat(s1,s2) 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 + 号。 strlen(s1) 返回字符串 s1 的长度。 strcmp(s1,s2) 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。 strchr(s1,ch) 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 strstr(s1,s2) 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 String类 常用操作 s.empty() 如果 s 为空串，则返回 true，否则返回 false。 s.size() 返回 s 中字符的个数 s[n] 返回 s 中位置为 n 的字符，位置从 0 开始计数 s1 + s2 把 s1 和 s2 连接成一个新字符串， 返回新生成的字符串（+=也可以） s1 = s2 把 s1 内容替换为 s2 的副本 v1 == v2 比较 v1 与 v2 的内容，相等则返回 true，否则返 回 false !=, &lt;, &lt;=, &gt;, and &gt;= 保持这些操作符惯有的含义 实例12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; int main ()&#123; string str1 = &quot;runoob&quot;; string str2 = &quot;google&quot;; string str3; int len ; // 复制 str1 到 str3 str3 = str1; cout &lt;&lt; &quot;str3 : &quot; &lt;&lt; str3 &lt;&lt; endl; // 连接 str1 和 str2 str3 = str1 + str2; cout &lt;&lt; &quot;str1 + str2 : &quot; &lt;&lt; str3 &lt;&lt; endl; // 连接后，str3 的总长度 len = str3.size(); cout &lt;&lt; &quot;str3.size() : &quot; &lt;&lt; len &lt;&lt; endl; //打印str3第三个元素 cout &lt;&lt; str3[2] &lt;&lt; endl; return 0;&#125; 重写string类mystring.h文件123456789101112131415#pragma once#include&lt;iostream&gt;class mystring &#123;private: char * my_data;public: mystring(const char * str = 0); //通用构造函数 mystring(const mystring &amp; another); //拷贝构造函数 ~mystring(); //析构函数 mystring &amp; operator=(const mystring &amp; mys); //赋值函数 mystring operator+(const mystring &amp; mys); //重载操作符+ friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const mystring &amp; mys);&#125;;std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const mystring &amp; mys); mystring.cpp文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &quot;mystring.h&quot;#include&lt;string.h&gt;//new char(0);//申请了一个空间，与[]不同//构造函数mystring::mystring(const char * str) &#123; if (str == 0) &#123; my_data = new char(0); &#125; else &#123; my_data = new char[strlen(str) + 1]; strcpy(this-&gt;my_data, str); &#125;&#125;//拷贝构造函数mystring::mystring(const mystring &amp; another) &#123; this-&gt;my_data = new char[strlen(another.my_data) + 1]; strcpy(this-&gt;my_data, another.my_data);&#125;//析构函数mystring::~mystring() &#123; delete[]my_data;&#125;//重载操作符=mystring &amp; mystring::operator=(const mystring &amp; mys) &#123; delete[]this-&gt;my_data; this-&gt;my_data = new char[strlen(mys.my_data) + 1]; strcpy(this-&gt;my_data, mys.my_data); return *this;&#125;//重载操作符+mystring mystring::operator+(const mystring &amp; mys) &#123; mystring mys2; char * str = new char[strlen(this-&gt;my_data) + strlen(mys.my_data) + 1]; strcpy(str, this-&gt;my_data); strcpy(str + strlen(this-&gt;my_data), mys.my_data); delete[]mys2.my_data; //mys2构造时会创建一块空间，如果直接赋值，那块空间就丢了，会导致内存泄漏 mys2.my_data = str; return mys2;&#125;std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const mystring &amp; mys)&#123; os &lt;&lt; mys.my_data; return os;&#125; main.cpp文件1234567891011121314151617#include&lt;iostream&gt;#include&quot;mystring.h&quot;using namespace std;int main() &#123; mystring str1 = &quot;123asd&quot;; mystring str2 = str1; mystring str3; mystring str4(str1); str3 = str2 = str1; cout &lt;&lt; str3 &lt;&lt; &#x27; &#x27; &lt;&lt; str4 &lt;&lt; endl;//这一步需要对&lt;&lt;函数进行函数重载 str3 = str2 + str1; cout &lt;&lt; str3 &lt;&lt; endl; return 0;&#125; 输出结果 123123asd 123asd123asd123asd","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"笔记","slug":"C-C/笔记","permalink":"http://example.com/categories/C-C/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"}]},{"title":"LeetCode刷题记录：8.字符串转换整数(atoi)","slug":"LeetCode刷题记录：字符串转换整数-atoi","date":"2021-01-09T09:02:35.000Z","updated":"2021-01-18T12:42:48.256Z","comments":true,"path":"2021/01/09/LeetCode刷题记录：字符串转换整数-atoi/","link":"","permalink":"http://example.com/2021/01/09/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi/","excerpt":"","text":"请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下： 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0 。 注意： 本题中的空白字符只包括空格字符 &#39; &#39; 。 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31, 2^31 − 1]。如果数值超过这个范围，请返回2^31 − 1或−2^31 。 *示例 1:**12输入: &quot;42&quot;输出: 42 *示例 2:**1234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 *示例 3:**123输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。 *示例 4:**1234输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。 因此无法执行有效的转换。 *示例 5:**1234输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 *提示：** 0 &lt;= s.length &lt;= 200 s由英文字母（大写和小写）、数字、 、+、-和.组成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int myAtoi(char * a) &#123; //判空 if (a == NULL) &#123; return 0; &#125; //丢弃无用的开头空格字符 while (*a == &#x27; &#x27;) &#123; a++; &#125; //判断是否为负数 int index = 1; switch (*a) &#123; case &#x27;-&#x27;: index = -1; a++; break; case &#x27;+&#x27;: a++; break; &#125; //计数 long long sum = 0; unsigned long max = 2147483647; unsigned long min = 2147483648; while (*a != &#x27;\\0&#x27; &amp;&amp; *a != &#x27; &#x27;) &#123; if (*a &gt;= &#x27;0&#x27; &amp;&amp; *a &lt;= &#x27;9&#x27;) &#123; sum = sum * 10 + *a - &#x27;0&#x27;; //判断数字是否超过有符号整型范围 if (index == -1) &#123; if (sum &gt; min) &#123; return INT_MIN; &#125; &#125; else &#123; if (sum &gt; max) &#123; return INT_MAX; &#125; &#125; &#125; else if (*a = &#x27;.&#x27;) &#123; break; &#125; else &#123; //如果在数字中出现其他字符返回0 return 0; &#125; a++; &#125; return sum * index;&#125;int main() &#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); char *num = (char *)malloc(n * sizeof(char)); getchar(); gets(num); int re_num = myAtoi(num); printf(&quot;%d&quot;, re_num);&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"字符串","slug":"LeetCode/字符串","permalink":"http://example.com/categories/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"数据结构&算法笔记","slug":"数据结构-算法笔记","date":"2021-01-07T12:55:20.000Z","updated":"2021-01-21T06:55:14.631Z","comments":true,"path":"2021/01/07/数据结构-算法笔记/","link":"","permalink":"http://example.com/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","excerpt":"","text":"数据结构的定义 数据结构是相互之间存在一种或多种特定关系的数据元素的集合 数据 算法五个基本特性 输入 输出 有穷性 确定性 可行性 算法的要求 正确性 可读性 健壮性 时间复杂度和空间复杂度低 事前分析估算方法 在计算机程序编制前，依据统计方法对算法进行估算 一个程序的运行时间，依赖于算法的好坏和问题的输入规模，所谓问题输入规模是指输入量的多少 在分析程序的运行时间时，最重要的是把程序看成独立于程序设计语言的算法或一系列步骤 常见的时间复杂度O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n) 查找顺序查找顺序查找(Sequential Search)又叫线性查找，是最基本的查找技术，它的查找过程是:从表中第一个(或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录;如果直到最后一个(或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。 123456789int Sequential_Search_1(int *a, int len, int key) &#123; for (int i = 1; i &lt;= len; i++) &#123; if (a[i] == key) &#123; return i; &#125; &#125; return 0;&#125; 优化设置一个哨兵使其不需要每次让i与n比较（防止越界） 12345678910int Sequential_Search_2(int *a, int len, int key) &#123; int i; a[0] = key; // 设置a[0]为哨兵 i = len; while (a[i] != key) &#123; i--; &#125; return i;&#125; 时间复杂度最好的情况：第一个元素就是key O(1) 最坏的情况：最后一个元素是key O(n) 平均时间复杂度：n*(n+1)/2 O(n) 有序表查找折半查找折半查找（Binary Search)技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序（通常从小到大有序)，线性表必须采用顺序存储。折半查找的基本思想是:在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功;若给定值小于中间记录的关键字，则在中间记录的左半区继续查找;若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。 123456789101112131415161718int Binary_Search(int *a, int n, int key) &#123; int low = 1; int high = n; int mid; while (low &lt;= high) &#123; mid = (low + high) / 2; if (a[mid] == key) &#123; return mid; &#125; else if (a[mid] &lt; key) &#123; low = mid + 1; &#125; else &#123; high = mid - 1; &#125; &#125; return 0;&#125; 时间复杂度具有n个结点的完全二叉树的深度为$$\\left\\lfloor { { {\\log }_2}n} \\right\\rfloor + 1$$ 折半查找判定二叉树并不是完全二叉树，但同样相同的推导可以得出，最坏情况是查找到关键字或查找失败的次数为$$\\left\\lfloor { { {\\log }_2}n} \\right\\rfloor + 1$$故时间复杂度为$$O({\\rm{log}}n)$$注意：由于折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，比较适合折半查找。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。 插值查找插值查找(Interpolation Search)是折半查找的改进方案，是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式$$\\fracNaNNaN$$ 12345678910111213141516171819//插值查找int Interpolation_Search(int *a, int n, int key) &#123; int low = 1; int high = n; int mid = 0; while (low &lt;= high) &#123; mid = low + (key - a[low]) * (high - low) / (a[high] - a[low]); if (a[mid] == key) &#123; return mid; &#125; else if (a[mid] &lt; key) &#123; low = mid + 1; &#125; else &#123; high = mid - 1; &#125; &#125; return 0;&#125; 时间复杂度时间复杂度仍是$$O({\\rm{log}}n)$$,但对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多。反之，数组中如果分布类似{,1,2,00200….999998, 99999}这种极端不均匀的数据，用插值查找未必是很合适的选择。 排序时间复杂度快些归队：O(n*logn) 其中希尔是$$O(n_{}^{3/2})$$剩下的都是$$O(n_{}^2)$$ 稳定性快些选一堆 不稳定 内排序与外排序 根据在排序过程中待排序的记录是否全部被放置在内存中，排序分为:内排序和外排序。 内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。 外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。 时间性能在内排序中，主要进行两种操作:比较和移动。比较指关键字之间的比较。移动指记录从一个位置移动到另一个位置，移动可以通过改变记录的存储方式来予以避免。高效率的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。 辅助空间评价排序算法的另一个主要标准是执行算法所需要的辅助存储空间。辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。 算法的复杂性这里指的是算法本身的复杂度，而不是指算法的时间复杂度。算法过于复杂会影响排序的性能。根据排序过程中借助的主要操作，我们把内排序分为:插入排序、交换排序、选择排序和归并排序。 封装成类※ 封装成模板※ 冒泡排序（Bubble Sort） 交换排序 思想：两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止。 1234567891011121314void Sort::bubbleSort(std::vector&lt;int&gt;&amp; vec, int n) &#123; for (int j = n - 1; j &gt;= 1; j--) &#123; bool flag = false; for (int i = 0; i &lt; j; i++) &#123; if (vec[i] &gt; vec[i + 1]) &#123; std::swap(vec[i], vec[i + 1]); flag = true; &#125; &#125; if (flag = false) &#123; break; &#125; &#125;&#125; 时间复杂度 最好情况下：没有发生数据交换，时间复杂度为 $$ O(n) $$ 最坏情况下：待排序表为逆序，时间复杂度为 $$ O(n_{}^2) $$ 平均时间复杂度为 $$ O(n_{}^2) $$ 简单选择排序(Simple Selection Sort)通过n次关键字间的比较，从n-i+1个记录中选出关键字最大的记录，并和第n-i+1(1&lt;i&lt;n)个记录交换之。 12345678910111213void Sort::selectSort(vector&lt;int&gt;&amp; vec, int n) &#123; for (int j = n - 1; j &gt;= 1; j--) &#123; int maxIndex = 0; for (int i = 1; i &lt;= j; i++) &#123; if (vec[i] &gt; vec[maxIndex]) &#123; maxIndex = i; &#125; &#125; if (maxIndex != j) &#123; swap(vec[maxIndex], vec[j]); &#125; &#125;&#125; 时间复杂度$$O(n_{}^2)$$ 虽然时间复杂度和冒泡排序一样，但性能上要略优于冒泡 直接插入排序(Straight Insertion Sort)基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。 123456789101112void Sort::straightSort(vector&lt;int&gt;&amp; vec, int n) &#123; int i,j,temp; for (i = 1; i &lt; n; i++) &#123; if (vec[i] &lt; vec[i - 1]) &#123; //当插入有序表需要移动记录时 temp = vec[i]; //设置哨兵 for (j = i - 1; j &gt;= 0 &amp;&amp; vec[j] &gt; temp; j--) &#123; vec[j + 1] = vec[j]; //大于哨兵的记录后移 &#125; vec[j + 1] = temp; //插入到正确位置 &#125; &#125;&#125; 时间复杂度 最好的情况：本身已经有序，时间复杂度为 $$ O(n) $$ 最坏的情况：逆序，时间复杂度为 $$ O(n_{}^2) $$ 平均时间复杂度为 $$ O(n_{}^2) $$ 性能比冒泡和简单选择好 希尔排序 先使序列基本有序。所谓的基本有序,就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间。 采取跳跃分割的策略:将相距某个‘增量” 的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。 增量序列的最后一个增量值必须为1. 12345678910111213141516void Sort::shellSort(vector&lt;int&gt;&amp; vec, int n) &#123; int i, j; int gap = n / 2; //增量序列 while (gap &gt;= 1) &#123; for (i = gap + 1; i &lt;= n; i++) &#123; if (vec[i] &lt; vec[i - gap]) &#123; vec[0] = vec[i]; for (j = i - gap; j &gt; 0 &amp;&amp; vec[0] &lt; vec[j]; j -= gap) &#123; vec[j + gap] = vec[j]; &#125; vec[j + gap] = vec[0]; &#125; &#125; gap--; &#125;&#125; 时间复杂度当增量序列为$$dlta[k] = 2_{}^{t - k + 1} - 1(0 \\le k \\le t \\le \\left\\lfloor { { {\\log }2}(n + 1)} \\right\\rfloor )$$时，可以获得时间复杂度$$O(n{}^{3/2})$$ 堆排序（Heap Sort）利用堆(假设利用大顶堆)进行排序的方法。它的基本思想是，将待排序的序列构造成-一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走(其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的n-1个序列重新构造成-一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列了。 难点 如何由一个无序序列构建成-一个堆? 如果在输出堆顶元素后，调整剩余元素成为一个新的堆? 堆排序 1234567891011void Sort::heapSort(vector&lt;int&gt;&amp; vec, int n) &#123; int fa = (n / 2) - 1; //初始堆调整 while (fa &gt;= 0) &#123; heapAdjust(vec, fa--, n); &#125; for (int i = n - 1; i &gt; 0; i--) &#123; swap(vec[i], vec[0]); heapAdjust(vec, 0, i); &#125;&#125; 堆调整 123456789101112131415161718void Sort::heapAdjust(vector&lt;int&gt;&amp; vec, int fa, int maxindex) &#123; //数组从下标0开始存放 int ch; ch = 2 * fa + 1; while (ch &lt; maxindex) &#123; if (ch + 1 &lt; maxindex &amp;&amp; vec[ch] &lt; vec[ch + 1]) &#123; ch = ch + 1; &#125; else if (vec[fa] &lt; vec[ch]) &#123; swap(vec[fa], vec[ch]); fa = ch; ch = 2 * fa + 1; &#125; else &#123; break; &#125; &#125;&#125; 时间复杂度堆排序对原始记录的排序状态不敏感，最好、最坏和平均时间复杂度都是$$O(n\\log n)$$ 桶排序（基数排序）原理:将数值作为桶号，遍历整个数组，将相应的桶进行计数。数据较为密集时比较好。稳定。 第一步 遍历原数组，找到最大值max,并且申请max+1个桶,初始化都为0（下标从0到max），即vector&lt;int&gt;bucket(max+1,0); 第二步 遍历原数组，找到每个数值对应的桶号，并对桶计数++，即bucket[a[i]]++; 第三步 遍历桶数组，看对应的桶内计数为几就取出几个下标值，放到原数组，即 while(bucket[i]--) a[index++] = bucket[i]; 123456789101112131415161718192021void Sort::bucketSort(vector&lt;int&gt;&amp; vec, int n) &#123; //找到最大值 int bucket_max = vec[0]; for (int i = 1; i &lt; n; i++) &#123; if (vec[i] &gt; bucket_max) &#123; bucket_max = vec[i]; &#125; &#125; //将数据存入桶中 vector&lt;int&gt; bucket(bucket_max + 1, 0); for (int i = 0; i &lt; n; i++) &#123; bucket[vec[i]]++; &#125; //遍历桶 int j = 0; for (int i = 0; i &lt;= bucket_max; i++) &#123; while (bucket[i]--) &#123; vec[j++] = i; &#125; &#125;&#125; 时间复杂度O(n) 空间复杂度O(n) 快速排序(Quick Sort) 通过一趟排序将待排记录分割成独立的两部分，其中- -部分记录的关键字均比另一部分 记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。 每趟排序都会有一个元素达到最终位置 三色旗稳定","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"C语言例题7：输出和为s的数组元素","slug":"C语言例题7：输出和为s的数组元素","date":"2021-01-06T12:59:39.000Z","updated":"2021-01-11T10:27:10.874Z","comments":true,"path":"2021/01/06/C语言例题7：输出和为s的数组元素/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%987%EF%BC%9A%E8%BE%93%E5%87%BA%E5%92%8C%E4%B8%BAs%E7%9A%84%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0/","excerpt":"输出和为s的数组元素Description输入一个递增排序的数组和数字s.在数组中查找两个数，使得他们的和恰好为s。如果有多对数字的和等于s，输出两个数的乘积最小的","text":"输出和为s的数组元素Description输入一个递增排序的数组和数字s.在数组中查找两个数，使得他们的和恰好为s。如果有多对数字的和等于s，输出两个数的乘积最小的 Input输入第一个数 n 表示数组长度输入第二个数 s 表示两个数之和其余数组中的数按空格分开输入 Output输出满足条件的两个元素 解法思想 先从后向前找最后一个小于s的数记为j（可以减少主循环次数），从第一个元素开始到j依次两两相加，查找符合条件（和为s且乘积最小）的两个数 矩形面积，周长相等时，正方向面积大于长方形面积。故和相等时，差值越大乘积越小 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int n = 0; int target = 0; scanf(&quot;%d %d&quot;,&amp;n,&amp;target); int *nums = (int *)malloc(n*sizeof(int)); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;,&amp;nums[i]); &#125; int i = 0; int j = n - 1; while (i &lt; j) &#123; if (nums[i] + nums[j] &gt; target) &#123; j--; &#125; if (nums[i] + nums[j] &lt; target) &#123; i++; &#125; else if (nums[i] + nums[j] == target) &#123; printf(&quot;%d %d&quot;,nums[i],nums[j]); return 0; &#125; &#125; return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"习题","slug":"C-C/习题","permalink":"http://example.com/categories/C-C/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"C/C++习题","slug":"C-C-习题","permalink":"http://example.com/tags/C-C-%E4%B9%A0%E9%A2%98/"}]},{"title":"C语言例题6：查看亮灯情况","slug":"C语言例题6：查看亮灯情况","date":"2021-01-06T12:44:14.000Z","updated":"2021-01-11T10:27:25.281Z","comments":true,"path":"2021/01/06/C语言例题6：查看亮灯情况/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%986%EF%BC%9A%E6%9F%A5%E7%9C%8B%E4%BA%AE%E7%81%AF%E6%83%85%E5%86%B5/","excerpt":"查看亮灯情况Descriopion一条长廊里依次装有n(1 ≤ n ≤ 65535)盏电灯，从头到尾编号1、2、3、…n-1、n。 每盏电灯由一个拉线开关控制。开始，电灯全部关着。 有n个学生从长廊穿过。第一个学生把号码凡是1的倍数的电灯的开关拉一下； 接着第二个学生把号码凡是2的倍数的电灯的开关拉一下； 接着第三个学生把号码凡是3的倍数的电灯的开关拉一下； 如此继续下去，最后第n个学生把号码凡是n的倍数的电灯的开关拉一下。 n个学生按此规定走完后，长廊里电灯有几盏亮着。 注：电灯数和学生数一致。","text":"查看亮灯情况Descriopion一条长廊里依次装有n(1 ≤ n ≤ 65535)盏电灯，从头到尾编号1、2、3、…n-1、n。 每盏电灯由一个拉线开关控制。开始，电灯全部关着。 有n个学生从长廊穿过。第一个学生把号码凡是1的倍数的电灯的开关拉一下； 接着第二个学生把号码凡是2的倍数的电灯的开关拉一下； 接着第三个学生把号码凡是3的倍数的电灯的开关拉一下； 如此继续下去，最后第n个学生把号码凡是n的倍数的电灯的开关拉一下。 n个学生按此规定走完后，长廊里电灯有几盏亮着。 注：电灯数和学生数一致。 Input 1输入n个学生 Output 1输出当有n个学生的时候还有几盏灯亮着 解法碰过i号灯的人都是i的因子，当因子个数为奇数时灯亮。（完全平方数因子有重复，如：9 = 3 * 3） 12345678910111213#include&lt;stdio.h&gt;int main()&#123; int n &#x3D; 0; scanf(&quot;%d&quot;,&amp;n); int i &#x3D; 1; while(i * i &lt;&#x3D; n) &#123; i++; &#125; printf(&quot;%d&quot;,i-1); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"习题","slug":"C-C/习题","permalink":"http://example.com/categories/C-C/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"C/C++习题","slug":"C-C-习题","permalink":"http://example.com/tags/C-C-%E4%B9%A0%E9%A2%98/"}]},{"title":"C语言例题5：厄拉多塞筛选法","slug":"C语言例题5：厄拉多塞筛选法","date":"2021-01-06T12:40:00.000Z","updated":"2021-01-11T10:27:32.319Z","comments":true,"path":"2021/01/06/C语言例题5：厄拉多塞筛选法/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%985%EF%BC%9A%E5%8E%84%E6%8B%89%E5%A4%9A%E5%A1%9E%E7%AD%9B%E9%80%89%E6%B3%95/","excerpt":"厄拉多塞筛选法乘法运算的速度没有加法快西元前250年，希腊数学家厄拉多塞(Eeatosthese)想到了一个非常美妙的质数筛法，减少了逐一检查每个数的的步骤，可以比较简单的从一大堆数字之中，筛选出质数（素数）来，这方法被称作厄拉多塞筛法(Sieve of Eeatosthese)。","text":"厄拉多塞筛选法乘法运算的速度没有加法快西元前250年，希腊数学家厄拉多塞(Eeatosthese)想到了一个非常美妙的质数筛法，减少了逐一检查每个数的的步骤，可以比较简单的从一大堆数字之中，筛选出质数（素数）来，这方法被称作厄拉多塞筛法(Sieve of Eeatosthese)。 具体操作：先将 2~n 的各个数放入表中，然后在2的上面画一个圆圈，然后划去2的其他倍数；第一个既未画圈又没有被划去的数是3，将它画圈，再划去3的其他倍数；现在既未画圈又没有被划去的第一个数 是5，将它画圈，并划去5的其他倍数……依次类推，一直到所有小于或等于 n 的各数都画了圈或划去为止。这时，表中画了圈的以及未划去的那些数正好就是小于 n 的素数。 其实，当你要画圈的素数的平方大于 n 时，那么后面没有划去的数都是素数，就不用继续判了。如下图： Description输出1到1000以内所有素数 123456789101112131415161718#include &lt;stdio.h&gt;int main ()&#123; int nums[1001] &#x3D; &#123;0&#125; ; for (int i &#x3D; 2 ; i &lt;&#x3D; 1000 ; i++) &#123; if (nums[i] &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;证明是素数 printf( &quot;%d\\n&quot;, i); for (int j &#x3D; i + i; j&lt;&#x3D; 1000; j +&#x3D; i) &#123;&#x2F;&#x2F;把i的倍数都刷掉 nums[j]&#x3D; 1 ; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"习题","slug":"C-C/习题","permalink":"http://example.com/categories/C-C/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"C/C++习题","slug":"C-C-习题","permalink":"http://example.com/tags/C-C-%E4%B9%A0%E9%A2%98/"}]},{"title":"C语言例题4：股神","slug":"C语言例题4：股神","date":"2021-01-06T12:15:46.000Z","updated":"2021-01-11T10:27:38.770Z","comments":true,"path":"2021/01/06/C语言例题4：股神/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%984%EF%BC%9A%E8%82%A1%E7%A5%9E/","excerpt":"股神Description假设买入1元股票，股票的变化规律是第一天不变（0），第二天涨1元（1），第三天跌1元（-1），第四天涨1元（1），第五天涨1元（1），第六天跌1元（-1），第七天涨1元（1），第八天涨1元（1），第九天涨1元（1），第十天跌1元（-1）…求N天后的股票剩余价格","text":"股神Description假设买入1元股票，股票的变化规律是第一天不变（0），第二天涨1元（1），第三天跌1元（-1），第四天涨1元（1），第五天涨1元（1），第六天跌1元（-1），第七天涨1元（1），第八天涨1元（1），第九天涨1元（1），第十天跌1元（-1）…求N天后的股票剩余价格 法一12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; int n &#x3D; 0; int i &#x3D; 1; int j &#x3D; 2; int count &#x3D; 0; scanf(&quot;%d&quot;,&amp;n); while ( i + j &lt;&#x3D; n) &#123; i &#x3D; i + j; j &#x3D; j + 1; count++; &#125; printf(&quot;%d&quot;, n - 2 * count); return 0; &#125; 法二1234567891011121314151617181920#include&lt;stdio.h&gt;int main()&#123; int n &#x3D; 0; scanf(&quot;%d&quot;,&amp;n); int count &#x3D; 0; &#x2F;&#x2F;-1的总天数 int i &#x3D; 1; &#x2F;&#x2F;第i天为-1 int sum &#x3D; 0; for (; i &lt;&#x3D; n; i++) &#123; i &#x3D; 2*i + 1; count++; &#125; sum &#x3D; n - 2 * count;&#x2F; printf(&quot;%d&quot;,sum); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"习题","slug":"C-C/习题","permalink":"http://example.com/categories/C-C/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"C/C++习题","slug":"C-C-习题","permalink":"http://example.com/tags/C-C-%E4%B9%A0%E9%A2%98/"}]},{"title":"C语言例题3：求s=1+(1+2)+...+(1+2+3+...+n)","slug":"C语言例题3：求s-1-1-2-1-2-3-n","date":"2021-01-06T12:10:32.000Z","updated":"2021-01-11T10:27:44.197Z","comments":true,"path":"2021/01/06/C语言例题3：求s-1-1-2-1-2-3-n/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%983%EF%BC%9A%E6%B1%82s-1-1-2-1-2-3-n/","excerpt":"求s=1+(1+2)+(1+2+3)+…+(1+2+3+…+n)的值Description编写一个程序，求s=1+(1+2)+(1+2+3)+…+(1+2+3+…+n)的值","text":"求s=1+(1+2)+(1+2+3)+…+(1+2+3+…+n)的值Description编写一个程序，求s=1+(1+2)+(1+2+3)+…+(1+2+3+…+n)的值 123456789101112131415#include&lt;stdio.h&gt;int main()&#123; int a = 0; scanf(&quot;%d&quot;,&amp;a); int sum = 0; int j = 0; for (int i = 1; i &lt;= a; i++) &#123; j += i; sum = sum + j; &#125; printf(&quot;%d&quot;,sum); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"习题","slug":"C-C/习题","permalink":"http://example.com/categories/C-C/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"C/C++习题","slug":"C-C-习题","permalink":"http://example.com/tags/C-C-%E4%B9%A0%E9%A2%98/"}]},{"title":"C语言例题2：输出一个数的二进制有多少个1","slug":"C语言例题2：输出一个数的二进制有多少个1","date":"2021-01-06T12:03:22.000Z","updated":"2021-01-11T10:27:49.136Z","comments":true,"path":"2021/01/06/C语言例题2：输出一个数的二进制有多少个1/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%982%EF%BC%9A%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA1/","excerpt":"输出一个数的二进制有多少个1法一：依次消去二进制中的1，并计数","text":"输出一个数的二进制有多少个1法一：依次消去二进制中的1，并计数 1234567891011121314int main()&#123; int a = 0; int count = 0; scanf(&quot;&amp;d&quot;,&amp;a); while(a != 0) &#123; a = a &amp; (a - 1);//去掉二进制中倒数第一个1 count++; &#125; printf(&quot;%d&quot;,count); return 0;&#125; 法二：int整型变量有32位二进制代码，对每一位按位于1 12345678910111213int main()&#123; int a = 0; int count = 0; scanf(&quot;&amp;d&quot;,&amp;a); for( int i = 0; i &lt; 32; i++) &#123; if( 1 &lt;&lt; i &amp; a) count++; &#125; printf(&quot;%d&quot;,count); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"习题","slug":"C-C/习题","permalink":"http://example.com/categories/C-C/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"C/C++习题","slug":"C-C-习题","permalink":"http://example.com/tags/C-C-%E4%B9%A0%E9%A2%98/"}]},{"title":"C语言例题1：数值比较","slug":"C语言例题1：数值比较","date":"2021-01-06T11:55:18.000Z","updated":"2021-01-11T10:27:54.875Z","comments":true,"path":"2021/01/06/C语言例题1：数值比较/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%981%EF%BC%9A%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83/","excerpt":"数值比较Description输入两个整数，输出较大的值，要求不允许使用if，&lt;，&gt;，?运算符","text":"数值比较Description输入两个整数，输出较大的值，要求不允许使用if，&lt;，&gt;，?运算符 思想 123456789#include&lt;stdio.h&gt;int main()&#123; int a = 0; int b = 0; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); int f = (a - b) &gt;&gt; 31 &amp; 1; printf(&quot;%d&quot;,a - (a - b) * f); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"习题","slug":"C-C/习题","permalink":"http://example.com/categories/C-C/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"C/C++习题","slug":"C-C-习题","permalink":"http://example.com/tags/C-C-%E4%B9%A0%E9%A2%98/"}]},{"title":"设计模式笔记","slug":"设计模式笔记","date":"2021-01-06T09:17:36.000Z","updated":"2021-01-08T10:08:57.094Z","comments":true,"path":"2021/01/06/设计模式笔记/","link":"","permalink":"http://example.com/2021/01/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/","excerpt":"","text":"设计模式单例工厂简单工厂模式面向对象——活字印刷拿活字印刷举例子 可维护——可以改字 可复用——字并非只用一次，可在后来的印刷中使用 可拓展——可以加字 灵活性好——可随意排版 面向对象的好处通过封装、继承、多态把程序的耦合度降低，用设计模式使得程序更加灵活，容易修改，易于复用 封装使耦合度下降 紧耦合和松耦合代理策略模式模版方法","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"编程基础","slug":"编程基础","date":"2021-01-06T09:09:47.000Z","updated":"2021-01-08T10:10:39.067Z","comments":true,"path":"2021/01/06/编程基础/","link":"","permalink":"http://example.com/2021/01/06/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/","excerpt":"","text":"学习编程的基础四大件数据结构和算法学完之后要刷leetcode（剑指offer） 计算机网络tcp/ip协议栈（tcp/ip详解） 操作系统进程和线程并发和锁内存分布调度等等 （深入理解操作系统） 设计模式单例工厂代理策略模式模版方法（大话设计模式） 实践Linux操作系统掌握《linux就该这么学》 shell编程脚本 编译/调试工具GUN官方GCC和GDB文档《debugging with gdb 》中文版《跟我一起写makefile》陈皓 Linux平台上 gccmakefile《跟我一起写makefile》 要会写 gdb调试工具 Linux系统编程《unix环境高级编程》《linux高性能服务器编程》《posix多线程程序设计》 多线程编程网络编程（unix环境高级编程）（Linux高性能服务器编程）（posix多线程程序设计）","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"}],"tags":[{"name":"学习路线","slug":"学习路线","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"}]},{"title":"C++学习笔记1","slug":"C++学习笔记1","date":"2021-01-06T01:45:56.000Z","updated":"2021-01-15T15:14:02.812Z","comments":true,"path":"2021/01/06/C++学习笔记1/","link":"","permalink":"http://example.com/2021/01/06/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/","excerpt":"","text":"头文件C++中头文件没有.h 常用的头文件有cstdio，string，iostream。 处理格式化输入和输出的iostream库 ​ cin标准输入 ​ cout标准输出 ​ cerr标准错误 ​ clog产生程序执行的一般信息 12345678910#include&lt;iostream&gt; //input output streamusing namespace std;int main()&#123; int a = 100; int b = 100; cout &lt;&lt; a &lt;&lt; &#x27; &#x27; &lt;&lt; b &lt;&lt; &quot;hello&quot;; //泛型 return 0;&#125; cout是一个对象&lt;&lt;是cout的成员函数 1234567891011#include&lt;iostream&gt; //input output streamusing namespace std;int main()&#123; int n = 0; int v2 = 0; cin &gt;&gt; n &gt;&gt; v2; cout &lt;&lt; n &lt;&lt; &quot; and &quot; &lt;&lt; v2 &lt;&lt; endl; return 0;&#125; 输出结果 123132 456132 and 456 endl是一个特殊值，称为操纵符，将它写入输出流时，具有输出换行的效果，并刷新与设备相关联的缓冲区。通过刷新缓冲区，用户可立即看到写入到流中的输出。 经常在调试过程中插入输出语句，这些语句都应该刷新输出流。忘记刷新输出流可能会造成输出停留在缓冲区中，如果程序崩溃，将会导致程序错误推断崩溃位置。 命名空间三种方式 1234命名空间::print();using namespace 命名空间; //谨慎使用全局函数 ::print(); 作用防止变量或函数等重名，因为标准库定义的名字是定义在命名空间中， 所以我们可以按自己的意图使用相同的名字 。有重名情况需要在重名的东西前加要使用的命名空间名字::，::称为作用域限定符 1234567891011121314151617181920212223242526#include&lt;iostream&gt; //input output streamusing namespace std;namespace my1&#123; int a = 100; void print() &#123; printf(&quot;%d&quot;,a); &#125;&#125;namespace my2&#123; int a = 100; void print() &#123; printf(&quot;%d&quot;,a); &#125;&#125;using namespace my1;int main()&#123; print(); return 0;&#125; 123456789101112131415161718192021222324252627#include&lt;iostream&gt; //input output streamusing namespace std;namespace my1&#123; int a = 100; void print() &#123; printf(&quot;%d&quot;,a); &#125;&#125;namespace my2&#123; int a = 200; void print() &#123; printf(&quot;%d&quot;,a); &#125;&#125;using namespace my1;using namespace my2;int main()&#123; my1::print(); return 0;&#125; 全局函数与命名空间内函数重名1234567891011121314151617181920#include&lt;iostream&gt; //input output streamusing namespace std;namespace my1&#123; int a = 100; void print() &#123; printf(&quot;%d&quot;,a); &#125;&#125;void print()&#123; printf(&quot;%d&quot;,200);&#125;using namespace my1;int main()&#123; ::print(); //单写::就是使用全局空间 return 0;&#125; 新增变量类型bool只占一个字节 可以等于True或False 本质上时对char的封装 1bool b = false; 宽字符wchar_t1typedef short in wchar_t; 引用类型引用就是对象的另一个名字 特点※ 引用被创建的同时必须被初始化。（指针则可以在任何时候被初始化）。 不能有NULL引用，引用应该必须与合法的存储单元关联（指针则可以是NULL）。 一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。 本质上是对指针的封装 123int n = 100;int &amp;j = n; //j就是n，是同一个变量cout &lt;&lt; &amp;j &lt;&lt; &quot; &quot; &lt;&lt; &amp;n; 输出结果 10x61fe14 0x61fe14 j就是n，n就是j 例子交换两个变量 123456789101112void swap(int &amp;a, int &amp;b) &#123; //a,b和传入的参数是同一个变量 int t = a; a = b; b = t;&#125;int main() &#123; int a = 10; int b = 20; swap(a,b); cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; endl; return 0;&#125; 输出结果 120 10 强弱类型12345678int main()&#123; int n = 100; int x = 200; char *p = &amp;x;//这句话不合法，类型必须相同 char *q = (char *)malloc(sizeof(int));//这句合法，因为所有32位下的指针类型都是4个字节 return 0;&#125; 函数重载 相同声明域（都在全局或都在一个类下）函数名字相同但是参数列表不同（类型和个数不完全相同）。 只有返回值类型不同不算重载函数。 函数传入的参数必须能够被明确是调用的哪个函数。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;void func_1() &#123; cout &lt;&lt; &#x27;1&#x27; &lt;&lt; endl;&#125;void func_1(int a) &#123; cout &lt;&lt; a &lt;&lt; endl;&#125;void func_1(double b) &#123; cout &lt;&lt; b &lt;&lt; endl;&#125;void func_1(int&amp; c) &#123; cout &lt;&lt; c &lt;&lt; endl;&#125;void func_2() &#123; cout &lt;&lt; &#x27;2&#x27; &lt;&lt; endl;&#125;void func_2(int) &#123;//函数参数起不起名都行，如果函数内需要用到这个参数就需要起名。 cout &lt;&lt; &#x27;3&#x27; &lt;&lt; endl;&#125;int main() &#123; func_1(); //既有func_1(int&amp; c),还有func_1(int b)编译器不能明确调用的是哪个函数然后报错。 //func_1(12); //func_1(int&amp; c)引用类型是引用的变量，12是常量。 func_1(15.6); func_2(); func_2(12); return 0;&#125; 输出结果 12345611215.623 函数参数默认值 c++可以从后向前的设置参数的默认值(缺省值) 不能定义相同的函数，参数不同算不同的函数 调用函数时，必须能明确调用的是哪个函数 123456789101112131415161718#include&lt;iostream&gt;using namespace std;void func(int a, int b, int c, int d = 24) &#123; cout &lt;&lt; 1 &lt;&lt; endl;&#125;void func(int a, int b, int c = 10) &#123; cout &lt;&lt; 2 &lt;&lt; endl;&#125;void func(int a, int b = 12) &#123; cout &lt;&lt; 3 &lt;&lt; endl;&#125;int main() &#123; //func(12,35,56);//会报错，多个函数匹配传入的参数 func(12); return 0;&#125; 输出结果 123 类类与结构体区别class与struct在编译过程基本没有区别，只有缺省权限不同，class是私有，struct是共有。 成员成员变量与成员函数也称为属性和方法 书写格式类是抽象的，对象是实例 概念 描述 类成员函数 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 类访问修饰符 类成员可以被定义为public、private或 protected。默认情况下是定义为private。 构造函数&amp;析构函数 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。 拷贝构造函数 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 友元函数 友元函数可以访问类的private和protected成员。 内联函数 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。 this指针 每个对象都有一个特殊的指针this，它指向对象本身。 指向类的指针 指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。 静态成员 类的数据成员和函数成员都可以被声明为静态的。 访问修饰符 与结构体不同，类必须写访问修饰符public或private或protected。 缺省情况下默认是private，结构体默认是public。 私有成员变量不允许通过对象进行访问，但可以被共有成员函数访问。 访问修饰符 作用 public 公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值 private 私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。 protected protected（受保护）成员变量或函数与私有成员十分相似，但有一点不同，protected（受保护）成员在派生类（即子类）中是可访问的。 12345678910111213#include&lt;iostream&gt;using namespace std;class People&#123;public: int age; &#125;;int main()&#123; People p; p.age = 10; return 0;&#125; 属性（成员变量）下面的代码中People是类，p是对象 age、weight、sex、name是属性（成员变量） 12345678910111213141516#include&lt;iostream&gt;using namespace std;class People&#123;public: int age; int weight; int sex; char name[12];&#125;;int main()&#123; People p; p.age = 10; return 0;&#125; 方法（成员函数）私有成员变量不允许通过对象进行访问，但可以被公有成员函数访问。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;class People&#123;private: int age = 0; int weight; int sex; char name[12];public: int getAge() &#123; return age; &#125; void setAge() &#123; age++; &#125;&#125;;int main()&#123; People p; //p.age = 10; p.setAge(); int age = p.getAge(); cout &lt;&lt; age &lt;&lt; endl; return 0;&#125; 输出结果 121 成员函数可以定义在类定义内部，或者单独使用范围解析运算符 ::来定义。 thisthis代表调用当前函数的对象的地址 构造函数 构造函数是类的一种特殊成员函数，一般情况下，构造函数是专门用于初始化成员变量的，所以最好不要在构造函数中进行与对象的初始化无关的操作 构造函数的函数名一定与类的名称完全相同，而且没有返回值（不是说返回值是void或者int，而是说不允许指定返回值） 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;class People&#123;private: int age; int weight;public: //成员函数声明 People() //无参构造函数 &#123; age = 1; &#125; People(int w)//构造函数可以重载 &#123; weight = w; &#125; int getAge(); int getWeight();&#125;;//成员函数定义int People::getAge() &#123; return age;&#125;int People::getWeight() &#123; return weight;&#125;int main()&#123; People p;//创建对象时会运行构造函数,p是通过People()出生的 People xx(8);//xx是通过People(int w)出生的 //p.age = 10; cout &lt;&lt; p.getAge() &lt;&lt; &quot; &quot; &lt;&lt; xx.getWeight() &lt;&lt; endl; return 0;&#125; 输出结果 121 8 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;class People&#123;private: int age; int weight;public: //成员函数声明 People(int weight) &#123; age = 1; this-&gt;weight = weight; &#125; int getWeight();&#125;;//成员函数定义int People::getWeight() &#123; return weight;&#125;int main()&#123; People p(8); cout &lt;&lt; p.getWeight() &lt;&lt; endl; return 0;&#125; 输出结果 128 析构函数 只要是对象的生命期结束时，会自动启用析构函数。 析构函数不能重载。 ~类名 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class People&#123;private: int age; int weight; char *name;public: People() &#123; name = (char *)malloc(100); strcpy(name,&quot;123456&quot;); &#125; ~People()//不能重载 &#123; free(name); &#125;&#125;;int main()&#123; People p; return 0;&#125; 初始化列表 赋值先后顺序与书写顺序无关 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class People&#123;private: int age; int weight; char *name;public: People() : age(0),weight(8),name(NULL) &#123; name = (char *)malloc(100); strcpy(name,&quot;123456&quot;); &#125; ~People()//不能重载 &#123; free(name); &#125;&#125;;int main()&#123; People p; return 0;&#125; 拷贝构造函数※拷贝构造函数是特殊的成员函数 调用时机1. 通过使用另一个同类型的对象来初始化新创建的对象1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class People&#123;private: int age; int weight; char *name;public: //成员函数声明 People() &#123; &#125; People(const People&amp; p)//拷贝构造函数 &#123; this-&gt;age = p.age; &#125; void setAge(int age); int getAge();&#125;;//成员函数定义void People::setAge(int age) &#123; this-&gt;age = age;&#125;int People::getAge() &#123; return age;&#125;int main()&#123; People p1; p1.setAge(10); cout &lt;&lt; p1.getAge() &lt;&lt; endl; People p2(p1); cout &lt;&lt; p2.getAge() &lt;&lt; endl; return 0;&#125; 输出结果 1231010 2. 复制对象把它作为参数传递给函数12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class People&#123;private: int age; int weight; char *name;public: People() &#123; &#125; People(const People&amp; p)//拷贝构造函数 &#123; this-&gt;age = p.age; cout &lt;&lt; &quot;拷贝&quot; &lt;&lt; endl; &#125; ~People() &#123; cout &lt;&lt; &quot;game over&quot; &lt;&lt; endl; &#125; void setAge(int age); int getAge();&#125;;void People::setAge(int age) &#123; this-&gt;age = age;&#125;int People::getAge() &#123; return age;&#125;void printPeople(People p)&#123; cout &lt;&lt; p.getAge() &lt;&lt; endl;&#125;int main()&#123; People p; p.setAge(10); printPeople(p); return 0;&#125; 输出结果 12345拷贝10game overgame over 创建出了两个对象 主函数构造一个 printPeople构造一个 先输出的是printPeople的析构函数 后输出的是主函数的析构函数 3. 复制对象，并从函数返回这个对象1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class People&#123;private: int age; int weight; char *name;public: People() &#123; &#125; People(const People&amp; p)//拷贝构造函数 &#123; this-&gt;age = p.age; cout &lt;&lt; &quot;拷贝&quot; &lt;&lt; endl; &#125; ~People() &#123; cout &lt;&lt; &quot;game over&quot; &lt;&lt; endl; &#125; void setAge(int age); int getAge();&#125;;void People::setAge(int age) &#123; this-&gt;age = age;&#125;int People::getAge() &#123; return age;&#125;People printPeople(People p)&#123; return p;&#125;int main()&#123; People p; p.setAge(10); People t = printPeople(p); cout &lt;&lt; t.getAge() &lt;&lt; endl; return 0;&#125; 输出结果 1234567拷贝拷贝game over10game overgame over 第一个拷贝是printPeople(p)传入参数时拷贝构造函数输出的 第二个拷贝是将printPeople(p)返回值赋值给t时拷贝构造函数输出的 第一个game over是printPeople传入参数创造出的对象结束时输出的 第二个是t结束时输出的 第三个是p结束时输出的 浅拷贝123456789101112131415161718192021222324252627282930using namespace std;class Student &#123; char* name;public: Student() &#123; &#125; Student(const char* name) &#123; this-&gt;name = (char *)malloc(12); strcpy(this-&gt;name, name); cout &lt;&lt; name &lt;&lt; endl; &#125; Student(const Student &amp;rgh) &#123;//默认拷贝构造函数 this-&gt;name = rgh.name; &#125; ~Student() &#123; free(this-&gt;name); &#125; char* get_name();&#125;;char* Student::get_name() &#123; return name;&#125;int main() &#123; Student stu(&quot;abc&quot;); Student ss(stu); cout &lt;&lt; stu.get_name() &lt;&lt; endl;&#125; 输出异常。空间被释放了两次。 深拷贝12345678910111213141516171819202122232425262728293031using namespace std;class Student &#123; char* name;public: Student() &#123; &#125; Student(const char* name) &#123; this-&gt;name = (char *)malloc(12); strcpy(this-&gt;name, name); cout &lt;&lt; name &lt;&lt; endl; &#125; Student(const Student &amp;rgh) &#123;//默认拷贝构造函数 this-&gt;name = (char* )malloc(12); strcpy(this-&gt;name,name); &#125; ~Student() &#123; free(this-&gt;name); &#125; char* get_name();&#125;;char* Student::get_name() &#123; return name;&#125;int main() &#123; Student stu(&quot;abc&quot;); Student ss(stu); cout &lt;&lt; stu.get_name() &lt;&lt; endl;&#125; 输出结果 12abcabc 防止使用拷贝构造函数拷贝函数私有化。 12private: Student(const Student &amp;rgh); 为什么参数是引用类型防止循环拷贝进入死循环。 友元函数 类的友元函数是定义在类外部，但有权访问类的所有私有private成员和保护protected成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。 友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。 如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend。 一般情况下不使用，会破坏封装性 主函数也可以设成友元函数 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;class People&#123;private: int age;public: //成员函数声明 void setAge(int age); //友元函数声明 friend int getAge(People p);&#125;;//成员函数定义void People::setAge(int age) &#123; this-&gt;age = age;&#125;//友元函数定义int getAge(People p) &#123; return p.age;&#125;int main() &#123; People p; p.setAge(20); int age = getAge(p); cout &lt;&lt; age &lt;&lt; endl;&#125; 注意：printWidth() 不是任何类的成员函数 输出结果 1220 友元类1234567891011class People &#123; int age; frined class Animal;&#125;;class Animal &#123;public: void printAge(People&amp; p);&#125;;void Animal::printAge(People&amp; p) &#123; cout &lt;&lt; p.age &lt;&lt; endl;&#125; 静态成员变量/函数 静态成员变量必须在类外初始化 不能在类中使用 静态成员是属于类的，不是对象的 可以不通过对象访问，可以直接通过类访问 静态成员函数只能访问静态成员变量 因为静态成员函数属于类，故没有this。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;class People &#123;public: int age; static int water; //静态成员变量 void drink(); static void drink_2(); //静态成员函数&#125;;int People::water = 100;void People::drink() &#123; water--;&#125;void People::drink_2() &#123; //age = 100; water--;&#125;int main() &#123; People p1; p1.drink(); cout &lt;&lt; p1.water &lt;&lt; endl; People p2; p2.drink(); cout &lt;&lt; p2.water &lt;&lt; endl; cout &lt;&lt; People::water &lt;&lt; endl; //这种形式多为静态成员 People::drink_2(); cout &lt;&lt; p1.water &lt;&lt; endl; return 0;&#125; 输出结果 1234599989897 如果想通过静态成员函数访问非静态成员变量需要设置参数 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;class People &#123;public: int age; static int water; //两种传参方法 static void setAge(People* p, int age); static void setAge_2(People&amp; p, int age);&#125;;int People::water = 100;void People::setAge(People* p, int age) &#123; p-&gt;age = age;&#125;void People::setAge_2(People&amp; p, int age) &#123; p.age = age;&#125;int main() &#123; People p; p.setAge(&amp;p, 10); cout &lt;&lt; p.age &lt;&lt; endl; p.setAge_2(p, 20); cout &lt;&lt; p.age &lt;&lt; endl; return 0;&#125; 输出结果 1231020 嵌套类/内部类12345678910111213class People &#123;public: class babe &#123; public: int age; &#125;; babe b;&#125;;int main()&#123; People::babe b; b.age = 1; return 0;&#125; 内联函数 C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。 对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。 如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。 在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。 析构函数不能是内联函数 内联函数可以看作是宏函数 内联函数应尽可能短小 作用是效率高 1234567class People &#123; int age;public: inline void printAge() &#123; cout &lt;&lt; age &lt;&lt; endl; &#125;&#125;; 既然宏函数和内联函数效率高为什么不把所有函数都设成宏函数 宏多，编译时间长 常函数1234567class People &#123; int age;public: int getAge() const &#123; //不可修改类成员变量 return age; &#125;&#125;;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"笔记","slug":"C-C/笔记","permalink":"http://example.com/categories/C-C/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"}]},{"title":"C语言学习笔记","slug":"C语言学习笔记","date":"2021-01-05T08:50:02.000Z","updated":"2021-01-14T16:01:30.660Z","comments":true,"path":"2021/01/05/C语言学习笔记/","link":"","permalink":"http://example.com/2021/01/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"主函数main函数的返回值类型必须是int，这样返回值才能传递给程序的激活者（如操作系统）。如果main函数的最后没有写return语句的话，C99 规定编译器要自动在生成的目标文件中（如 exe 文件）加入return 0; ，表示程序正常退出。任何其他非零的返回值都有操作系统定义的含义。通常非零返回值表明有错误出现。每一种操作系统都有自己的方式告诉用户main函数返回什么内容。 变量类型 int整型（通常为 16 位，其取值范围在-32768～32767 之间，也有用 32 位表示的int类型） float浮点型（通常是 32 位，它至少有 6 位有效数字，取值范围一般在 10-38～1038之间） char字符——一个字节 short短整型 long长整型 double双精度浮点型 在 C 语言及许多其它语言中，整数除法操作将执行舍位，结果中的任何小数部分都会被舍弃。但是，如果某个算术运算符有一个浮点型操作数和一个整型操作数，则在开始运算之前整型操作数将会被转换为浮点型。 const1234567891011int main() &#123; int a = 100; int b = 200; int *const p1 = &amp;a;//const挨着p，即p不可修改 const int * p2 = &amp;a;//const挨着*p，即*p不可修改 const int * const p3 = &amp;a;//都挨着，都不可修改 //p1 = &amp;b; //*p2 = 100; return 0;&#125; 类型转换unsighed类型unsighed类型只能是正数或0 unsigned比int高级，n &lt;= i时n被隐式类型转换，无符号数负数变为最大值。 12345678910111213#include&lt;stdio.h&gt;void test(int n)&#123; for (unsigned int i = 0; n &lt;= i; n--) &#123; printf(&quot;%d&quot;,n); &#125;&#125;int main()&#123; test(10); return 0;&#125; 输出结果 1死循环 1.强制类型转换123int a = 2;int b = 3;printf(&quot;%f&quot;,(float)a / b); 2.隐式类型转换123int a = 2;int b = 3;printf(&quot;%f&quot;,(a * 1.0) / b); 符号常量 在程序中使用”幻数”-就是具体的数，反映不出数字所代表的意义-无法向以后阅读该程序的人提供什么信息，使程序的修改变得更加困难。处理这种幻数的一种方法是赋予它们有意义的名字。#define指令可以把符号名（或称为符号常量）定义为一个特定的字符串。 1#define 名字 替换文本 程序中出现的所有在#define中定义的名字（既没有用引号引起来，也不是其它名字的一部分）都将用相应的替换文本替换。其中，名字与普通变量名的形式相同：它们都是以字母打头的字母和数字序列；替换文本可以是任何字符序列，而不仅限于数字。 符号常量名通常用大写字母拼写，这样可以很容易与用小写字母拼写的变量名相区别。注意，#define指令行的末尾没有分号。 运算符位运算符 按位与&amp; 按位或`` `` 按位异或^ 按位取反~ 左移运算符&lt;&lt; 左移1位相当于乘2 右移运算符&gt;&gt; 右移1位相当于除2 例题计算2^0 + 2^1 + 2^2 + 2^3 + 2^4 + … + 2^n的结果1234567int main()&#123; int n = 0; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%d&quot;,1 &lt;&lt; (n + 1) - 1); return 0;&#125; &amp;&amp;和||和!当&amp;&amp;前为0时不运行&amp;&amp;后面的 当||前不为0时不运行||后面的 12345678#include&lt;stdio.h&gt;int main()&#123; int a = 0, b = -1; printf(&quot;%d %d %d\\n&quot;, a++ &amp;&amp; b++, a, b); printf(&quot;%d %d %d&quot;, a++ || b++, a, b); return 0;&#125; 输出结果 120 1 -11 2 -1 三步运算符当a&gt;b成立返回1否则返回-1 1return a &gt; b ? 1 : -1 C语言运算符优先级 逻辑语句switch…case…break switch必须是整型 case必须是整型常量 case分支的值不能相同 break不可忽视 如果现在case分支中定义一个变量，加一个括号 所有case分支条件都不满足，那么执行default分支 12345678910111213141516171819#include&lt;stdio.h&gt;int main() &#123; int a; scanf(&quot;%d&quot;,&amp;a); switch(a) &#123; case 1: printf(&quot;%d&quot;,a); break; case 2: &#123; int b = 10; printf(&quot;%d&quot;,b); break; &#125; default: printf(&quot;输入有误&quot;)； break; &#125;&#125; goto用法C语言提供了可以随意滥用的goto语句以及标记跳转位置的标号。可以跳出多重循环。 例子求200以内的素数 12345678910111213141516171819202122#include&lt;stdio.h&gt;int main()&#123; int j = 0; for (int i = 2; i &lt;= 200; i++) &#123; int j = 2; while (j &lt; i) &#123; if (i % j == 0) //当i能被除自己和1意外的数字整除时跳出循环。 &#123; goto Tiaoguo; &#125; j++; &#125; printf(&quot;%d\\n&quot;,i); Tiaoguo: continue; &#125; return 0;&#125; 输出结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445462357111317192329313741434753596167717379838997101103107109113127131137139149151157163167173179181191193197199 指针基础房子理论变量的三大要素1.名字2.空间3.地址 两种操作1.读2.写 指针变量p中放的是谁的地址，*p就是谁 12345int a = 10;int* p = &amp;a;//指针变量:用来存储a的地址printf(&quot;%d\\n&quot;,*p);*p = 20;printf(&quot;%d\\n&quot;,a); 输出结果 121020 指针的运算1234567891011int main()&#123; int nums[10] = &#123;0, 1, 2, 3, 4, 5&#125;; int* p = nums; p++;//p = p + 1*sizeof(int); printf(&quot;%d &quot;, sizeof(int)); printf(&quot;%d &quot;, &amp;nums[0]); printf(&quot;%d &quot;, &amp;nums[1]); printf(&quot;%d &quot;, &amp;nums[2]); return 0;&#125; 指针变量的大小32位编译环境下是4个字节64位编译环境下是8个字节 函数函数指针123456789101112131415161718192021#include&lt;stdio.h&gt;int f1(float f) &#123;&#125;int* f2(char c,int i) &#123; printf(&quot;f2&quot;);&#125;int f3(float f) &#123;&#125;int f4(float f) &#123;&#125;typedef int*(*pFun)(char, int);int main() &#123; //函数指针 int(*pf)(float) = f1;//与f1,f3,f4匹配 int*(*pd)(char, int) = f2; f2(&#x27;1&#x27;, 1); (*pd)(&#x27;1&#x27;, 1); pFun p = &amp;f2;&#125; 输出结果 1f2f2 数组[]的意思*(nums + i) &lt;===&gt;nums[i] 数组的名字代表的是数组第一个元素的地址（首地址）。 12345678#include&lt;stdio.h&gt;int main() &#123; int a[4] = &#123; 1,2,3,4 &#125;; int *ptr = (int *)(&amp;a + 1); // 1 * 4 * 4 printf(&quot;%d&quot;, *(ptr - 1)); //a 数组首地址 //&amp;a 数组的地址&#125; 14 数组传参数组传参过程中，数组int nums[]会退化成指针int *nums。 12345678void fun(int* nums, int n)&#123;&#125;int main()&#123; int nums[] &#x3D; &#123;1,2,3,4&#125;; fun(nums,sizeof(nums)&#x2F;sizeof(int));&#125; 例题打乱顺序数组的顺序1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;void printArray (int *arry, int n)&#123; for (int i = 0; i&lt; n; i++)&#123; printf (&quot;%d &quot;, arry[i]); &#125;&#125;int main()&#123; int arry[11] = &#123; 1,2,3,4,5,6,7,8,9,10,11&#125;; srand(time(0));//种随机种子 for (int i = 0; i &lt; 11; i++) &#123; int r = rand() % 11; int t = arry[i]; arry[i] = arry[r]; arry[r] = t; &#125; printArray(arry, 11) ; return 0; &#125; 字符串 字符串用&quot;&quot; ASCII表 12345678#include&lt;stdio.h&gt;int main()&#123; printf(&quot;%d&quot;,&quot;abcdefghi&quot;); printf(&quot;\\n&quot;); printf(&quot;%d&quot;,*&quot;abcdefghi&quot;); return 0;&#125; 输出结果 12421068897 字符 char类型在内存中占1个字节字符用单引号&#39;&#39; 0，’0’,’\\0’1234567891011121314#include&lt;stdio.h&gt;int main()&#123; char c = &#x27;0&#x27;; printf(&quot;%c\\n&quot;,c); //0 printf(&quot;%d\\n&quot;,c); //48 c = 0; printf(&quot;%c\\n&quot;,c); // printf(&quot;%d\\n&quot;,c); //0 c = &#x27;\\0&#x27;; printf(&quot;%c\\n&quot;,c); // printf(&quot;%d\\n&quot;,c); //0 return 0;&#125; 转义字符1234567891011#include &lt;stdio.h&gt;int main ( )&#123; char c = &#x27;\\&#x27;&#x27;; c =&#x27;\\\\&#x27;; c =&#x27;\\n&#x27;; c = &#x27;\\t&#x27;; c = &#x27;\\a&#x27;; printf( &quot;%c&quot;, c); return 0;&#125; &quot;&quot;代表的是字符串中首个字符的地址1234567#include&lt;stdio.h&gt;int main()&#123; printf(&quot;%d\\n&quot;,&quot;abcdefghi&quot;);//字符串实际上时第一个字符的地址，即字符串的首地址 printf(&quot;%d\\n&quot;,*&quot;abcdefghi&quot;);//*&quot;abcdefghi&quot;即为a return 0;&#125; 输出结果 12421068897 为什么使用char*存储字符串12345678#include &lt;stdio.h&gt;int main()&#123; char* p = &quot;abcdefghi&quot;; p++;//p = p + sizeof(char)在遍历字符串的时候指针变量偏移一个字节 printf(&quot;%c&quot;, *p); return 0;&#125; 输出结果 1b 注意char array[] = &#123;&#39;c&#39;,&#39;h&#39;,&#39;i&#39;,&#39;n&#39;,&#39;a&#39;&#125;;和char array[] = &quot;china&quot;;不同，第一种数组大小是5，第二种数组大小是6比第一种多一个元素\\0 计算字符串长度 \\012:\\0后接八以内数字表示八进制 \\x12:\\x后接数字或abcdef表示十六进制 strlen()以\\0作为字符串结束标志 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char* p = &quot;a\\0\\n\\012ab0&quot;; printf (&quot;%d &quot;, sizeof(p)) ; //8 64位系统字符串占8个字节 printf (&quot;%d &quot;, sizeof (&quot;a\\0\\n\\012ab0&quot;)); //8 //a 0 \\n \\012 a b 0 \\0 int n = strlen(p); printf (&quot;%d &quot;, n); //1 //a \\0 strlen()以\\0作为字符串结束标志,其中\\0不计入长度 p++; p++; n=strlen (p) ; printf(&quot;%d &quot;, n); //5 // \\n \\012 a b 0 \\0 return 0;&#125; 输出结果 18 8 1 5 字符数组和字符串常量的区别常量 常量不可修改 整型常量 10 100 字符常量 ‘a’ ‘c’ 浮点常量 1.1 1.01 字符串常量 “asdfd” 地址常量 变量的地址 数组名字 函数名字 1234567891011121314151617#include&lt;stdio.h&gt;int main()&#123; char* p = &quot;a\\0\\n\\012ab0&quot;; //字符串常量 char b[10] = &quot;a\\0\\n\\012ab0&quot;; //字符数组 printf(&quot;%d &quot;,sizeof(p)); //8 printf(&quot;%d &quot;, sizeof(b)); //10 //p++; //b++; //b为数组名是常量不允许修改，该语句有错 //*p++; //*b++; //b++先执行后执行*，产量不允许修改，同上 //(*p)++; //p存储的是字符串中第一个字符的地址，字符串存放在常量区是常量，不允许修改 //(*b)++; return 0;&#125; gets函数 gets函数只有一个参数。参数类型为char*型，即str可以是一个字符指针变量名，也可以是一个字符数组名。 gets()函数的功能是从输入缓冲区中读取一个字符串存储到字符指针变量str所指向的内存空间。 gets()函数不仅比scanf简洁，而且，就算输入的字符串中有空格也可以直接输入，不用像scanf那样要定义多个字符数组。 gets(str);完全可以取代:scanf(&quot;%s&quot;, string); 12345678#include&lt;stdio.h&gt;int main()&#123; char *gets(char *str); char a[50]; gets(a); return 0;&#125; 123456789# include &lt;stdio.h&gt;int main(void)&#123; char str[20] = &quot;\\0&quot;; //字符数组初始化\\0 printf(&quot;请输入字符串：&quot;); gets(str); printf(&quot;%s\\n&quot;, str); return 0;&#125; 输出结果 12请输入字符串：hello the worldhello the world 字符数组的两种遍历方式不同点参考上面《字符数组和字符串常量的区别》 123456789101112131415161718192021#include&lt;stdio.h&gt;int main()&#123; char str[20] = &quot;&quot;; gets(str); int i = 0; while( str[i] != &#x27;\\0&#x27;) &#123; printf(&quot;%c&quot;,str[i]); i++; &#125; char *p = str; while ( *p != &#x27;\\0&#x27;) &#123; printf(&quot;%c&quot;,*p); p++; &#125; return 0;&#125; 字符串函数常见操作 指针变量判空 最后赋值&#39;\\0&#39; 返回值（目的地址）以便支持链式操作 例题1.字符串拷贝123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;char* m_strcpy(char* des, const char* src)&#123; //1.判断指针变量是否为NULL if (des == 0 || src == 0) &#123; return 0;//结束 &#125; //2.字符串拷贝 int i = 0; for (i = 0; src[i] != &#x27;\\0&#x27;; i++) &#123; des[i] = src[i]; &#125; //3.赋值&#x27;\\0&#x27; des[i] = &#x27;\\0&#x27;; //4.返回值目的地址 return des; //支持链式操作&#125;int main()&#123; char src[100] = &quot;&quot;; gets(src); char des[100] = &quot;&quot;; //strcpy(des,src); m_strcpy(des, src); printf(&quot;%s&quot;, des); return 0;&#125; 内存管理常量区特点： 军事管理区，不可修改 常量区空间没有名字 整型常量 10 20 -10 浮点常量 1.2 1.001 字符常量 &#39;a&#39; &#39;0&#39; &#39;\\0&#39; 字符串常量 &quot;adjkls&quot; &quot;56as&quot; 地址常量 int a; &amp;a 数组名 函数名 栈区特点： 租的房子，房子到期自动回收 访问速度快 空间少 作用域和生命周期从定义的位置开始到&#39;&#125;&#39; 常用于局部变量、函数参数 全局区全局变量 特点 局部大于全局（当局部变量和全局变量重名时局部变量优先） 初始化默认为0 生命周期为程序开始到程序结束 作用域为整个项目 引用其他文件中的全局变量 123456789101112131415/mian.c/#include&lt;stdio.h&gt;int g_value;int main()&#123; printf(&quot;%d&quot;,g_value); return 0;&#125;/*a.c*/extern int g_value;void print()&#123; g_value = 100; printf(&quot;%d&quot;,g_value);&#125; 静态区静态局部变量 生命周期从程序开始到程序结束 作用域到&#39;&#125;&#39; 函数结束不释放※ 只被初始化一次※ 123456789101112131415#include&lt;stdio.h&gt;int fun()&#123; int a = 10; static int s = 10; printf(&quot;%d &quot;, a++); printf(&quot;%d &quot;, s++);&#125;int main()&#123; fun();//10 10 fun();//10 11 return 0;&#125; 静态全局变量 生命周期从程序开始到程序结束 作用域为当前文件 堆区特点 买的房子，不会自动释放 不会自动释放 容量大 访问速度慢 堆区空间没有名字 用完需要释放 1234567891011121314#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main()&#123; char* p = malloc(400);//在堆区申请空间（买房子） //返回值为地址，不一定是char，但一定是* //char* 房子被分为400份，一份1个字节 //int* 房子被分为100份，一份4个字节 strcpy(p,&quot;123456&quot;); //房子不用是记得释放 free(p); return 0;&#125; 注意 不要访问越界 不要忘记释放空间 GetMemory笔试题Test112345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void GetMemory1(char *p) &#123; p = (char *)malloc(100);//强制类型转换&#125;void Test1() &#123; char *str = NULL; GetMemory1(str); strcpy(str, &quot;hello world&quot;); printf(str);&#125;int main() &#123; Test1(); return 0;&#125; 访问空指针，异常退出 解决办法1123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char *GetMemory1(char *p) &#123; p = (char *)malloc(100); return p;&#125;void Test1(void) &#123; char *str = NULL; str = GetMemory1(str); strcpy(str, &quot;hello world&quot;); printf(str); free(str);&#125;int main() &#123; Test1(); return 0;&#125; 解决办法21234567891011121314151617#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void GetMemory1(char **p) &#123; //二级指针变量**p *p = (char *)malloc(100);//强制类型转换&#125;//p存放的是str的地址void Test1() &#123; char *str = NULL; GetMemory1(&amp;str); strcpy(str, &quot;hello world&quot;); printf(str); free(str);&#125;int main() &#123; Test1(); return 0;&#125; Test212345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char *GetMemory2(void) &#123; char p[] = &quot;hello world&quot;; return p;&#125;void Test2(void) &#123; char *str = NULL; str = GetMemory2(); printf(str);&#125;int main() &#123; Test2(); return 0;&#125; 字符数组在栈区分配，函数结束被释放 Test312345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char *GetMemory3 (void) &#123; char *p = &quot;hello world&quot;;//字符串是常量，不会改变 故虽然p被释放但常量空间不释放 return p;&#125;void Test3 (void) &#123; char *str = NULL; str = GetMemory3(); printf(str);&#125;int main() &#123; Test3(); return 0;&#125; 输出结果 1hello world Test412345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char *GetMemory4 (void) &#123; static char p[] = &quot;hello world&quot;; return p;&#125;void Test4 (void) &#123; char *str = NULL; str = GetMemory4(); printf(str);&#125;int main() &#123; Test4(); return 0;&#125; 输出结果 1hello world 静态局部变量不会被释放空间，生命周期是全局的 Test5123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void Test5 (void) &#123; char *str = (char *)malloc(400); strcpy(str, &quot;hello&quot;); free(str); //str = NULL; if (str != NULL) &#123; strcpy(str, &quot;world&quot;); printf(str); &#125;&#125;int main() &#123; Test5(); return 0;&#125; 输出结果 1world str被free后变为野指针，空间被释放，但仍存储着房子的地址 free是剥夺变量房子的使用权，但变量仍记得房子地址 平时记得买完房子free记得置空str = NULL; 内存已经被释放，访问野指针造成内存泄漏 指针在free后未赋值 NULL，便会使人以为是合法的。它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。※ Test612345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void Test6 (void) &#123; char *str = (char *)malloc(400); strcpy(str, &quot;hello&quot;); str += 6; free(str); if (str != NULL) &#123; strcpy(str, &quot;world&quot;); printf(str); &#125;&#125;int main() &#123; Test6(); return 0;&#125; str += 6;后地址改变free卖的是别人的房子 出现异常，释放空间不对。 结构体结构体定义123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct STUDENT&#123; int number; int age; int weight; char s;&#125;student; //student为全局变量typedef struct STUDENT1&#123; char a; int weight; char s;&#125;student1; //student1等于STUDENT1int main()&#123; student.age = 10; struct STUDENT abc = &#123;1001, 22, 110, &#x27;M&#x27;&#125;; //初始化结构体 student1 bcd = &#123;1001, 22, 110, &#x27;M&#x27;&#125;; //等于struct student bcd = &#123;1001, 22, 110, &#x27;M&#x27;&#125;; //通常用typedef sturct,方便 printf(&quot;%d %d %d %c &quot;,abc.number,abc.age,abc.weight,abc.s); return 0;&#125; 输出结果 11001 22 110 M 字节对齐 按照最长的成员对齐 保证整数倍地址对齐（比如：short占两个字节不能放在奇数地址，char随便放奇偶都可以） 12345typedef struct STUDENT&#123; int a; char c;&#125;student; 123456typedef struct STUDENT&#123; char s; int a; char c;&#125;student; 1234567typedef struct STUDENT&#123; int a; char s; char c; short d; //short占两个字节&#125;student; 1234567typedef struct STUDENT&#123; int a; char s; short d; char c;&#125;student; 12345678typedef struct STUDENT&#123; int a; long long c; //long long占八个字节 char d; int b; short s;&#125;student; 1234567typedef struct STUDENT&#123; char a : 2;//2代表2比特bt，一个字节8bt char b : 2; char c : 2; char d : 2;&#125;student; 结构体定义的原则，保证结构体字节对齐 12345678### pragma pack(2)//控制结构体按2字节对齐typedef struct STUDENT&#123; int a; char c; char res[3];//跨平台时由于编译器不同，需强制对齐&#125;student;#pragma pack() 结构体数组p-&gt;score &lt;===&gt; (*p).score12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct STUDENT&#123; int number; int score;&#125;student;int main()&#123; int array[10]; char buffer[10]; student s[10] = &#123;&#123;1,10&#125;,&#123;2,30&#125;&#125;; printf(&quot;%d&quot;,s[0].number); student* p = s; printf(&quot;%d &quot;,s[0].score); printf(&quot;%d &quot;,(*p).score); printf(&quot;%d&quot;,p-&gt;score); //p-&gt;score &lt;===&gt; (*p).score return 0;&#125; 输出结果 11 10 10 10 链表特点 空间不连续 不支持随机访问 插入删除的效率高 创建链表 head-&gt;next要初始化为空，因为链表以节点next域为空判断链表是否接受 head在栈区，malloc在堆区分配一片空间给head，head存放的是这片空间的地址 带头结点的头插法123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct NODE&#123; int num; struct NODE* next;//不能用Node，因为编译顺序Node在这句话之后&#125;Node;int main()&#123; Node *head = (Node *)malloc(sizeof(Node)); //head-&gt;next要初始化为空，因为链表以节点next域为空判断链表是否结束 head-&gt;next = NULL; //head在栈区，malloc在堆区分配一片空间给head， //head存放的是这片空间的地址 int number; while (1) &#123; scanf(&quot;%d&quot;,&amp;number); if (number &lt;= 0) &#123; break; &#125; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;num = number; p-&gt;next = head-&gt;next; head-&gt;next = p; &#125; return 0;&#125; 打印链表12345678void printLink(Node* p)&#123; while (p) // &lt;===&gt; p != NULL &#123; printf(&quot;%d &quot;,p-&gt;num); p = p-&gt;next; //不能用p++，因为链表空间不是连续的 &#125;&#125; 释放链表123456789void freeLink(Node* p)&#123; Node *q = NULL; while (p) &#123; q = p; p = p-&gt;next; free(q); &#125;&#125; 查找节点1234567891011Node* searchLink(Node* p, int num)&#123; while (p) &#123; if(p-&gt;num == num) &#123; return p; &#125; p = p-&gt;next; &#125; return NULL;&#125; 修改节点123456789101112Node* modifyLink(Node* p, int num)&#123; while (p) &#123; if(p-&gt;num == num) &#123; p-&gt;num = 20; return p; &#125; p = p-&gt;next; &#125; return NULL;&#125; 删除节点12345678910111213141516171819int modifyLink(Node* p, int num)&#123; if(p == NULL) return; //默认带头节点 Node *q = p; p = p-&gt;next; while (p) &#123; if(p-&gt;num == num) &#123; q-&gt;next = p-&gt;next; free(p); return 0; &#125; q = p; p = p-&gt;next; &#125; return 1;&#125; 插入节点在findnum前插入一个num = newnum的节点 123456789101112131415161718192021int modifyLink(Node* p, int findnum, int newnum)&#123; if(p == NULL) return; //默认带头节点 Node *q = p; p = p-&gt;next; while (p) &#123; if(p-&gt;num == num) &#123; Node *r = (Node *)malloc(sizeof(Node)); r-&gt;num = findnum; q-&gt;next = r; r-&gt;next = p; return 0; &#125; q = p; p = p-&gt;next; &#125; return 1;&#125; 联合 所有成员共享一块空间 sizeof计算成员中字节最大的空间大小 各成员内存重叠 在使用时和结构体语法相同 优势 省空间 1234567891011121314#include&lt;stdio.h&gt;union UN&#123; int a; int c;&#125;;int main()&#123; printf(&quot;%d\\n&quot;,sizeof(union UN)); union UN u; u.a = 10; printf(&quot;%d %d\\n&quot;,u.a,u.c); return 0;&#125; 输出结果 123410 10 1234567891011121314#include&lt;stdio.h&gt;union UN&#123; int a; char c;&#125;;int main()&#123; printf(&quot;%d\\n&quot;,sizeof(union UN)); union UN u; u.c = 10; printf(&quot;%d %d&quot;,u.a,u.c); //a没有被赋值 return 0;&#125; 输出结果 12410 10 大小端小端存储高地址（数大的）放高位（如例子中的万位），低地址放低位 十进制 二进制 100000 0000 0000 0000 0001 1000 0110 1010 0000 0x1234 0x1235 0x1236 0x1237 1010 0000 1000 0110 0000 0001 0000 0000 大端存储低地址（数小的）放高位（如例子中的个位），高地址放低位 十进制 二进制 100000 0000 0000 0000 0001 1000 0110 1010 0000 0x1234 0x1235 0x1236 0x1237 0000 0000 0000 0001 1000 0110 1010 0000 例题：判断电脑cpu是什么架构，是大端存储还是小端存储常见电脑都是小端存储 12345678910111213141516#include&lt;stdio.h&gt;int checkSystem()&#123; union UN &#123; int a; char c; &#125;u; u.a = 1; return u.c == 1;&#125;int main()&#123; printf(&quot;%d&quot;,checkSystem()); return 0;&#125; 若是大端存储 十进制 二进制 1 0000 0000 0000 0000 0000 0000 0000 0001 0x1234 0x1235 0x1236 0x1237 0000 0000 0000 0000 0000 0000 0000 0001 输出结果 10 若是小端存储 十进制 二进制 1 0000 0000 0000 0000 0000 0000 0000 0001 0x1234 0x1235 0x1236 0x1237 0000 0001 0000 0000 0000 0000 0000 0000 输出结果 11 枚举用来屏蔽魔鬼数字，用来表示某种含义 1234567891011121314151617181920#include&lt;stdio.h&gt;//默认从0开始enum ENUM &#123; SUN, MON = 10, TUE, WED, THU, FRI, SAT&#125;;int main()&#123; int a = TUE; printf(&quot;%d &quot;,SUN); printf(&quot;%d&quot;,a); return 0;&#125; 输出结果 10 11 宏定义用来屏蔽魔鬼数字 1234567891011121314151617#include&lt;stdio.h&gt;#define NUM 10int main()&#123; int arry[NUM]; for (int i = 0; i &lt; NUM; i++) &#123; arry[i] = 10; &#125; for (int i = 0; i &lt; NUM; i++) &#123; printf(&quot;%d &quot;,arry[i]); &#125; return 0;&#125; 输出结果 110 10 10 10 10 10 10 10 10 10 宏定义只是单纯的字符串替换 12345678#include&lt;stdio.h&gt;#define NUM 5+2int main()&#123; printf(&quot;%d&quot;,NUM * 2); return 0;&#125; 输出结果 19 宏函数12345678#include&lt;stdio.h&gt;#define MAX(a,b) if (a &gt; b) &#123;printf(&quot;%d&quot;,a);&#125;else&#123;printf(&quot;%d&quot;,b);&#125;int main()&#123; MAX(20,30) //这句加不加;都不行。 return 0;&#125; 输出结果 130 宏只能在一行，如果换行要在最后加\\ 1234567891011121314#include&lt;stdio.h&gt;#define MAX(a,b)\\if (a &gt; b) &#123;\\ printf(&quot;%d&quot;,a);\\ &#125;\\else&#123;\\ printf(&quot;%d&quot;,b);\\ &#125;int main()&#123; MAX(20,30) return 0;&#125; 多文件编程 联合，枚举，宏定义，函数的声明放在.h文件中 .c文件要使用需要#include&quot;filename.h&quot; 注意 不能循环包含头文件 开头要加#pragma once,防止重复包含头文件或加 1234#ifndef __INC_FILENAME_#define __INC_FILENAME_//代码#endif eg 1234567891011121314151617#ifndef __INC_222_#define __INC_222_typedef struct NODE&#123; int num; struct NODE* next;&#125;;#endif#ifndef __INC_222_#define __INC_222_typedef struct NODE&#123; int num; struct NODE* next;&#125;;#endif 文件读写 12345678910111213141516171819202122#include&lt;stdio.h&gt;int main()&#123; //1.打开文件 FILE* fr = fopen(&quot;E:\\\\文档\\\\新建文本文档.c&quot;,&quot;r&quot;); FILE* fw = fopen(&quot;E:\\\\文档\\\\新建文本文档.c&quot;,&quot;w&quot;); if(fr == NULL || fw == NULL) &#123; printf(&quot;文件打开失败&quot;); return 0; &#125; //2.读写文件 char buffer[128]; fgets(buffer,128,fr); printf(&quot;%s&quot;,buffer); fputs(buffer,fw); //3.关闭文件 fclose(fr); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"笔记","slug":"C-C/笔记","permalink":"http://example.com/categories/C-C/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"测试1错题","slug":"测试1错题","date":"2021-01-03T22:50:02.000Z","updated":"2021-01-11T10:28:14.663Z","comments":true,"path":"2021/01/04/测试1错题/","link":"","permalink":"http://example.com/2021/01/04/%E6%B5%8B%E8%AF%951%E9%94%99%E9%A2%98/","excerpt":"1.计算2^0 + 2^1 + 2^2 + 2^3 + 2^4 + … + 2^n的结果","text":"1.计算2^0 + 2^1 + 2^2 + 2^3 + 2^4 + … + 2^n的结果 1234567int main()&#123; int n = 0; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%d&quot;,1 &lt;&lt; (n + 1) - 1); return 0;&#125; 2.任意一个大于2的偶数n都可以由两个素数的和组成，但是组成偶数的素数有很多种情况，输出所有情况。123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int n = 0; scanf(&quot;%d&quot;,&amp;n); int *nums = (int *)malloc(n*sizeof(int)); if (nums == NULL) &#123; return -1; //申请空间失败，返回异常状态 &#125; //初始化动态数组 for (int i = 0; i &lt; n; i++) &#123; nums[i] = 0; &#125; //厄拉多塞筛选法 for (int i = 2; i &lt; n; i++) &#123; if (nums[i] == 0) &#123; for (int j = i + i; j &lt; n; j += i) &#123; nums[j] = 1; &#125; &#125; &#125; for(int i = 2; i &lt; n / 2; i++) &#123; if (nums[i] == 0 &amp;&amp; nums[n - i] == 0) &#123; printf(&quot;%d %d\\n&quot;,i,n - i); &#125; &#125; free(nums); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"习题","slug":"C-C/习题","permalink":"http://example.com/categories/C-C/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"C/C++习题","slug":"C-C-习题","permalink":"http://example.com/tags/C-C-%E4%B9%A0%E9%A2%98/"}]},{"title":"not done","slug":"not done","date":"2020-05-30T02:10:04.000Z","updated":"2021-01-16T12:23:33.157Z","comments":true,"path":"2020/05/30/not done/","link":"","permalink":"http://example.com/2020/05/30/not%20done/","excerpt":"","text":"1. C++链表12345struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;; main函数中如何创建链表 2. string123string s = &quot;saldkj12093&quot;;for (char c : s) &#123;&#125; for循环条件什么意思 3. 友元函数私有4. B b();相当于函数声明，即返回值为B的名叫b的函数 26期 linux基础小野老师 晚上 21-25 系统编程 小白老师晚上 类名(); //无名创造 strcat必须找到’\\0’","categories":[],"tags":[]},{"title":"shell学习笔记01：两个简单的shell脚本","slug":"shell学习笔记01：两个简单的shell脚本","date":"2020-05-30T02:10:04.000Z","updated":"2021-01-08T10:06:06.093Z","comments":true,"path":"2020/05/30/shell学习笔记01：两个简单的shell脚本/","link":"","permalink":"http://example.com/2020/05/30/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%EF%BC%9A%E4%B8%A4%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84shell%E8%84%9A%E6%9C%AC/","excerpt":"","text":"1.添加用户user1-10，但要求只有用户不存在的情况下才能添加。 2.切换工作目录至/var；统计/var目录下共有多个文件，并显示出来。 注意运行shell时如果提示权限不够时需先运行chmod 764 test.sh。 1.添加用户user1-10123456789101112131415161718192021222324#!/bin/sh#添加用户user1-10,只有用户不存在时才添加。psw=&quot;1&quot;for i in `seq 1 10` do name=&quot;user&quot;$i&quot;&quot;; sudo useradd $name; #判断该用户是否存在。 if [ $? -eq 0 ];then echo &quot;user $&#123;name&#125; is created successfully!&quot; else echo &quot;user $&#123;name&#125; is existed!&quot; continue fi #判断密码设置是否成功。 echo $password | sudo password --stdin $name; if [$? -eq 0 ];then echo &quot;$&#123;name&#125;&#x27;s password is set successfully&quot; else echo &quot;$&#123;name&#125;&#x27;s password is set failly!&quot; fidone 定义变量时等号不能加空格。 #!是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。 拼接字符串，可以使用单引号或双引号拼接。 12name=&quot;user&quot;user_name=&quot;&quot;$name&quot;1&quot; #user_name=&quot;$&#123;name&#125;1&quot; 2.统计/var目录下共有多个文件1234567891011#!/bin/sh#切换工作目录至/ver;#依次向/var目录下的每个文件或子目录问好;#统计/var目录下共有多少个文件，并显示出来。i=0cd /varfor FILE in /var/*do i=`expr $i + 1`;doneecho $i “`”的作用是将”``”中间的语句当成命令执行","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"shell","slug":"Linux/shell","permalink":"http://example.com/categories/Linux/shell/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"http://example.com/tags/shell/"}]},{"title":"解决microsoft应用商店开启代理后无法连接问题","slug":"解决microsoft应用商店开启代理后无法连接问题","date":"2020-05-16T11:28:27.000Z","updated":"2021-01-08T10:09:38.303Z","comments":true,"path":"2020/05/16/解决microsoft应用商店开启代理后无法连接问题/","link":"","permalink":"http://example.com/2020/05/16/%E8%A7%A3%E5%86%B3microsoft%E5%BA%94%E7%94%A8%E5%95%86%E5%BA%97%E5%BC%80%E5%90%AF%E4%BB%A3%E7%90%86%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/","excerpt":"问题Microsoft的全部应用在中国区的设置默认都是直连，所以当打开网络代理之后就无法使用应用商店。","text":"问题Microsoft的全部应用在中国区的设置默认都是直连，所以当打开网络代理之后就无法使用应用商店。 解决办法使用Fiddler，点击左上角winconfig，将需要更改的Microso应用打勾✔。","categories":[{"name":"日常问题","slug":"日常问题","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"},{"name":"Microsoft","slug":"日常问题/Microsoft","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Microsoft/"}],"tags":[{"name":"日常问题","slug":"日常问题","permalink":"http://example.com/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"title":"Linux基本操作","slug":"Linux基本操作","date":"2020-04-25T04:30:42.000Z","updated":"2021-01-08T10:07:00.825Z","comments":true,"path":"2020/04/25/Linux基本操作/","link":"","permalink":"http://example.com/2020/04/25/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"Linux的目录 /root：根目录/bin：包含供每个人使用的可执行程序/sbin：包含仅供管理员使用的可执行程序/lib：包含库文件/boot：包括了内核镜像和其它相关内容/dev：包含着代表硬件设备的设备文件/etc：包含着整个系统的各种配置文件/home：包含各用户的主目录/root：是root的主目录/mnt：包含装载其它非标准文件系统的装载点/proc:是个虚拟目录，里面保存内核和进程的信息/tmp：是为程序和用户提供放置临时空间的目录/usr：包含UNIX系统的众多资源，较占空间/var：目录包含了一些文件大小比较特殊的文件，如日志文件，锁文件等，还包括各种用途的文件，如：邮件、计划、打印文件等/lost+found：存在于所有的文件系统中，保存文件碎片/opt：是由一些外部应用程序使用的目录 其它一些用户自己建的目录 工作目录：用户在登录到Linux系统中之后，每时每刻都”处在”某个目录之中，此目录被称作工作目录或当前目录（Working Directory）。工作目录是可以随时改变的。工作目录用.表示，其父目录用..表示。 主目录：是系统管理员增加用户时建立起来的（以后也可以改变），每个用户都有自己的主目录用于保存信息，不同用户的主目录一般互不相同。 用户初始登录到系统中时，其主目录（Home Directory）就成为其工作目录，通常与用户的登录名相同。 用户可以通过一个~字符来引用自己的主目录。例如命令：$ cat ~/file1 Linux常用命令最常用的几个命令可用pwd命令查看用户的当前目录可用cd命令来切换目录.表示当前目录..表示当前目录的上一级目录（父目录）-表示用cd命令切换目录前所在的目录~表示用户主目录的绝对路径名--help查看该操作的帮助信息--version显示版本信息并退出clear清除屏幕 修改口令passwd对用户口令进行操作 who命令who显示当前已登录的用户信息who am i：等价于who -mwhoami：显示当前“操作用户”的用户名 echo命令显示输出字符串 用法：/bin/echo [短选项]... [字符串]... 或：`/bin/echo 长选项`` ​ echo将 STRING 回显到标准输出。 ​ -n不尾随换行符 ​ -e启用解释反斜杠的转义功能 ​ -E禁用解释反斜杠的转义功能(默认) 注意：echo的帮助信息需要输入/bin/echo --help date命令显示或设置系统的日期和时间 用法：date [选项]... [+格式] 或：date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]] cal命令cal显示日历 文件和目录操作相关命令cat命令连接文件并打印到标准输出设备上 用法：cat [选项]... [文件]... more命令用于显示内容超过一屏的文件 用法：more [选项] &lt;文件&gt;...more 内部命令键:Space、Enter、/、h、 b、q。 less的作用与more十分相似，都可以用来浏览文字档案的内容，不同的是less允许使用者往回卷动。 Head/Tail命令用来显示开头或结尾某个数量的文字区块 用法：head [选项]... [文件]... 用法：tail [选项]... [文件]... od命令以指定格式显示文件，默认为八进制 用法：od [选项]... [文件]... 或：od [-abcdfilosx]... [文件] [[+]偏移量[.][b]] 或：od --traditional [选项]... [文件] [[+]偏移量[.][b] [+][标签][.][b]] file命令辨识文件类型 用法：file[选项]... [文件]... touch命令改变档案的时间记录 用法：touch[选项]... [文件]... grep命令查找文件里符合条件的字符串 用法：grep[选项]... [查找模式]... [文件]... 其中-n选项可输出匹配行的行号，-r选项表示在目录中递归查找符合的文件名。 find命令文件查找命令 用法：find[路径]... [选项]... 其中-name选项用于通过文件名查找，-size选项用于通过文件大小查找等。 locate命令快速文件查找命令，该命令在运行时需要后台索引的数据库支撑，可以执行sudo updatedb来手动更新。 用法：Locate[选项]... [文件]... sort命令对文件中的各行进行排序。默认以升序词典顺序排序文件的内容。每一列的字符，包括空格、数字和特殊字符都经一一比较。 用法：sort[选项]... [文件列表]... -d选项：只比较字母、数字和空格，其他忽略。 uniq命令将相邻的重复行从输出文件中删除，只留下每条记录的唯一样本。可结合sort命令使用。 用法：uniq[选项]... [文件]... wc命令统计指定文件中的行数、字数、字节数， 并将统计结果显示输出。 用法：wc[选项]... [文件]... comm命令该命令是对两个已经排好序的文件进行比较。其中file1和file2是已排序的文件。comm读取这两个文件，然后生成三列输出。仅在 file1中出现的行；仅在file2中出现的行；在两个文件中都存在的行。其中- 123选项为选择哪列显示。 用法：comm [- 123 ] file1 file2 diff命令该命令的功能为逐行比较两个文本文件，列出其不同之处。 用法：diff[选项]... [文件1]... [文件名2]... cp命令文件复制 用法：cp[选项]... [源文件名或目录]... [目标文件名或目录]... -r若给出的源文件是一目录文件，此时cp将递归复制该目录下所有的子目录和文件。此时目标文件必须为一个目录名。 -a该选项通常在拷贝目录时使用。它保留链接、文件属性，并递归地拷贝目录。 -f删除已经存在的目标文件而不提示。 rm命令删除文件命令 用法：rm[选项]... [文件列表]... -f忽略不存在的文件，从不给出提示。 -r指示rm将参数中列出的全部目录和子目录均递归地删除。 -i进行交互式删除。 mv命令移动文件命令 用法：mv[选项]... [源文件/目录名]... [目标文件/目录名]... -f覆盖前不询问 -i覆盖前询问 -n不覆盖已存在文件 ln命令文件链接命令，包括硬链接和软链接两种。其中硬链接使得链接数加1，不能链接目录，不能跨文件系统。 用法：ln[选项]... [源文件]... [目标文件]... mkdir/rmdir命令创建目录、删除空目录。 用法：mkdir/rmdir[选项]... [目录名]... rmdir的-p选项，表示当删除目录的父目录为空时，父目录也一并删除。 ls 命令列出目录内容 用法：ls[选项]... [文件或目录]... -a显示所有文件，包括隐藏文件 -R显示所有文件，包括子目录下的文件 -l显示文件的详细信息 -d显示目录的信息而不是目录所含的内容 -i显示文件的inode数 命令的输入和输出 标准I/O文件 标准输入(stdin) 0 标准输出(stdout) 1 标准错误输出(stderr) 2 输出重定向：&gt; 1&gt; 2&gt; &amp;&gt; （含1和2） 附加重定向：&gt;&gt; 输入重定向：&lt;，0&lt; 管道：上一个命令的stdout接到下一个命令的stdin;管道符号| 过滤器：用来接收标准输入，经过一定的转化，再写到标准输出。所以，过滤器一般放在管道符中间。如：ls | sort | more 联机帮助命令help：显示bash shell内置命令的简单信息。使用help命令不带任何参数将显示bash shell所有内置的命令。 用法：help[命令]...man：显示对应命令系统的帮助手册。 用法：man[选项]... [章节数字]... [命令]...whatis:描述一个命令执行什么功能。等同于使用man -f命令 用法：whatis [命令]...whereis：从环境变量的路径中查找符合条件的文件。 用法：whereis[选项]... [文件]... 网络管理命令ifconfig程序设置，检查以及监控网络接口的配置值。 用法：ifconfig [interface_name] [ip_address] [up|down] route路由显示及配置网络路由 netstat 程序显示网络连接、路由表和网络接口信息，可以让用户得知目前都有哪些网络连接正在运作。 用法：netstat［选项］... -a所有连接 -r路由表 -tTCP协议（-u） ping程序用于查看网络上的主机是否在工作，它向该主机发送ICMP ECHO_REQUEST包。当想从网络上的某台主机上下载文件，可是又不知道那台主机是否开着，就需要使用ping命令查看。 用法：ping［选项］ [主机名/IP地址] -c数目 在发送指定数目的包后停止。 -d设定SO_DEBUG的选项。 -f大量且快速地送网络封包给一台机器，看它的回应。 -I秒数 设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"使用Github PicGo搭建图床","slug":"使用Github-PicGo搭建图床","date":"2020-03-22T05:50:16.000Z","updated":"2021-01-08T10:08:43.371Z","comments":true,"path":"2020/03/22/使用Github-PicGo搭建图床/","link":"","permalink":"http://example.com/2020/03/22/%E4%BD%BF%E7%94%A8Github-PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"在github中搭建图床1.创建Repository一定要选择public,private的仓库，图片链接会带token，这个token又存在过期的问题。 这里因为我已经有一个叫Figurebed的仓库所以”Repository name”不可用. README.md可选可不选。 2.创建一个token 选择最下方Developer setting 选择左下方Personal access tokens 右上角generate generate token 新生成的token一定要先复制到其他地方留作备用 配置PicGo1.下载PicGohttps://github.com/Molunerfinn/PicGo 2.配置PicGo 设定仓库名，按照“用户名/仓库名”的格式 分支名填写“master” 将之前留作备用的token粘贴在这里 img/存储路径，会在repository中创建一个img文件夹 设定自定义域名后，上传图片成功后，PicGo会自动生成该图片的访问链接 https://raw.githubusercontent.com/用户名/RepositoryName/分支名 3.相关设置我习惯关闭自动更新，开启开机自启 快捷键可自己设置，我是参考别人用的ctrl+shift+c","categories":[{"name":"Github","slug":"Github","permalink":"http://example.com/categories/Github/"}],"tags":[{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"},{"name":"图床","slug":"图床","permalink":"http://example.com/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"hexo常用指令","slug":"hexo常用指令","date":"2020-03-21T08:50:02.000Z","updated":"2021-01-08T09:03:17.774Z","comments":true,"path":"2020/03/21/hexo常用指令/","link":"","permalink":"http://example.com/2020/03/21/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","excerpt":"","text":"hexo常用指令12345678910hexo new &quot;postName&quot; &#x2F;&#x2F;新建文章hexo new page &quot;pageName&quot; &#x2F;&#x2F;新建页面hexo g &#x2F;&#x2F;生成静态页面至public目录hexo server &#x2F;&#x2F;开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）hexo deploy &#x2F;&#x2F;将.deploy目录部署到GitHubhexo cleanhexo ghexo dhexo d -g #生成部署hexo s -g #生成预览 文件信息123456---title: xxx &#x2F;&#x2F;在此处添加你的标题。date: 2016-10-07 13:38:49 &#x2F;&#x2F;在此处输入编辑这篇文章的时间。tags: xxx &#x2F;&#x2F;在此处输入这篇文章的标签。categories: xxx &#x2F;&#x2F;在此处输入这篇文章的分类。--- 文件编辑完成后发布12hexo ghexo d","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"设置hexo首页只显示博文摘要","slug":"设置hexo首页只显示博文摘要","date":"2020-03-21T01:36:03.000Z","updated":"2021-01-08T08:55:39.110Z","comments":true,"path":"2020/03/21/设置hexo首页只显示博文摘要/","link":"","permalink":"http://example.com/2020/03/21/%E8%AE%BE%E7%BD%AEhexo%E9%A6%96%E9%A1%B5%E5%8F%AA%E6%98%BE%E7%A4%BA%E5%8D%9A%E6%96%87%E6%91%98%E8%A6%81/","excerpt":"","text":"修改配置我使用的Volantis主题默认是开启只显示文章摘要的。该选项可以在blog\\themes\\主题名\\_config.yml文件中找到。 # When there is no description in the article’s front-matter, use excerpt as the description. use_excerpt_as_description: true 在其他主题中变量名可能会变，但一般都会有excerpt和description这两个单词。 对文章的处理方法一：Description在文章的front-matter中添加description，首页会只显示description的内容。下面是本文front-matter title: 设置hexo首页只显示博文摘要date: 2020-03-24 12:10:54 tags: hexodescription: 针对Volantis主题，主题默认显示摘要是开启的，但需要在博文中加一些内容，使其只显示前面一部分。 方法二：文章截断在需要截断的地方加入下列语句。 &lt;!--more--&gt; 首页就会只显示这条以上的所有内容。 法二比法一方便一些，如果感觉文章开头写的不错就直接用法二更方便一点。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"双指针","slug":"LeetCode/双指针","permalink":"http://example.com/categories/LeetCode/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"},{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"笔记","slug":"C-C/笔记","permalink":"http://example.com/categories/C-C/%E7%AC%94%E8%AE%B0/"},{"name":"字符串","slug":"LeetCode/字符串","permalink":"http://example.com/categories/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"习题","slug":"C-C/习题","permalink":"http://example.com/categories/C-C/%E4%B9%A0%E9%A2%98/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"学习路线","slug":"学习路线","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"name":"shell","slug":"Linux/shell","permalink":"http://example.com/categories/Linux/shell/"},{"name":"日常问题","slug":"日常问题","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"},{"name":"Microsoft","slug":"日常问题/Microsoft","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Microsoft/"},{"name":"Github","slug":"Github","permalink":"http://example.com/categories/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"C/C++习题","slug":"C-C-习题","permalink":"http://example.com/tags/C-C-%E4%B9%A0%E9%A2%98/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"学习路线","slug":"学习路线","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"shell","slug":"shell","permalink":"http://example.com/tags/shell/"},{"name":"日常问题","slug":"日常问题","permalink":"http://example.com/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"},{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"},{"name":"图床","slug":"图床","permalink":"http://example.com/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}