{"meta":{"title":"Wwwhw's BLOG","subtitle":"","description":"","author":"Wang Haowen","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"数据结构&算法笔记","slug":"数据结构-算法笔记","date":"2021-01-07T12:55:20.000Z","updated":"2021-01-07T14:16:05.458Z","comments":true,"path":"2021/01/07/数据结构-算法笔记/","link":"","permalink":"http://example.com/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","excerpt":"","text":"数据结构的定义 数据结构是相互之间存在一种或多种特定关系的数据元素的集合 数据 算法五个基本特性 输入 输出 有穷性 确定性 可行性 算法的要求 正确性 可读性 健壮性 时间复杂度和空间复杂度低 事前分析估算方法 在计算机程序编制前，依据统计方法对算法进行估算 一个程序的运行时间，依赖于算法的好坏和问题的输入规模，所谓问题输入规模是指输入量的多少 在分析程序的运行时间时，最重要的是把程序看成独立于程序设计语言的算法或一系列步骤 常见的时间复杂度O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n) 线性表线性表顺序存储线性表顺序存储结构体的定义1234567#define MAXSIZE 20 /*存储空间初始分配量*/typedef int ElemType; /*ElemType类型根据实际情况而定，这里假设为int*/typedef struct &#123; ElemType data[MAXSIZE]; /*数组存储数据元素，最大值为MAXSIZE*/ int length; /*线性表当前长度*/&#125;; 栈","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"C语言例题7：输出和为s的数组元素","slug":"C语言例题7：输出和为s的数组元素","date":"2021-01-06T12:59:39.000Z","updated":"2021-01-06T13:25:15.496Z","comments":true,"path":"2021/01/06/C语言例题7：输出和为s的数组元素/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%987%EF%BC%9A%E8%BE%93%E5%87%BA%E5%92%8C%E4%B8%BAs%E7%9A%84%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0/","excerpt":"","text":"输出和为s的数组元素Description输入一个递增排序的数组和数字s.在数组中查找两个数，使得他们的和恰好为s。如果有多对数字的和等于s，输出两个数的乘积最小的 Input输入第一个数 n 表示数组长度输入第二个数 s 表示两个数之和其余数组中的数按空格分开输入 Output输出满足条件的两个元素 解法思想 先从后向前找最后一个小于s的数记为j（可以减少主循环次数），从第一个元素开始到j依次两两相加，查找符合条件（和为s且乘积最小）的两个数 矩形面积，周长相等时，正方向面积大于长方形面积。故和相等时，差值越大乘积越小 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int n = 0; int target = 0; scanf(&quot;%d %d&quot;,&amp;n,&amp;target); int *nums = (int *)malloc(n*sizeof(int)); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;,&amp;nums[i]); &#125; int i = 0; int j = n - 1; while (i &lt; j) &#123; if (nums[i] + nums[j] &gt; target) &#123; j--; &#125; if (nums[i] + nums[j] &lt; target) &#123; i++; &#125; else if (nums[i] + nums[j] == target) &#123; printf(&quot;%d %d&quot;,nums[i],nums[j]); return 0; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C语言例题6：查看亮灯情况","slug":"C语言例题6：查看亮灯情况","date":"2021-01-06T12:44:14.000Z","updated":"2021-01-06T13:26:46.779Z","comments":true,"path":"2021/01/06/C语言例题6：查看亮灯情况/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%986%EF%BC%9A%E6%9F%A5%E7%9C%8B%E4%BA%AE%E7%81%AF%E6%83%85%E5%86%B5/","excerpt":"","text":"查看亮灯情况Descriopion一条长廊里依次装有n(1 ≤ n ≤ 65535)盏电灯，从头到尾编号1、2、3、…n-1、n。 每盏电灯由一个拉线开关控制。开始，电灯全部关着。 有n个学生从长廊穿过。第一个学生把号码凡是1的倍数的电灯的开关拉一下； 接着第二个学生把号码凡是2的倍数的电灯的开关拉一下； 接着第三个学生把号码凡是3的倍数的电灯的开关拉一下； 如此继续下去，最后第n个学生把号码凡是n的倍数的电灯的开关拉一下。 n个学生按此规定走完后，长廊里电灯有几盏亮着。 注：电灯数和学生数一致。Input 1输入n个学生 Output 1输出当有n个学生的时候还有几盏灯亮着 解法碰过i号灯的人都是i的因子，当因子个数为奇数时灯亮。（完全平方数因子有重复，如：9 = 3 * 3） 12345678910111213#include&lt;stdio.h&gt;int main()&#123; int n &#x3D; 0; scanf(&quot;%d&quot;,&amp;n); int i &#x3D; 1; while(i * i &lt;&#x3D; n) &#123; i++; &#125; printf(&quot;%d&quot;,i-1); return 0;&#125;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C语言例题5：厄拉多塞筛选法","slug":"C语言例题5：厄拉多塞筛选法","date":"2021-01-06T12:40:00.000Z","updated":"2021-01-06T13:24:23.629Z","comments":true,"path":"2021/01/06/C语言例题5：厄拉多塞筛选法/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%985%EF%BC%9A%E5%8E%84%E6%8B%89%E5%A4%9A%E5%A1%9E%E7%AD%9B%E9%80%89%E6%B3%95/","excerpt":"","text":"厄拉多塞筛选法乘法运算的速度没有加法快西元前250年，希腊数学家厄拉多塞(Eeatosthese)想到了一个非常美妙的质数筛法，减少了逐一检查每个数的的步骤，可以比较简单的从一大堆数字之中，筛选出质数（素数）来，这方法被称作厄拉多塞筛法(Sieve of Eeatosthese)。 具体操作：先将 2~n 的各个数放入表中，然后在2的上面画一个圆圈，然后划去2的其他倍数；第一个既未画圈又没有被划去的数是3，将它画圈，再划去3的其他倍数；现在既未画圈又没有被划去的第一个数 是5，将它画圈，并划去5的其他倍数……依次类推，一直到所有小于或等于 n 的各数都画了圈或划去为止。这时，表中画了圈的以及未划去的那些数正好就是小于 n 的素数。 其实，当你要画圈的素数的平方大于 n 时，那么后面没有划去的数都是素数，就不用继续判了。如下图： Description输出1到1000以内所有素数 123456789101112131415161718#include &lt;stdio.h&gt;int main ()&#123; int nums[1001] &#x3D; &#123;0&#125; ; for (int i &#x3D; 2 ; i &lt;&#x3D; 1000 ; i++) &#123; if (nums[i] &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;证明是素数 printf( &quot;%d\\n&quot;, i); for (int j &#x3D; i + i; j&lt;&#x3D; 1000; j +&#x3D; i) &#123;&#x2F;&#x2F;把i的倍数都刷掉 nums[j]&#x3D; 1 ; &#125; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C语言例题4：股神","slug":"C语言例题4：股神","date":"2021-01-06T12:15:46.000Z","updated":"2021-01-06T12:40:05.269Z","comments":true,"path":"2021/01/06/C语言例题4：股神/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%984%EF%BC%9A%E8%82%A1%E7%A5%9E/","excerpt":"","text":"股神Description假设买入1元股票，股票的变化规律是第一天不变（0），第二天涨1元（1），第三天跌1元（-1），第四天涨1元（1），第五天涨1元（1），第六天跌1元（-1），第七天涨1元（1），第八天涨1元（1），第九天涨1元（1），第十天跌1元（-1）…求N天后的股票剩余价格 法一12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; int n &#x3D; 0; int i &#x3D; 1; int j &#x3D; 2; int count &#x3D; 0; scanf(&quot;%d&quot;,&amp;n); while ( i + j &lt;&#x3D; n) &#123; i &#x3D; i + j; j &#x3D; j + 1; count++; &#125; printf(&quot;%d&quot;, n - 2 * count); return 0; &#125; 法二1234567891011121314151617181920#include&lt;stdio.h&gt;int main()&#123; int n &#x3D; 0; scanf(&quot;%d&quot;,&amp;n); int count &#x3D; 0; &#x2F;&#x2F;-1的总天数 int i &#x3D; 1; &#x2F;&#x2F;第i天为-1 int sum &#x3D; 0; for (; i &lt;&#x3D; n; i++) &#123; i &#x3D; 2*i + 1; count++; &#125; sum &#x3D; n - 2 * count;&#x2F; printf(&quot;%d&quot;,sum); return 0;&#125;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C语言例题3：求s=1+(1+2)+...+(1+2+3+...+n)","slug":"C语言例题3：求s-1-1-2-1-2-3-n","date":"2021-01-06T12:10:32.000Z","updated":"2021-01-06T12:15:58.092Z","comments":true,"path":"2021/01/06/C语言例题3：求s-1-1-2-1-2-3-n/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%983%EF%BC%9A%E6%B1%82s-1-1-2-1-2-3-n/","excerpt":"","text":"求s=1+(1+2)+(1+2+3)+…+(1+2+3+…+n)的值Description编写一个程序，求s=1+(1+2)+(1+2+3)+…+(1+2+3+…+n)的值 123456789101112131415#include&lt;stdio.h&gt;int main()&#123; int a = 0; scanf(&quot;%d&quot;,&amp;a); int sum = 0; int j = 0; for (int i = 1; i &lt;= a; i++) &#123; j += i; sum = sum + j; &#125; printf(&quot;%d&quot;,sum); return 0;&#125;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C语言例题2：输出一个数的二进制有多少个1","slug":"C语言例题2：输出一个数的二进制有多少个1","date":"2021-01-06T12:03:22.000Z","updated":"2021-01-06T12:08:39.135Z","comments":true,"path":"2021/01/06/C语言例题2：输出一个数的二进制有多少个1/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%982%EF%BC%9A%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA1/","excerpt":"","text":"输出一个数的二进制有多少个1法一：依次消去二进制中的1，并计数 1234567891011121314int main()&#123; int a = 0; int count = 0; scanf(&quot;&amp;d&quot;,&amp;a); while(a != 0) &#123; a = a &amp; (a - 1);//去掉二进制中倒数第一个1 count++; &#125; printf(&quot;%d&quot;,count); return 0;&#125; 法二：int整型变量有32位二进制代码，对每一位按位于1 12345678910111213int main()&#123; int a = 0; int count = 0; scanf(&quot;&amp;d&quot;,&amp;a); for( int i = 0; i &lt; 32; i++) &#123; if( 1 &lt;&lt; i &amp; a) count++; &#125; printf(&quot;%d&quot;,count); return 0;&#125;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C语言例题1：数值比较","slug":"C语言例题1：数值比较","date":"2021-01-06T11:55:18.000Z","updated":"2021-01-06T12:10:34.618Z","comments":true,"path":"2021/01/06/C语言例题1：数值比较/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%981%EF%BC%9A%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83/","excerpt":"","text":"数值比较Description输入两个整数，输出较大的值，要求不允许使用if，&lt;，&gt;，?运算符 思想 123456789#include&lt;stdio.h&gt;int main()&#123; int a = 0; int b = 0; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); int f = (a - b) &gt;&gt; 31 &amp; 1; printf(&quot;%d&quot;,a - (a - b) * f); return 0;&#125;","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"设计模式笔记","slug":"设计模式笔记","date":"2021-01-06T09:17:36.000Z","updated":"2021-01-06T14:03:35.233Z","comments":true,"path":"2021/01/06/设计模式笔记/","link":"","permalink":"http://example.com/2021/01/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/","excerpt":"","text":"设计模式单例工厂简单工厂模式面向对象——活字印刷拿活字印刷举例子 可维护——可以改字 可复用——字并非只用一次，可在后来的印刷中使用 可拓展——可以加字 灵活性好——可随意排版 面向对象的好处通过封装、继承、多态把程序的耦合度降低，用设计模式使得程序更加灵活，容易修改，易于复用 封装使耦合度下降 紧耦合和松耦合代理策略模式模版方法","categories":[],"tags":[]},{"title":"编程基础","slug":"编程基础","date":"2021-01-06T09:09:47.000Z","updated":"2021-01-06T09:22:32.812Z","comments":true,"path":"2021/01/06/编程基础/","link":"","permalink":"http://example.com/2021/01/06/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/","excerpt":"","text":"学习编程的基础四大件数据结构和算法学完之后要刷leetcode（剑指offer） 计算机网络tcp/ip协议栈（tcp/ip详解） 操作系统进程和线程并发和锁内存分布调度等等 （深入理解操作系统） 设计模式单例工厂代理策略模式模版方法（大话设计模式） 实践Linux操作系统掌握《linux就该这么学》 shell编程脚本 编译/调试工具GUN官方GCC和GDB文档《debugging with gdb 》中文版《跟我一起写makefile》陈皓 Linux平台上 gccmakefile《跟我一起写makefile》 要会写 gdb调试工具 Linux系统编程《unix环境高级编程》《linux高性能服务器编程》《posix多线程程序设计》 多线程编程网络编程（unix环境高级编程）（Linux高性能服务器编程）（posix多线程程序设计）","categories":[],"tags":[]},{"title":"C++学习笔记","slug":"C-学习笔记","date":"2021-01-06T01:45:56.000Z","updated":"2021-01-07T12:48:25.354Z","comments":true,"path":"2021/01/06/C-学习笔记/","link":"","permalink":"http://example.com/2021/01/06/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"C++学习笔记头文件处理格式化输入和输出的iostream库 ​ cin标准输入 ​ cout标准输出 ​ cerr标准错误 ​ clog产生程序执行的一般信息 12345678910#include&lt;iostream&gt; //input output streamusing namespace std;int main()&#123; int a = 100; int b = 100; cout &lt;&lt; a &lt;&lt; &#x27; &#x27; &lt;&lt; b &lt;&lt; &quot;hello&quot;; //泛型 return 0;&#125; cout是一个对象&lt;&lt;是cout的成员函数 1234567891011#include&lt;iostream&gt; //input output streamusing namespace std;int main()&#123; int n = 0; int v2 = 0; cin &gt;&gt; n &gt;&gt; v2; cout &lt;&lt; n &lt;&lt; &quot; and &quot; &lt;&lt; v2 &lt;&lt; endl; return 0;&#125; 输出结果 123132 456132 and 456 endl是一个特殊值，称为操纵符，将它写入输出流时，具有输出换行的效果，并刷新与设备相关联的缓冲区。通过刷新缓冲区，用户可立即看到写入到流中的输出。 经常在调试过程中插入输出语句，这些语句都应该刷新输出流。忘记刷新输出流可能会造成输出停留在缓冲区中，如果程序崩溃，将会导致程序错误推断崩溃位置 。 命名空间1using namespace std; 优势使用命名空间程序员可以避免与库中定义的名字相同而引起无意冲突。因为标准库定义的名字是定义在命名空间中， 所以我们可以按自己的意图使用相同的名字 。有重名情况需要在重名的东西前加要使用的命名空间名字:: 1234567891011121314151617181920212223242526#include&lt;iostream&gt; //input output streamusing namespace std;namespace my1&#123; int a = 100; void print() &#123; printf(&quot;%d&quot;,a); &#125;&#125;namespace my2&#123; int a = 100; void print() &#123; printf(&quot;%d&quot;,a); &#125;&#125;using namespace my1;int main()&#123; print(); return 0;&#125; 123456789101112131415161718192021222324252627#include&lt;iostream&gt; //input output streamusing namespace std;namespace my1&#123; int a = 100; void print() &#123; printf(&quot;%d&quot;,a); &#125;&#125;namespace my2&#123; int a = 200; void print() &#123; printf(&quot;%d&quot;,a); &#125;&#125;using namespace my1;using namespace my2;int main()&#123; my1::print(); return 0;&#125; 1234567891011121314151617181920#include&lt;iostream&gt; //input output streamusing namespace std;namespace my1&#123; int a = 100; void print() &#123; printf(&quot;%d&quot;,a); &#125;&#125;void print()&#123; printf(&quot;%d&quot;,200);&#125;using namespace my1;int main()&#123; ::print(); //单写::就是使用全局空间 return 0;&#125; 新增变量类型bool只占一个字节 可以等于True或False 本质上时对char的封装 1bool b = false; 引用类型特点※ 引用被创建的同时必须被初始化。（指针则可以在任何时候被初始化）。 不能有NULL引用，引用应该必须与合法的存储单元关联（指针则可以是NULL）。 一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。 本质上是对指针的封装 123int n = 100;int &amp;j = n;cout &lt;&lt; &amp;j &lt;&lt; &quot; &quot; &lt;&lt; &amp;n; 输出结果 10x61fe14 0x61fe14 j就是n，n就是j 强弱类型12345678int main()&#123; int n = 100; int x = 200; char *p = &amp;x;//这句话不合法，类型必须相同 char *q = (char *)malloc(sizeof(int));//这句合法，因为所有32位下的指针类型都是4个字节 return 0;&#125; 类类是抽象的，对象是实例 访问修饰符 与结构体不同，类必须写访问修饰符public或private。 缺省情况下默认是private，结构体默认是public。 私有成员变量不允许通过对象进行访问，但可以被共有成员函数访问。 12345678910111213#include&lt;iostream&gt;using namespace std;class People&#123;public: int age; &#125;;int main()&#123; People p; p.age = 10; return 0;&#125; 对象属性（成员变量）下面的代码中People是类，p是对象 age、weight、sex、name是属性（成员变量） 12345678910111213141516#include&lt;iostream&gt;using namespace std;class People&#123;public: int age; int weight; int sex; char name[12];&#125;;int main()&#123; People p; p.age = 10; return 0;&#125; 行为（成员函数）私有成员变量不允许通过对象进行访问，但可以被公有成员函数访问。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;class People&#123;private: int age = 0; int weight; int sex; char name[12];public: int getage() //行为（成员函数） &#123; return age; &#125; void setAge() &#123; age++; &#125;&#125;;int main()&#123; People p; //p.age = 10; p.setAge(); int age = p.getage(); cout &lt;&lt; age &lt;&lt; endl; return 0;&#125; 输出结果 121 函数重载 相同声明域（都在全局或都在一个类下）函数名字相同但是参数列表不同（类型和个数不完全相同）。 只有返回值类型不同不算重载函数 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;class People&#123;private: int age = 0; int weight; public: void setWeight() &#123; weight = 0; &#125; void setWeight(int w) &#123; weight = w; &#125; void setWeight(double w) &#123; weight = w; &#125;&#125;;int main()&#123; People p; //p.age = 10; p.setWeight(); p.setWeight(50); p.setWeight(62.3); return 0;&#125; 构造函数 构造函数是类的一种特殊成员函数，一般情况下，构造函数是专门用于初始化成员变量的，所以最好不要在构造函数中进行与对象的初始化无关的操作 构造函数的函数名一定与类的名称完全相同，而且没有返回值（不是说返回值是void或者int，而是说不允许指定返回值） 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;class People&#123;private: int age; int weight;public: People() &#123; age = 1; &#125; People(int w)//构造函数可以重载 &#123; weight = w; &#125; int getAge() &#123; return age; &#125; int getWeight() &#123; return weight; &#125;&#125;;int main()&#123; People p;//创建对象时会运行构造函数,p是通过People()出生的 People xx(8);//xx是通过People(int w)出生的 //p.age = 10; cout &lt;&lt; p.getAge() &lt;&lt; &quot; &quot; &lt;&lt; xx.getWeight() &lt;&lt; endl; return 0;&#125; 输出结果 121 8 当形参和成员属性名字相同时,使用this是调用这个函数的对象的地址 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;class People&#123;private: int age; int weight;public: People(int weight) &#123; age &#x3D; 1; this-&gt;weight &#x3D; weight; &#125;int getWeight() &#123; return weight; &#125;&#125;;int main()&#123; People p(8); cout &lt;&lt; p.getAge() &lt;&lt; &quot; &quot; &lt;&lt; xx.getWeight() &lt;&lt; endl; return 0;&#125; 输出结果 121 8 析构函数 只要是对象的生命期结束时，会自动启用析构函数。 析构函数不能重载。 ~类名 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class People&#123;private: int age; int weight; char *name;public: People() &#123; name = (char *)malloc(100); strcpy(name,&quot;123456&quot;); &#125; ~People()//不能重载 &#123; free(name); &#125;&#125;;int main()&#123; People p; return 0;&#125; 初始化列表 赋值先后顺序更书写顺序无关 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class People&#123;private: int age; int weight; char *name;public: People() : age(0),weight(8),name(NULL) &#123; name = (char *)malloc(100); strcpy(name,&quot;123456&quot;); &#125; ~People()//不能重载 &#123; free(name); &#125;&#125;;int main()&#123; People p; return 0;&#125; 拷贝构造函数※拷贝构造函数是特殊的成员函数 调用时机对象需要通过另外一个对象进行初始化123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class People&#123;private: int age; int weight; char *name;public: People() &#123; &#125; People(const People&amp; p)//拷贝构造函数 &#123; this-&gt;age = p.age; &#125; void setAge(int age) &#123; this-&gt;age = age; &#125; int getAge() &#123; return age; &#125;&#125;;int main()&#123; People p1; p1.setAge(10); cout &lt;&lt; p1.getAge() &lt;&lt; endl; People p2(p1); cout &lt;&lt; p2.getAge() &lt;&lt; endl; return 0;&#125; 对象通过值传递的方式传入函数参数123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class People&#123;private: int age; int weight; char *name;public: People() &#123; &#125; People(const People&amp; p)//拷贝构造函数 &#123; this-&gt;age = p.age; &#125; void setAge(int age) &#123; this-&gt;age = age; &#125; int getAge() &#123; return age; &#125; ~People() &#123; cout &lt;&lt; &quot;game over&quot; &lt;&lt; endl; &#125;&#125;;void printPeople(People p)&#123; cout &lt;&lt; p.getAge() &lt;&lt; endl;&#125;int main()&#123; People p; p.setAge(10); printPeople(p); return 0;&#125; 输出结果 123410game overgame over 创建出了两个对象 主函数构造一个 printPeople构造一个 先输出的是printPeople的析构函数 后输出的是主函数的析构函数 对象以值传递的方式从函数返回??","categories":[],"tags":[]},{"title":"C语言学习笔记","slug":"C语言学习笔记","date":"2021-01-05T08:50:02.000Z","updated":"2021-01-07T08:56:21.526Z","comments":true,"path":"2021/01/05/C语言学习笔记/","link":"","permalink":"http://example.com/2021/01/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"主函数main函数的返回值类型必须是int，这样返回值才能传递给程序的激活者（如操作系统）。如果main函数的最后没有写return语句的话，C99 规定编译器要自动在生成的目标文件中（如 exe 文件）加入return 0; ，表示程序正常退出。任何其他非零的返回值都有操作系统定义的含义。通常非零返回值表明有错误出现。每一种操作系统都有自己的方式告诉用户main函数返回什么内容。 变量类型 int整型（通常为 16 位，其取值范围在-32768～32767 之间，也有用 32 位表示的int类型） float浮点型（通常是 32 位，它至少有 6 位有效数字，取值范围一般在 10-38～1038之间） char字符——一个字节 short短整型 long长整型 double双精度浮点型 在 C 语言及许多其它语言中，整数除法操作将执行舍位，结果中的任何小数部分都会被舍弃。但是，如果某个算术运算符有一个浮点型操作数和一个整型操作数，则在开始运算之前整型操作数将会被转换为浮点型。 类型转换unsighed类型unsighed类型只能是正数或0 unsigned比int高级，n &lt;= i时n被隐式类型转换，无符号数负数变为最大值。 12345678910111213#include&lt;stdio.h&gt;void test(int n)&#123; for (unsigned int i = 0; n &lt;= i; n--) &#123; printf(&quot;%d&quot;,n); &#125;&#125;int main()&#123; test(10); return 0;&#125; 输出结果 1死循环 1.强制类型转换123int a = 2;int b = 3;printf(&quot;%f&quot;,(float)a / b); 2.隐式类型转换123int a = 2;int b = 3;printf(&quot;%f&quot;,(a * 1.0) / b); 符号常量 在程序中使用”幻数”-就是具体的数，反映不出数字所代表的意义-无法向以后阅读该程序的人提供什么信息，使程序的修改变得更加困难。处理这种幻数的一种方法是赋予它们有意义的名字。#define指令可以把符号名（或称为符号常量）定义为一个特定的字符串。 1#define 名字 替换文本 程序中出现的所有在#define中定义的名字（既没有用引号引起来，也不是其它名字的一部分）都将用相应的替换文本替换。其中，名字与普通变量名的形式相同：它们都是以字母打头的字母和数字序列；替换文本可以是任何字符序列，而不仅限于数字。 符号常量名通常用大写字母拼写，这样可以很容易与用小写字母拼写的变量名相区别。注意，#define指令行的末尾没有分号。 运算符位运算符 按位与&amp; 按位或`` `` 按位异或^ 按位取反~ 左移运算符&lt;&lt; 左移1位相当于乘2 右移运算符&gt;&gt; 右移1位相当于除2 例题计算2^0 + 2^1 + 2^2 + 2^3 + 2^4 + … + 2^n的结果1234567int main()&#123; int n = 0; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%d&quot;,1 &lt;&lt; (n + 1) - 1); return 0;&#125; &amp;&amp;和||和!当&amp;&amp;前为0时不运行&amp;&amp;后面的 当||前不为0时不运行||后面的 12345678#include&lt;stdio.h&gt;int main()&#123; int a = 0, b = -1; printf(&quot;%d %d %d\\n&quot;, a++ &amp;&amp; b++, a, b); printf(&quot;%d %d %d&quot;, a++ || b++, a, b); return 0;&#125; 输出结果 120 1 -11 2 -1 三步运算符当a&gt;b成立返回1否则返回-1 1return a &gt; b ? 1 : -1 C语言运算符优先级 逻辑语句switch…case…break switch必须是整型 case必须是整型常量 case分支的值不能相同 break不可忽视 如果现在case分支中定义一个变量，加一个括号 所有case分支条件都不满足，那么执行default分支 12345678910111213141516171819#include&lt;stdio.h&gt;int main() &#123; int a; scanf(&quot;%d&quot;,&amp;a); switch(a) &#123; case 1: printf(&quot;%d&quot;,a); break; case 2: &#123; int b = 10; printf(&quot;%d&quot;,b); break; &#125; default: printf(&quot;输入有误&quot;)； break; &#125;&#125; goto用法C语言提供了可以随意滥用的goto语句以及标记跳转位置的标号。可以跳出多重循环。 例子求200以内的素数 12345678910111213141516171819202122#include&lt;stdio.h&gt;int main()&#123; int j = 0; for (int i = 2; i &lt;= 200; i++) &#123; int j = 2; while (j &lt; i) &#123; if (i % j == 0) //当i能被除自己和1意外的数字整除时跳出循环。 &#123; goto Tiaoguo; &#125; j++; &#125; printf(&quot;%d\\n&quot;,i); Tiaoguo: continue; &#125; return 0;&#125; 输出结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445462357111317192329313741434753596167717379838997101103107109113127131137139149151157163167173179181191193197199 指针基础房子理论变量的三大要素1.名字2.空间3.地址 两种操作1.读2.写 指针变量p中放的是谁的地址，*p就是谁 12345int a = 10;int* p = &amp;a;//指针变量:用来存储a的地址printf(&quot;%d\\n&quot;,*p);*p = 20;printf(&quot;%d\\n&quot;,a); 输出结果 121020 指针的运算1234567891011int main()&#123; int nums[10] = &#123;0, 1, 2, 3, 4, 5&#125;; int* p = nums; p++;//p = p + 1*sizeof(int); printf(&quot;%d &quot;, sizeof(int)); printf(&quot;%d &quot;, &amp;nums[0]); printf(&quot;%d &quot;, &amp;nums[1]); printf(&quot;%d &quot;, &amp;nums[2]); return 0;&#125; 指针变量的大小32位编译环境下是4个字节64位编译环境下是8个字节 函数数组[]的意思*(nums + i) &lt;===&gt;nums[i] 数组的名字代表的是数组第一个元素的地址（首地址）。 数组传参数组传参过程中，数组int nums[]会退化成指针int *nums。 12345678void fun(int* nums, int n)&#123;&#125;int main()&#123; int nums[] &#x3D; &#123;1,2,3,4&#125;; fun(nums,sizeof(nums)&#x2F;sizeof(int));&#125; 例题打乱顺序数组的顺序1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;void printArray (int *arry, int n)&#123; for (int i = 0; i&lt; n; i++)&#123; printf (&quot;%d &quot;, arry[i]); &#125;&#125;int main()&#123; int arry[11] = &#123; 1,2,3,4,5,6,7,8,9,10,11&#125;; srand(time(0));//种随机种子 for (int i = 0; i &lt; 11; i++) &#123; int r = rand() % 11; int t = arry[i]; arry[i] = arry[r]; arry[r] = t; &#125; printArray(arry, 11) ; return 0; &#125; 字符串 字符串用&quot;&quot; ASCII表 12345678#include&lt;stdio.h&gt;int main()&#123; printf(&quot;%d&quot;,&quot;abcdefghi&quot;); printf(&quot;\\n&quot;); printf(&quot;%d&quot;,*&quot;abcdefghi&quot;); return 0;&#125; 输出结果 12421068897 字符 char类型在内存中占1个字节字符用单引号&#39;&#39; 0，’0’,’\\0’1234567891011121314#include&lt;stdio.h&gt;int main()&#123; char c = &#x27;0&#x27;; printf(&quot;%c\\n&quot;,c); //0 printf(&quot;%d\\n&quot;,c); //48 c = 0; printf(&quot;%c\\n&quot;,c); // printf(&quot;%d\\n&quot;,c); //0 c = &#x27;\\0&#x27;; printf(&quot;%c\\n&quot;,c); // printf(&quot;%d\\n&quot;,c); //0 return 0;&#125; 转义字符1234567891011#include &lt;stdio.h&gt;int main ( )&#123; char c = &#x27;\\&#x27;&#x27;; c =&#x27;\\\\&#x27;; c =&#x27;\\n&#x27;; c = &#x27;\\t&#x27;; c = &#x27;\\a&#x27;; printf( &quot;%c&quot;, c); return 0;&#125; &quot;&quot;代表的是字符串中首个字符的地址1234567#include&lt;stdio.h&gt;int main()&#123; printf(&quot;%d\\n&quot;,&quot;abcdefghi&quot;);//字符串实际上时第一个字符的地址，即字符串的首地址 printf(&quot;%d\\n&quot;,*&quot;abcdefghi&quot;);//*&quot;abcdefghi&quot;即为a return 0;&#125; 输出结果 12421068897 为什么使用char*存储字符串12345678#include &lt;stdio.h&gt;int main()&#123; char* p = &quot;abcdefghi&quot;; p++;//p = p + sizeof(char)在遍历字符串的时候指针变量偏移一个字节 printf(&quot;%c&quot;, *p); return 0;&#125; 输出结果 1b 计算字符串长度 \\012:\\0后接八以内数字表示八进制 \\x12:\\x后接数字或abcdef表示十六进制 strlen()以\\0作为字符串结束标志 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char* p = &quot;a\\0\\n\\012ab0&quot;; printf (&quot;%d &quot;, sizeof(p)) ; //8 64位系统字符串占8个字节 printf (&quot;%d &quot;, sizeof (&quot;a\\0\\n\\012ab0&quot;)); //8 //a 0 \\n \\012 a b 0 \\0 int n = strlen(p); printf (&quot;%d &quot;, n); //1 //a \\0 strlen()以\\0作为字符串结束标志,其中\\0不计入长度 p++; p++; n=strlen (p) ; printf(&quot;%d &quot;, n); //5 // \\n \\012 a b 0 \\0 return 0;&#125; 输出结果 18 8 1 5 字符数组和字符串常量的区别常量 常量不可修改 整型常量 10 100 字符常量 ‘a’ ‘c’ 浮点常量 1.1 1.01 字符串常量 “asdfd” 地址常量 变量的地址 数组名字 函数名字 1234567891011121314151617#include&lt;stdio.h&gt;int main()&#123; char* p = &quot;a\\0\\n\\012ab0&quot;; //字符串常量 char b[10] = &quot;a\\0\\n\\012ab0&quot;; //字符数组 printf(&quot;%d &quot;,sizeof(p)); //8 printf(&quot;%d &quot;, sizeof(b)); //10 //p++; //b++; //b为数组名是常量不允许修改，该语句有错 //*p++; //*b++; //b++先执行后执行*，产量不允许修改，同上 //(*p)++; //p存储的是字符串中第一个字符的地址，字符串存放在常量区是常量，不允许修改 //(*b)++; return 0;&#125; gets函数 gets函数只有一个参数。参数类型为char*型，即str可以是一个字符指针变量名，也可以是一个字符数组名。 gets()函数的功能是从输入缓冲区中读取一个字符串存储到字符指针变量str所指向的内存空间。 gets()函数不仅比scanf简洁，而且，就算输入的字符串中有空格也可以直接输入，不用像scanf那样要定义多个字符数组。 gets(str);完全可以取代:scanf(&quot;%s&quot;, string); 12345678#include&lt;stdio.h&gt;int main()&#123; char *gets(char *str); char a[50]; gets(a); return 0;&#125; 123456789# include &lt;stdio.h&gt;int main(void)&#123; char str[20] = &quot;\\0&quot;; //字符数组初始化\\0 printf(&quot;请输入字符串：&quot;); gets(str); printf(&quot;%s\\n&quot;, str); return 0;&#125; 输出结果 12请输入字符串：hello the worldhello the world 字符数组的两种遍历方式不同点参考上面《字符数组和字符串常量的区别》 123456789101112131415161718192021#include&lt;stdio.h&gt;int main()&#123; char str[20] = &quot;&quot;; gets(str); int i = 0; while( str[i] != &#x27;\\0&#x27;) &#123; printf(&quot;%c&quot;,str[i]); i++; &#125; char *p = str; while ( *p != &#x27;\\0&#x27;) &#123; printf(&quot;%c&quot;,*p); p++; &#125; return 0;&#125; 字符串函数常见操作 指针变量判空 最后赋值&#39;\\0&#39; 返回值（目的地址）以便支持链式操作 例题1.字符串拷贝123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;char* m_strcpy(char* des, const char* src)&#123; //1.判断指针变量是否为NULL if (des == 0 || src == 0) &#123; return 0;//结束 &#125; //2.字符串拷贝 int i = 0; for (i = 0; src[i] != &#x27;\\0&#x27;; i++) &#123; des[i] = src[i]; &#125; //3.赋值&#x27;\\0&#x27; des[i] = &#x27;\\0&#x27;; //4.返回值目的地址 return des; //支持链式操作&#125;int main()&#123; char src[100] = &quot;&quot;; gets(src); char des[100] = &quot;&quot;; //strcpy(des,src); m_strcpy(des, src); printf(&quot;%s&quot;, des); return 0;&#125; 内存管理常量区特点： 军事管理区，不可修改 常量区空间没有名字 整型常量 10 20 -10 浮点常量 1.2 1.001 字符常量 &#39;a&#39; &#39;0&#39; &#39;\\0&#39; 字符串常量 &quot;adjkls&quot; &quot;56as&quot; 地址常量 int a; &amp;a 数组名 函数名 栈区特点： 租的房子，房子到期自动回收 访问速度快 空间少 作用域和生命周期从定义的位置开始到&#39;&#125;&#39; 常用于局部变量、函数参数 全局区全局变量 特点 局部大于全局（当局部变量和全局变量重名时局部变量优先） 初始化默认为0 生命周期为程序开始到程序结束 作用域为整个项目 引用其他文件中的全局变量 123456789101112131415/mian.c/#include&lt;stdio.h&gt;int g_value;int main()&#123; printf(&quot;%d&quot;,g_value); return 0;&#125;/*a.c*/extern int g_value;void print()&#123; g_value = 100; printf(&quot;%d&quot;,g_value);&#125; 静态区静态局部变量 生命周期从程序开始到程序结束 作用域到&#39;&#125;&#39; 函数结束不释放※ 只被初始化一次※ 123456789101112131415#include&lt;stdio.h&gt;int fun()&#123; int a = 10; static int s = 10; printf(&quot;%d &quot;, a++); printf(&quot;%d &quot;, s++);&#125;int main()&#123; fun();//10 10 fun();//10 11 return 0;&#125; 静态全局变量 生命周期从程序开始到程序结束 作用域为当前文件 堆区特点 买的房子，不会自动释放 不会自动释放 容量大 访问速度慢 堆区空间没有名字 用完需要释放 1234567891011121314#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main()&#123; char* p = malloc(400);//在堆区申请空间（买房子） //返回值为地址，不一定是char，但一定是* //char* 房子被分为400份，一份1个字节 //int* 房子被分为100份，一份4个字节 strcpy(p,&quot;123456&quot;); //房子不用是记得释放 free(p); return 0;&#125; 注意 不要访问越界 不要忘记释放空间 GetMemory笔试题Test112345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void GetMemory1(char *p) &#123; p = (char *)malloc(100);//强制类型转换&#125;void Test1() &#123; char *str = NULL; GetMemory1(str); strcpy(str, &quot;hello world&quot;); printf(str);&#125;int main() &#123; Test1(); return 0;&#125; 访问空指针，异常退出 解决办法1123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char *GetMemory1(char *p) &#123; p = (char *)malloc(100); return p;&#125;void Test1(void) &#123; char *str = NULL; str = GetMemory1(str); strcpy(str, &quot;hello world&quot;); printf(str); free(str);&#125;int main() &#123; Test1(); return 0;&#125; 解决办法21234567891011121314151617#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void GetMemory1(char **p) &#123; //二级指针变量**p *p = (char *)malloc(100);//强制类型转换&#125;//p存放的是str的地址void Test1() &#123; char *str = NULL; GetMemory1(&amp;str); strcpy(str, &quot;hello world&quot;); printf(str); free(str);&#125;int main() &#123; Test1(); return 0;&#125; Test212345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char *GetMemory2(void) &#123; char p[] = &quot;hello world&quot;; return p;&#125;void Test2(void) &#123; char *str = NULL; str = GetMemory2(); printf(str);&#125;int main() &#123; Test2(); return 0;&#125; 字符数组在栈区分配，函数结束被释放 Test312345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char *GetMemory3 (void) &#123; char *p = &quot;hello world&quot;;//字符串是常量，不会改变 故虽然p被释放但常量空间不释放 return p;&#125;void Test3 (void) &#123; char *str = NULL; str = GetMemory3(); printf(str);&#125;int main() &#123; Test3(); return 0;&#125; 输出结果 1hello world Test412345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char *GetMemory4 (void) &#123; static char p[] = &quot;hello world&quot;; return p;&#125;void Test4 (void) &#123; char *str = NULL; str = GetMemory4(); printf(str);&#125;int main() &#123; Test4(); return 0;&#125; 输出结果 1hello world 静态局部变量不会被释放空间，生命周期是全局的 Test5123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void Test5 (void) &#123; char *str = (char *)malloc(400); strcpy(str, &quot;hello&quot;); free(str); //str = NULL; if (str != NULL) &#123; strcpy(str, &quot;world&quot;); printf(str); &#125;&#125;int main() &#123; Test5(); return 0;&#125; 输出结果 1world str被free后变为野指针，空间被释放，但仍存储着房子的地址 free是剥夺变量房子的使用权，但变量仍记得房子地址 平时记得买完房子free记得置空str = NULL; 内存已经被释放，访问野指针造成内存泄漏 指针在free后未赋值 NULL，便会使人以为是合法的。它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。※ Test612345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void Test6 (void) &#123; char *str = (char *)malloc(400); strcpy(str, &quot;hello&quot;); str += 6; free(str); if (str != NULL) &#123; strcpy(str, &quot;world&quot;); printf(str); &#125;&#125;int main() &#123; Test6(); return 0;&#125; str += 6;后地址改变free卖的是别人的房子 出现异常，释放空间不对。 结构体结构体定义123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct STUDENT&#123; int number; int age; int weight; char s;&#125;student; //student为全局变量typedef struct STUDENT1&#123; char a; int weight; char s;&#125;student1; //student1等于STUDENT1int main()&#123; student.age = 10; struct STUDENT abc = &#123;1001, 22, 110, &#x27;M&#x27;&#125;; //初始化结构体 student1 bcd = &#123;1001, 22, 110, &#x27;M&#x27;&#125;; //等于struct student bcd = &#123;1001, 22, 110, &#x27;M&#x27;&#125;; //通常用typedef sturct,方便 printf(&quot;%d %d %d %c &quot;,abc.number,abc.age,abc.weight,abc.s); return 0;&#125; 输出结果 11001 22 110 M 字节对齐 按照最长的成员对齐 保证整数倍地址对齐（比如：short占两个字节不能放在奇数地址，char随便放奇偶都可以） 12345typedef struct STUDENT&#123; int a; char c;&#125;student; 123456typedef struct STUDENT&#123; char s; int a; char c;&#125;student; 1234567typedef struct STUDENT&#123; int a; char s; char c; short d; //short占两个字节&#125;student; 1234567typedef struct STUDENT&#123; int a; char s; short d; char c;&#125;student; 12345678typedef struct STUDENT&#123; int a; long long c; //long long占八个字节 char d; int b; short s;&#125;student; 1234567typedef struct STUDENT&#123; char a : 2;//2代表2比特bt，一个字节8bt char b : 2; char c : 2; char d : 2;&#125;student; 结构体定义的原则，保证结构体字节对齐 12345678### pragma pack(2)//控制结构体按2字节对齐typedef struct STUDENT&#123; int a; char c; char res[3];//跨平台时由于编译器不同，需强制对齐&#125;student;#pragma pack() 结构体数组p-&gt;score &lt;===&gt; (*p).score12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct STUDENT&#123; int number; int score;&#125;student;int main()&#123; int array[10]; char buffer[10]; student s[10] = &#123;&#123;1,10&#125;,&#123;2,30&#125;&#125;; printf(&quot;%d&quot;,s[0].number); student* p = s; printf(&quot;%d &quot;,s[0].score); printf(&quot;%d &quot;,(*p).score); printf(&quot;%d&quot;,p-&gt;score); //p-&gt;score &lt;===&gt; (*p).score return 0;&#125; 输出结果 11 10 10 10 链表特点 空间不连续 不支持随机访问 插入删除的效率高 创建链表 head-&gt;next要初始化为空，因为链表以节点next域为空判断链表是否接受 head在栈区，malloc在堆区分配一片空间给head，head存放的是这片空间的地址 带头结点的头插法123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct NODE&#123; int num; struct NODE* next;//不能用Node，因为编译顺序Node在这句话之后&#125;Node;int main()&#123; Node *head = (Node *)malloc(sizeof(Node)); //head-&gt;next要初始化为空，因为链表以节点next域为空判断链表是否接受 head-&gt;next = NULL; //head在栈区，malloc在堆区分配一片空间给head， //head存放的是这片空间的地址 int number; while (1) &#123; scanf(&quot;%d&quot;,&amp;number); if (number &lt;= 0) &#123; break; &#125; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;num = number; p-&gt;next = head-&gt;next; head-&gt;next = p; &#125; return 0;&#125; 打印链表12345678void printLink(Node* p)&#123; while (p) // &lt;===&gt; p != NULL &#123; printf(&quot;%d &quot;,p-&gt;num); p = p-&gt;next; //不能用p++，因为链表空间不是连续的 &#125;&#125; 释放链表123456789void freeLink(Node* p)&#123; Node *q = NULL; while (p) &#123; q = p; p = p-&gt;next; free(q); &#125;&#125; 查找节点1234567891011Node* searchLink(Node* p, int num)&#123; while (p) &#123; if(p-&gt;num == num) &#123; return p; &#125; p = p-&gt;next; &#125; return NULL;&#125; 修改节点123456789101112Node* modifyLink(Node* p, int num)&#123; while (p) &#123; if(p-&gt;num == num) &#123; p-&gt;num = 20; return p; &#125; p = p-&gt;next; &#125; return NULL;&#125; 删除节点12345678910111213141516171819int modifyLink(Node* p, int num)&#123; if(p == NULL) return; //默认带头节点 Node *q = p; p = p-&gt;next; while (p) &#123; if(p-&gt;num == num) &#123; q-&gt;next = p-&gt;next; free(p); return 0; &#125; q = p; p = p-&gt;next; &#125; return 1;&#125; 插入节点在findnum前插入一个num = newnum的节点 123456789101112131415161718192021int modifyLink(Node* p, int findnum, int newnum)&#123; if(p == NULL) return; //默认带头节点 Node *q = p; p = p-&gt;next; while (p) &#123; if(p-&gt;num == num) &#123; Node *r = (Node *)malloc(sizeof(Node)); r-&gt;num = findnum; q-&gt;next = r; r-&gt;next = p; return 0; &#125; q = p; p = p-&gt;next; &#125; return 1;&#125; 联合 所有成员共享一块空间 sizeof计算成员中字节最大的空间大小 各成员内存重叠 在使用时和结构体语法相同 优势 省空间 1234567891011121314#include&lt;stdio.h&gt;union UN&#123; int a; int c;&#125;;int main()&#123; printf(&quot;%d\\n&quot;,sizeof(union UN)); union UN u; u.a = 10; printf(&quot;%d %d\\n&quot;,u.a,u.c); return 0;&#125; 输出结果 123410 10 1234567891011121314#include&lt;stdio.h&gt;union UN&#123; int a; char c;&#125;;int main()&#123; printf(&quot;%d\\n&quot;,sizeof(union UN)); union UN u; u.c = 10; printf(&quot;%d %d&quot;,u.a,u.c); //a没有被赋值 return 0;&#125; 输出结果 12410 10 大小端小端存储高地址（数大的）放高位（如例子中的万位），低地址放低位 十进制 二进制 100000 0000 0000 0000 0001 1000 0110 1010 0000 0x1234 0x1235 0x1236 0x1237 1010 0000 1000 0110 0000 0001 0000 0000 大端存储低地址（数小的）放高位（如例子中的个位），高地址放低位 十进制 二进制 100000 0000 0000 0000 0001 1000 0110 1010 0000 0x1234 0x1235 0x1236 0x1237 0000 0000 0000 0001 1000 0110 1010 0000 例题：判断电脑cpu是什么架构，是大端存储还是小端存储常见电脑都是小端存储 12345678910111213141516#include&lt;stdio.h&gt;int checkSystem()&#123; union UN &#123; int a; char c; &#125;u; u.a = 1; return u.c == 1;&#125;int main()&#123; printf(&quot;%d&quot;,checkSystem()); return 0;&#125; 若是大端存储 十进制 二进制 1 0000 0000 0000 0000 0000 0000 0000 0001 0x1234 0x1235 0x1236 0x1237 0000 0000 0000 0000 0000 0000 0000 0001 输出结果 10 若是小端存储 十进制 二进制 1 0000 0000 0000 0000 0000 0000 0000 0001 0x1234 0x1235 0x1236 0x1237 0000 0001 0000 0000 0000 0000 0000 0000 输出结果 11","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"测试1错题","slug":"测试1错题","date":"2021-01-03T22:50:02.000Z","updated":"2021-01-06T10:31:54.936Z","comments":true,"path":"2021/01/04/测试1错题/","link":"","permalink":"http://example.com/2021/01/04/%E6%B5%8B%E8%AF%951%E9%94%99%E9%A2%98/","excerpt":"","text":"1.计算2^0 + 2^1 + 2^2 + 2^3 + 2^4 + … + 2^n的结果1234567int main()&#123; int n = 0; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%d&quot;,1 &lt;&lt; (n + 1) - 1); return 0;&#125; 2.任意一个大于2的偶数n都可以由两个素数的和组成，但是组成偶数的素数有很多种情况，输出所有情况。123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int n = 0; scanf(&quot;%d&quot;,&amp;n); int *nums = (int *)malloc(n*sizeof(int)); if (nums == NULL) &#123; return -1; //申请空间失败，返回异常状态 &#125; //初始化动态数组 for (int i = 0; i &lt; n; i++) &#123; nums[i] = 0; &#125; //厄拉多塞筛选法 for (int i = 2; i &lt; n; i++) &#123; if (nums[i] == 0) &#123; for (int j = i + i; j &lt; n; j += i) &#123; nums[j] = 1; &#125; &#125; &#125; for(int i = 2; i &lt; n / 2; i++) &#123; if (nums[i] == 0 &amp;&amp; nums[n - i] == 0) &#123; printf(&quot;%d %d\\n&quot;,i,n - i); &#125; &#125; free(nums); return 0;&#125;","categories":[],"tags":[]},{"title":"shell学习笔记01：两个简单的shell脚本","slug":"shell学习笔记01：两个简单的shell脚本","date":"2020-05-30T02:10:04.000Z","updated":"2021-01-06T10:06:04.408Z","comments":true,"path":"2020/05/30/shell学习笔记01：两个简单的shell脚本/","link":"","permalink":"http://example.com/2020/05/30/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%EF%BC%9A%E4%B8%A4%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84shell%E8%84%9A%E6%9C%AC/","excerpt":"","text":"1.添加用户user1-10，但要求只有用户不存在的情况下才能添加。 2.切换工作目录至/var；统计/var目录下共有多个文件，并显示出来。 注意运行shell时如果提示权限不够时需先运行chmod 764 test.sh。 1.添加用户user1-10123456789101112131415161718192021222324#!/bin/sh#添加用户user1-10,只有用户不存在时才添加。psw=&quot;1&quot;for i in `seq 1 10` do name=&quot;user&quot;$i&quot;&quot;; sudo useradd $name; #判断该用户是否存在。 if [ $? -eq 0 ];then echo &quot;user $&#123;name&#125; is created successfully!&quot; else echo &quot;user $&#123;name&#125; is existed!&quot; continue fi #判断密码设置是否成功。 echo $password | sudo password --stdin $name; if [$? -eq 0 ];then echo &quot;$&#123;name&#125;&#x27;s password is set successfully&quot; else echo &quot;$&#123;name&#125;&#x27;s password is set failly!&quot; fidone 定义变量时等号不能加空格。 #!是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。 拼接字符串，可以使用单引号或双引号拼接。 12name=&quot;user&quot;user_name=&quot;&quot;$name&quot;1&quot; #user_name=&quot;$&#123;name&#125;1&quot; 2.统计/var目录下共有多个文件1234567891011#!/bin/sh#切换工作目录至/ver;#依次向/var目录下的每个文件或子目录问好;#统计/var目录下共有多少个文件，并显示出来。i=0cd /varfor FILE in /var/*do i=`expr $i + 1`;doneecho $i “`”的作用是将”``”中间的语句当成命令执行","categories":[],"tags":[]},{"title":"解决microsoft应用商店开启代理后无法连接问题","slug":"解决microsoft应用商店开启代理后无法连接问题","date":"2020-05-16T11:28:27.000Z","updated":"2021-01-06T01:45:18.818Z","comments":true,"path":"2020/05/16/解决microsoft应用商店开启代理后无法连接问题/","link":"","permalink":"http://example.com/2020/05/16/%E8%A7%A3%E5%86%B3microsoft%E5%BA%94%E7%94%A8%E5%95%86%E5%BA%97%E5%BC%80%E5%90%AF%E4%BB%A3%E7%90%86%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题Microsoft的全部应用在中国区的设置默认都是直连，所以当打开网络代理之后就无法使用应用商店。 解决办法使用Fiddler，点击左上角winconfig，将需要更改的Microso应用打勾✔。","categories":[],"tags":[{"name":"日常问题","slug":"日常问题","permalink":"http://example.com/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"title":"Linux基本操作","slug":"Linux基本操作","date":"2020-04-25T04:30:42.000Z","updated":"2021-01-06T07:56:44.382Z","comments":true,"path":"2020/04/25/Linux基本操作/","link":"","permalink":"http://example.com/2020/04/25/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"Linux的目录 /root：根目录/bin：包含供每个人使用的可执行程序/sbin：包含仅供管理员使用的可执行程序/lib：包含库文件/boot：包括了内核镜像和其它相关内容/dev：包含着代表硬件设备的设备文件/etc：包含着整个系统的各种配置文件/home：包含各用户的主目录/root：是root的主目录/mnt：包含装载其它非标准文件系统的装载点/proc:是个虚拟目录，里面保存内核和进程的信息/tmp：是为程序和用户提供放置临时空间的目录/usr：包含UNIX系统的众多资源，较占空间/var：目录包含了一些文件大小比较特殊的文件，如日志文件，锁文件等，还包括各种用途的文件，如：邮件、计划、打印文件等/lost+found：存在于所有的文件系统中，保存文件碎片/opt：是由一些外部应用程序使用的目录 其它一些用户自己建的目录 工作目录：用户在登录到Linux系统中之后，每时每刻都”处在”某个目录之中，此目录被称作工作目录或当前目录（Working Directory）。工作目录是可以随时改变的。工作目录用.表示，其父目录用..表示。 主目录：是系统管理员增加用户时建立起来的（以后也可以改变），每个用户都有自己的主目录用于保存信息，不同用户的主目录一般互不相同。 用户初始登录到系统中时，其主目录（Home Directory）就成为其工作目录，通常与用户的登录名相同。 用户可以通过一个~字符来引用自己的主目录。例如命令：$ cat ~/file1 Linux常用命令最常用的几个命令可用pwd命令查看用户的当前目录可用cd命令来切换目录.表示当前目录..表示当前目录的上一级目录（父目录）-表示用cd命令切换目录前所在的目录~表示用户主目录的绝对路径名--help查看该操作的帮助信息--version显示版本信息并退出clear清除屏幕 修改口令passwd对用户口令进行操作 who命令who显示当前已登录的用户信息who am i：等价于who -mwhoami：显示当前“操作用户”的用户名 echo命令显示输出字符串 用法：/bin/echo [短选项]... [字符串]... 或：`/bin/echo 长选项`` ​ echo将 STRING 回显到标准输出。 ​ -n不尾随换行符 ​ -e启用解释反斜杠的转义功能 ​ -E禁用解释反斜杠的转义功能(默认) 注意：echo的帮助信息需要输入/bin/echo --help date命令显示或设置系统的日期和时间 用法：date [选项]... [+格式] 或：date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]] cal命令cal显示日历 文件和目录操作相关命令cat命令连接文件并打印到标准输出设备上 用法：cat [选项]... [文件]... more命令用于显示内容超过一屏的文件 用法：more [选项] &lt;文件&gt;...more 内部命令键:Space、Enter、/、h、 b、q。 less的作用与more十分相似，都可以用来浏览文字档案的内容，不同的是less允许使用者往回卷动。 Head/Tail命令用来显示开头或结尾某个数量的文字区块 用法：head [选项]... [文件]... 用法：tail [选项]... [文件]... od命令以指定格式显示文件，默认为八进制 用法：od [选项]... [文件]... 或：od [-abcdfilosx]... [文件] [[+]偏移量[.][b]] 或：od --traditional [选项]... [文件] [[+]偏移量[.][b] [+][标签][.][b]] file命令辨识文件类型 用法：file[选项]... [文件]... touch命令改变档案的时间记录 用法：touch[选项]... [文件]... grep命令查找文件里符合条件的字符串 用法：grep[选项]... [查找模式]... [文件]... 其中-n选项可输出匹配行的行号，-r选项表示在目录中递归查找符合的文件名。 find命令文件查找命令 用法：find[路径]... [选项]... 其中-name选项用于通过文件名查找，-size选项用于通过文件大小查找等。 locate命令快速文件查找命令，该命令在运行时需要后台索引的数据库支撑，可以执行sudo updatedb来手动更新。 用法：Locate[选项]... [文件]... sort命令对文件中的各行进行排序。默认以升序词典顺序排序文件的内容。每一列的字符，包括空格、数字和特殊字符都经一一比较。 用法：sort[选项]... [文件列表]... -d选项：只比较字母、数字和空格，其他忽略。 uniq命令将相邻的重复行从输出文件中删除，只留下每条记录的唯一样本。可结合sort命令使用。 用法：uniq[选项]... [文件]... wc命令统计指定文件中的行数、字数、字节数， 并将统计结果显示输出。 用法：wc[选项]... [文件]... comm命令该命令是对两个已经排好序的文件进行比较。其中file1和file2是已排序的文件。comm读取这两个文件，然后生成三列输出。仅在 file1中出现的行；仅在file2中出现的行；在两个文件中都存在的行。其中- 123选项为选择哪列显示。 用法：comm [- 123 ] file1 file2 diff命令该命令的功能为逐行比较两个文本文件，列出其不同之处。 用法：diff[选项]... [文件1]... [文件名2]... cp命令文件复制 用法：cp[选项]... [源文件名或目录]... [目标文件名或目录]... -r若给出的源文件是一目录文件，此时cp将递归复制该目录下所有的子目录和文件。此时目标文件必须为一个目录名。 -a该选项通常在拷贝目录时使用。它保留链接、文件属性，并递归地拷贝目录。 -f删除已经存在的目标文件而不提示。 rm命令删除文件命令 用法：rm[选项]... [文件列表]... -f忽略不存在的文件，从不给出提示。 -r指示rm将参数中列出的全部目录和子目录均递归地删除。 -i进行交互式删除。 mv命令移动文件命令 用法：mv[选项]... [源文件/目录名]... [目标文件/目录名]... -f覆盖前不询问 -i覆盖前询问 -n不覆盖已存在文件 ln命令文件链接命令，包括硬链接和软链接两种。其中硬链接使得链接数加1，不能链接目录，不能跨文件系统。 用法：ln[选项]... [源文件]... [目标文件]... mkdir/rmdir命令创建目录、删除空目录。 用法：mkdir/rmdir[选项]... [目录名]... rmdir的-p选项，表示当删除目录的父目录为空时，父目录也一并删除。 ls 命令列出目录内容 用法：ls[选项]... [文件或目录]... -a显示所有文件，包括隐藏文件 -R显示所有文件，包括子目录下的文件 -l显示文件的详细信息 -d显示目录的信息而不是目录所含的内容 -i显示文件的inode数 命令的输入和输出 标准I/O文件 标准输入(stdin) 0 标准输出(stdout) 1 标准错误输出(stderr) 2 输出重定向：&gt; 1&gt; 2&gt; &amp;&gt; （含1和2） 附加重定向：&gt;&gt; 输入重定向：&lt;，0&lt; 管道：上一个命令的stdout接到下一个命令的stdin;管道符号| 过滤器：用来接收标准输入，经过一定的转化，再写到标准输出。所以，过滤器一般放在管道符中间。如：ls | sort | more 联机帮助命令help：显示bash shell内置命令的简单信息。使用help命令不带任何参数将显示bash shell所有内置的命令。 用法：help[命令]...man：显示对应命令系统的帮助手册。 用法：man[选项]... [章节数字]... [命令]...whatis:描述一个命令执行什么功能。等同于使用man -f命令 用法：whatis [命令]...whereis：从环境变量的路径中查找符合条件的文件。 用法：whereis[选项]... [文件]... 网络管理命令ifconfig程序设置，检查以及监控网络接口的配置值。 用法：ifconfig [interface_name] [ip_address] [up|down] route路由显示及配置网络路由 netstat 程序显示网络连接、路由表和网络接口信息，可以让用户得知目前都有哪些网络连接正在运作。 用法：netstat［选项］... -a所有连接 -r路由表 -tTCP协议（-u） ping程序用于查看网络上的主机是否在工作，它向该主机发送ICMP ECHO_REQUEST包。当想从网络上的某台主机上下载文件，可是又不知道那台主机是否开着，就需要使用ping命令查看。 用法：ping［选项］ [主机名/IP地址] -c数目 在发送指定数目的包后停止。 -d设定SO_DEBUG的选项。 -f大量且快速地送网络封包给一台机器，看它的回应。 -I秒数 设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"使用Github PicGo搭建图床","slug":"使用Github-PicGo搭建图床","date":"2020-03-22T05:50:16.000Z","updated":"2021-01-06T01:45:20.166Z","comments":true,"path":"2020/03/22/使用Github-PicGo搭建图床/","link":"","permalink":"http://example.com/2020/03/22/%E4%BD%BF%E7%94%A8Github-PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"在github中搭建图床1.创建Repository一定要选择public,private的仓库，图片链接会带token，这个token又存在过期的问题。 这里因为我已经有一个叫Figurebed的仓库所以”Repository name”不可用. README.md可选可不选。 2.创建一个token 选择最下方Developer setting 选择左下方Personal access tokens 右上角generate generate token 新生成的token一定要先复制到其他地方留作备用 配置PicGo1.下载PicGohttps://github.com/Molunerfinn/PicGo 2.配置PicGo 设定仓库名，按照“用户名/仓库名”的格式 分支名填写“master” 将之前留作备用的token粘贴在这里 img/存储路径，会在repository中创建一个img文件夹 设定自定义域名后，上传图片成功后，PicGo会自动生成该图片的访问链接 https://raw.githubusercontent.com/用户名/RepositoryName/分支名 3.相关设置我习惯关闭自动更新，开启开机自启 快捷键可自己设置，我是参考别人用的ctrl+shift+c","categories":[],"tags":[]},{"title":"hexo常用指令","slug":"hexo常用指令","date":"2020-03-21T08:50:02.000Z","updated":"2021-01-06T03:30:17.268Z","comments":true,"path":"2020/03/21/hexo常用指令/","link":"","permalink":"http://example.com/2020/03/21/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","excerpt":"","text":"hexo常用指令12345678910hexo new &quot;postName&quot; &#x2F;&#x2F;新建文章hexo new page &quot;pageName&quot; &#x2F;&#x2F;新建页面hexo g &#x2F;&#x2F;生成静态页面至public目录hexo server &#x2F;&#x2F;开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）hexo deploy &#x2F;&#x2F;将.deploy目录部署到GitHubhexo cleanhexo ghexo dhexo d -g #生成部署hexo s -g #生成预览 文件信息123456---title: xxx &#x2F;&#x2F;在此处添加你的标题。date: 2016-10-07 13:38:49 &#x2F;&#x2F;在此处输入编辑这篇文章的时间。tags: xxx &#x2F;&#x2F;在此处输入这篇文章的标签。categories: xxx &#x2F;&#x2F;在此处输入这篇文章的分类。--- 文件编辑完成后发布12hexo ghexo d","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"设置hexo首页只显示博文摘要","slug":"设置hexo首页只显示博文摘要","date":"2020-03-21T01:36:03.000Z","updated":"2021-01-06T02:09:10.530Z","comments":true,"path":"2020/03/21/设置hexo首页只显示博文摘要/","link":"","permalink":"http://example.com/2020/03/21/%E8%AE%BE%E7%BD%AEhexo%E9%A6%96%E9%A1%B5%E5%8F%AA%E6%98%BE%E7%A4%BA%E5%8D%9A%E6%96%87%E6%91%98%E8%A6%81/","excerpt":"","text":"修改配置我使用的Volantis主题默认是开启只显示文章摘要的。该选项可以在blog\\themes\\主题名\\_config.yml文件中找到。 # When there is no description in the article’s front-matter, use excerpt as the description. use_excerpt_as_description: true 在其他主题中变量名可能会变，但一般都会有excerpt和description这两个单词。 对文章的处理方法一：Description在文章的front-matter中添加description，首页会只显示description的内容。下面是本文front-matter title: 设置hexo首页只显示博文摘要date: 2020-03-24 12:10:54 tags: hexodescription: 针对Volantis主题，主题默认显示摘要是开启的，但需要在博文中加一些内容，使其只显示前面一部分。 方法二：文章截断在需要截断的地方加入下列语句。 &lt;!--more--&gt; 首页就会只显示这条以上的所有内容。 法二比法一方便一些，如果感觉文章开头写的不错就直接用法二更方便一点。","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"日常问题","slug":"日常问题","permalink":"http://example.com/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}