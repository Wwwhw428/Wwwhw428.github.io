{"meta":{"title":"Wwwhw's BLOG","subtitle":"","description":"","author":"Wang Haowen","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"QT","date":"2021-03-04T15:46:28.841Z","updated":"2021-03-04T16:46:46.086Z","comments":true,"path":"2021/03/04/QT/","link":"","permalink":"http://example.com/2021/03/04/QT/","excerpt":"","text":"Qt概述Qt是一个跨平台的C++图形用户界面应用程序框架 QWidget只有最大化、最小化、关闭的空白窗口 QMainWindow带菜单栏、状态栏、工具栏的窗口 Qdialog对话框，带按钮 项目文件 Headers分组：该节点下是项目内的所有头文件（.h） widget.h 是所设计的窗体类的头文件 Sources 分组：该节点下是项目内的所有 C++源文件（.cpp） 主程序入口文件 main.cpp，实现 main()函数的程序文件。 widget.cpp 是 widget.h 里 定义类的实现文件。C++ 中，任何窗体或界面组件都是用类封装的，一个类一般有一个头文件（.h 文件）和一个源程序文件（.cpp 文件）。 Forms 分组：该节点下是项目内的所有界面文件（.ui）。界面文件是文本文件，使用 XML 语言描述界面的组成。 窗体界面文件 widget.ui，一个 XML 格式存储的窗体上的元件及其布局的文件。 .pro.pro：是项目管理文件，包括一些对项目的设置项。 1234567891011121314151617181920212223242526272829303132#-------------------------------------------------## Project created by QtCreator 2021-03-05T00:09:56##-------------------------------------------------QT +&#x3D; core gui #表示项目中加入core gui模块#QT +&#x3D; sqlgreaterThan(QT_MAJOR_VERSION, 4): QT +&#x3D; widgets #当前版本比4多出来一个widgetTARGET &#x3D; temp #文件TEMPLATE &#x3D; app #模板# The following define makes your compiler emit warnings if you use# any feature of Qt which as been marked as deprecated (the exact warnings# depend on your compiler). Please consult the documentation of the# deprecated API in order to know how to port your code away from it.DEFINES +&#x3D; QT_DEPRECATED_WARNINGS# You can also make your code fail to compile if you use deprecated APIs.# In order to do so, uncomment the following line.# You can also select to disable deprecated APIs only up to a certain version of Qt.#DEFINES +&#x3D; QT_DISABLE_DEPRECATED_BEFORE&#x3D;0x060000 # disables all the APIs deprecated before Qt 6.0.0#源文件SOURCES +&#x3D; \\ main.cpp \\ widget.cpp#头文件HEADERS +&#x3D; \\ widget.h","categories":[],"tags":[]},{"title":"","slug":"斗地主","date":"2021-03-04T06:54:53.431Z","updated":"2021-03-05T07:01:14.784Z","comments":true,"path":"2021/03/04/斗地主/","link":"","permalink":"http://example.com/2021/03/04/%E6%96%97%E5%9C%B0%E4%B8%BB/","excerpt":"","text":"数据库 用户名 密码 总局数 胜利局数 头像代号 玩家类 用户名 密码 总局数 获胜局数 头像 当前游戏编号 当前身份（农民，地主） 手牌 登录功能卡组 卡组转换成字符串 卡组排序 牌型 卡牌 花色 点数 大小比较 信息报文游戏服务游戏窗口 窗口 按键 时间过滤 1.客户端大概流程main调用gamewindow库 huase.h枚举出所有花色 point.h按牌权值大小枚举出所有牌的点数 gamewindow.h gamewindow类 初始化窗口 初始化按钮 声明初始化函数 声明按钮变量 绘图时间 事件过滤器 QT部分 使用了core、gui、network、sql模块 ui使用的库 QWidget QTextBrowser QString QPushButton QLabel QEvent C++部分 在C++中，explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。 2.服务器大概注册——————–分割线——————-QString类append()&amp;prepend() append()用于在字符串的后面添加字符串 prepend()在字符串的前面添加字符串 例子1234Qstring a = &quot;卖&quot;, b = &quot;拐&quot;;Qstring c = a;a.append(b);//卖拐c.prepend(b);//拐卖 QPushButton123QPushButton::QPushButton(const QString &amp; text, QWidget * parent = 0)QPushButton::QPushButton(const QIcon &amp; icon, const QString &amp; text, QWidget * parent = 0) 第一个构造函数有两个参数 text 是按钮显示的文本，第二个 parent 是父窗口指针 第二个构造函数多了参数 icon，表示按钮图标，图标意味着有相关的图片资源","categories":[],"tags":[]},{"title":"Linux网络编程","slug":"Linux网络编程","date":"2021-02-19T10:00:42.000Z","updated":"2021-03-06T13:09:49.425Z","comments":true,"path":"2021/02/19/Linux网络编程/","link":"","permalink":"http://example.com/2021/02/19/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"IPeg：300Mb带宽指的是300兆bit，1Byte = 8 bit， 300Mb = 37.5MB 在不同主机上的进程间的通信 ipv4 4：4个Byte（字节）=&gt; 2^32 = 40亿 ipv6：6个Byte（字节）=&gt; 2^48 点分十进制的ip地址 eg：192.168.1.12 转二进制 11000000 10101000 00000001 00001100 mac地址物理地址（48位），每台机器出场时规定的唯一地址。如果根据物理地址来判断某台主机，数据将十分庞大但不利于管理。 IP地址的格式 网络号 net-id：它标志主机（或路由器）所连接到的网烙 主机号 host-id：它标志该主机（或路由器） IP地址通常由点分十进制的方式来表示。 图片 A类地址 A类地址范围：1.0.0.0 - 127.255.255.255 每类地址的第一个地址是网络地址，最后一个地址是广播地址，这两个地址都不允许作为主机地址。 子网掩码 子网掩玛要掩住网络位，故网络位有多少位就有多少个连续的1 eg：C类地址，255.255.255.0 或 192.168.1.X/24 子网可以再划分 eg：C类地址，11111111 11111111 11111111 10000000 将C类地址分为两个子网192.168.1.0-192.168.1.127和192.168.1.128-192.168.1.255 在同一子网下的ip地址于子网掩码与完是相同的 例题1.利用子网数需将B类IP地址167.194.0.0划分成28个子网：255.255.0.0 28 &lt; 2^5 故有2 * 8 + 5个网络位 255.255.247.0 11111000 32 64 128 2.利用主机数例如:需将B类IP地址167.194.0.0划分成若干个子网，每个子网内有主机500台: 500 &lt; 2^9 故需要九个主机位 =&gt;255.255.254.0 子网划分网络字节序※ 网络数据流的地址：先发出的数据是低地址，后发出的数据时高地址 网络数据流采用大端字节序：低地址高字节 如果发送主机或接受主机是小端字节序则需要做字节序的转换 123456789#include &lt;arpa/inet.h&gt;uint32_t htonl(uint32_t hostlong);uint16_t htons(uint16_t hostshort);uint32_t ntohl(uint32_t netlong);uint16_t ntohs(uint16_t netshort); h表示host,n表示network，l表示32位长整数，s表示16位短整数。 如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返 如果主机是大端字节序,这些函数不做转换,将参数原封不动地返回 uint32_t htonl(uint32_t hostlong); //四个字节 Socket编程1.套接字概念 本质为内核借助缓冲区形成的伪文件=&gt;可以使用文件描述符引用套接字 在网络通信中，套接字是成对出现的 在网络中通过IP + 端口号能唯一标识出一个进程 一次通信中需要三个套接字。 3.网络套接字函数socket()创建一个套接字 1234#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;int socket(int domain, int type, int protocol); 返回值：成功返回新的文件描述符即创建的套接字，失败返回-1。 int domain：网络类型（IP地址的类型） AF_INET：ipv4 AF_INET6：ipv6 int type：底层传输协议 SOCK_STREAM：流式套接字 SOCK_DGRAN： int protocol：常用0 bind()为套接字绑定地址结构信息 1234#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 返回值：成功返回0，失败返回-1并设置errno int sockfd：绑定的套接字 const struct sockaddr *addr：sockaddr_in结构体 man 7 调用时要强制转换为sockaddr struct sockaddr_in结构体：#include&lt;netinet/in.h&gt; sa_family_t sin_family：地址类型 in_port_t sin_port：符合网络字节序的端口号 struct in_addr sin_addr ：ip地址 ```c sturct in_addr { uint32_t s_addr;//符合网络字节序的ip地址 }; 123456789* socklen_t addrlen：传入参数，sockaddr_in的长度### listen&#96;&#96;&#96;c#include &lt;sys&#x2F;socket.h&gt;int listen(int sockfd, int backlog); 返回值：成功返回0，失败返回-1并设置errno int backlog： accept从全连接队列中取出一个连接，能够反映出三次握手是否成功 123#include &lt;sys/socket.h&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 返回值：指向一个新的套接字的文件描述符 struct sockaddr *addr：传入传出参数，传出客户端地址结构信息 socklen_t *addrlen：传入传出参数，客户端地址结构信息的长度 inet_pton/ntop将IPv4和IPv6地址从本地字节序转换成网络字节序/从网络字节序转换成本地字节序 123#include &lt;arpa/inet.h&gt;int inet_pton(int af, const char *src, void *dst); int af：AF_INET，AF_INET6 const char *src：IP地址字符串 void *dst：转换后的二进制数 123#include &lt;arpa/inet.h&gt;const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); 返回值：成功返回一个，失败返回空并设置errno const void *src： char *dst： socklen_t size： connect1234#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 返回值：成功返回0，失败返回-1并设置errno int sockfd：用于通讯的套接字 const struct sockaddr *addr：服务器的地址结构信息 例子123456789101112131415161718192021222324252627282930313233343536//server.c#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/socket.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;netinet/in.h&gt;#define SER_IP &quot;192.168.183.128&quot;#define SER_PORT 8000int main() &#123; char buf[1024]; //创建一个套接字 int lfd = socket(AF_INET, SOCK_STREAM, 0); //为套接字绑定地址结构信息 struct sockaddr_in ser_addr; int dst; inet_pton(AF_INET, SER_IP, (void*)&amp;dst); ser_addr.sin_family = AF_INET; ser_addr.sin_port = htons(SER_PORT); //ser_addr.sin_addr.s_addr = htonl(INADDR_ANY); //127.0.0.1本地回环 用于测试本地网络 ser_addr.sin_addr.s_addr = dst; bind(lfd, (struct sockaddr*)&amp;ser_addr, sizeof(ser_addr)); //服务器开始监听 listen(lfd, 64); socklen_t len = sizeof(ser_addr); int cfd = accept(lfd, (struct sockaddr*)&amp;ser_addr, &amp;len); //回射服务器 while(1) &#123; int rr = read(cfd, buf, 1024); write(STDOUT_FILENO, buf, rr);//#define STDOUT_FILENO 1 write(cfd, buf, rr); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233//client.c#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/socket.h&gt;#include&lt;netinet/in.h&gt;#define SER_IP &quot;192.168.183.128&quot;#define SER_PORT 8000int main() &#123; char buf[1024]; //创建一个套接字 int cfd = socket(AF_INET, SOCK_STREAM, 0); //客户端可以不绑定地址结构信息，不绑定系统自动分配一个 //需要服务器的地址结构信息 struct sockaddr_in ser_addr, cli_addr; ser_addr.sin_family = AF_INET; int dst; inet_pton(AF_INET, SER_IP, (void*)&amp;dst); ser_addr.sin_port = htons(SER_PORT); ser_addr.sin_addr.s_addr = dst; int cret = connect(cfd, (struct sockaddr*)&amp;ser_addr, sizeof(ser_addr)); if (cret &lt; 0) &#123; perror(&quot;connect error:&quot;); exit(1); &#125; printf(&quot;建立连接成功\\n&quot;); while(1) &#123; int rr = read(STDIN_FILENO, buf, 1024); write(cfd, buf, rr); &#125; return 0;&#125; 半连接队列：最后一次握手没完成 全连接队列：最后一次握手完成后从半连接队列移至全连接队列 accpet从全连接队列中将已经建立连接的节点取出到应用层中 判断是否有建立的连接==判断accpet是否有指向一个套接字的返回值 协议格式数据包封装以太网帧格式目的地址（mac地址） 源地址 TCP段格式16位源端口号，端口号最大时2^16=65536 16位目的端口号， 32位序号 32位确认序号 16位窗口大小（缓冲区大小） 16位紧急指针 TCP协议 传输层协议，可靠的，面向连接的传输层协议，速度较慢 UDP也是传输层协议，不可靠的（可能丢包等），无连接的传输层协议，速度较快 超时重传：基于确认应答，ACK丢了不会超时重传（不包括四次挥手） 确认应答 TTL：销毁迷途的包，每跳一次-1 序列号seq：占4个字节， 用来标记数据段的顺序, TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生;给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号 确认号ack：占4个字节 序列号表示报文段携带数据的第一个字节的编号，而确认号指的是期望接收到下一个字节的编号 因此当前报文段最后一个字节的编号+1即为确认号 确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效 同步SYN：连接建立时用于同步序号 当SYN=1, ACK=0时表示:这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1, ACK=1 SYN=1表示这是一个连接请求，或连接接受报文 SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0 终止FIN：用来释放-一个连接。FIN=1表示：此报文段的发送方的数据已经发送完 毕，并要求释放运输连接 ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0;ack、seq小写的单词表示序号 TCP通信时序三次握手 第一次握手（通常为客户机向服务器发）：发送SYN（SYN置为1）、初始序列号（32位序号，随机数）seq 第二次握手：服务器收到后同意握手请求，发送ACK（ACK标志位置为1，SYN置为1）、确认序号（初始序号+1） 第三次握手：客户机收到服务器发送的ACK后，发送ACK SYN：连接建立时用于同步序号 ACK：确认应答，占1位，置1表示确认确认序号有效 握手完成后 服务器给客户机发送数据 服务器发送序列号+数据 客户机回复ACK和确认序号（初始序号+数据 + 1 - 1即希望接收到的下一个字节编号） 客户机给服务器发送数据 客户机发送序列号+数据 服务器回复ACK和确认序号（初始序号+数据 + 1 - 1即希望接收到的下一个字节编号） 四次挥手 FIN：可能携带数据 CLOSE_WAIT：可以发送数据，不可以接受数据 流量控制客户端接收数据时 窗口大小：可接受的数据量 TCPUDP区别 TCP怎么实现可靠性… TCP流量控制 滑动窗口状态转换把正常的看懂 TIME_WAIT：等待2MSL（MSL = TTL估计时间），LAST_ACK没收到回复的ACK会超时重传，TIME_WAIT会再次发送ACK，保证四次挥手的完整；允许老的重复分节在网络中消逝 拥塞控制慢启动 拥塞窗口cwnd逐渐变大（以指数增长），门限值ssthresh初始值为65535 阈值记录拥塞窗口的最大值 拥塞窗口达到一定大小后启动拥塞避免 使用情况： 链接刚建立时,cwnd设为1，每经过一个轮次翻倍 发生超时重传时启用慢启动，cwnd设为1，门限值设为当前窗口大小的一半 当cwnd = 门限值时，既可以慢启动也可以拥塞避免 拥塞避免 每经过一个传输轮次+1 快重传&amp;快恢复 快重传：回复三个相同的ACK，不用等待超时重传，直接开始重传。快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（一般为三次）（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。 快恢复：ssthresh设为当前窗口大小的一半，拥塞窗口大小也设为当前窗口大小的一半。 多进程服务器 情况： 已经accept一次后，全连接队列中还有剩余 while(1){accept;} 当进行一次accept后，可能无法进行数据传输。因为程序在下一次accept处阻塞（全连接队列为空） 多客户端=&gt;多次accept 阻塞&amp;非阻塞 管道、设备、套接字等可以修改阻塞属性 fcntl更改文件描述符的属性 123#include&lt;fcntl.h&gt;int fcntl(int fd, int cmd, ... /* arg */ ); 返回值 多路I/O复用用一个工具监听一堆io BIO：block io阻塞io 同步io NIO：同步io 操作系统中：nonblock io非阻塞io JAVA：new io AIO：异步io select监听io事件 也会造成阻塞（监听的事件都没有发生/timeout为空） 123#include&lt;sys/select.h&gt;int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); 返回值：触发的事件的和 int nfds：需要监听的最大的文件描述符+1，作为内核轮询的上限 fd_set *readfds：传入传出参数，位图，128个字节，1024位，需要监听读事件的位图 fd_set *writefds：传入传出参数，需要监听写事件的位图 fd_set *exceptfds：传入传出参数，需要监听异常事件的位图 struct timeval *timeout：传入传出参数，传出参数为剩余时间，超时时长，传空表示没有任何事件发生时会阻塞在select上，都设置成0就表示不阻塞 struct timeval &#123; long tv_sec; /*seconds*/ long tv_usec; /*microseconds*/ &#125;; 123456789101112131415161718 * lfd监听套接字* cfd用于通讯的套接字* 优缺点： * 优点：跨平台 * 缺点： * 受限于fd_set，最多只能同时监听1024个文件描述符 * 底层监听方式是轮询，效率低 * 用户到内核空间的大量数据拷贝（fd_set类型的参数） * fd_set传入传出参数，每次调用select都要重新赋值* 允许TIME_WAIT状态复用* ### 操作位图的函数 void FD_CLR(int fd, fd_set *set); int FD_ISSET(int fd, fd_set *set); void FD_SET(int fd, fd_set *set); void FD_ZERO(fd_set) *set; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384阻塞在lfd或cfd上### 例子&#96;&#96;&#96;c#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys&#x2F;socket.h&gt;#include&lt;arpa&#x2F;inet.h&gt;#include&lt;netinet&#x2F;in.h&gt;#include&lt;fcntl.h&gt;#include&lt;errno.h&gt;#include&lt;sys&#x2F;select.h&gt;#define SER_IP &quot;192.168.183.128&quot;#define SER_PORT 8000&#x2F;&#x2F;多进程服务器int main() &#123; char buf[1024]; &#x2F;&#x2F;创建一个套接字 int lfd &#x3D; socket(AF_INET, SOCK_STREAM, 0); &#x2F;&#x2F;为套接字绑定地址结构信息 struct sockaddr_in ser_addr, cli_addr; ser_addr.sin_family &#x3D; AF_INET; ser_addr.sin_port &#x3D; htons(SER_PORT); ser_addr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY); int bi &#x3D; bind(lfd, (struct sockaddr*)&amp;ser_addr, sizeof(ser_addr)); &#x2F;&#x2F;服务器开始监听 listen(lfd, 64); socklen_t len &#x3D; sizeof(cli_addr); &#x2F;&#x2F;select int maxfd &#x3D; lfd; fd_set rset, aset;&#x2F;&#x2F;aset用来记录所有监听的 FD_ZERO(&amp;aset);&#x2F;&#x2F;初始化写位图，所有位置为0 FD_SET(lfd, &amp;aset); struct timeval timeout; timeout.tv_sec &#x3D; 5; timeout.tv_usec &#x3D; 0; while(1) &#123; rset &#x3D; aset; int count &#x3D; select(maxfd + 1, &amp;rset, NULL, NULL, NULL); &#x2F;*if (count &#x3D;&#x3D; 0) &#123; printf(&quot;5秒内没有时间触发\\n&quot;); continue; &#125;*&#x2F; if (FD_ISSET(lfd, &amp;rset)) &#123; int cfd &#x3D; accept(lfd, (struct sockaddr*)&amp;cli_addr, &amp;len); fcntl(cfd, F_SETFL, O_NONBLOCK);&#x2F;&#x2F;将cfd更改为非阻塞 char dst[64]; int src &#x3D; cli_addr.sin_addr.s_addr; inet_ntop(AF_INET, (void*)&amp;src, dst, sizeof(dst)); printf(&quot;客户端连接成功：客户端IP &#x3D; %s, PORT &#x3D; %d\\n&quot;, dst, ntohs(cli_addr.sin_port)); FD_SET(cfd, &amp;aset); if (cfd &gt; maxfd) &#123; maxfd &#x3D; cfd; &#125; if (--count &#x3D;&#x3D; 0) &#123; continue; &#125; &#125; for (int i &#x3D; lfd + 1; i &lt; maxfd + 1; i++) &#123; if (FD_ISSET(i, &amp;rset)) &#123; int rr &#x3D; read(i, buf, 1024); if (rr &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;当客户端关闭时，会在文件描述符中打印一个结束标志，当read读到这个标志时会返回0，而结束标志一直读不出来一直触发select FD_CLR(i, &amp;aset); close(i); printf(&quot;客户端断开连接\\n&quot;); continue; &#125; write(STDOUT_FILENO, buf, rr); write(i, buf, rr); if (--count &#x3D;&#x3D; 0) &#123; break; &#125; &#125; &#125; &#125; return 0;&#125; ## poll 123#include&lt;pool.h&gt;int poll(struct pollfd *fds, nfds_t nfds, int timeout); 返回值：失败返回-1 struct pollfd *fds：指针加复数一定是数组 struct pollfd &#123; int fd;/* file descriptor */ short events;/* requested events */ short revents;/* returned events */ &#125;; 1234567891011121314151617181920212223 * int fd：打开的文件描述符，小于0时events被忽略，revents返回0 * short events：输入参数 * short revents：输出参数，触发的事件* nfds_t nfds：使用到的最后一个数组元素的下标+1* int timeout：单位是毫秒，-1表示阻塞，0表示非阻塞，&gt;0表示超时时长* 与select相比突破了1024的上限## epollman epoll_create&#96;&#96;&#96;c#include &lt;sys&#x2F;epoll.h&gt;int epoll_create(int size);int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);&#x2F;&#x2F;控制红黑树int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);&#x2F;&#x2F;类似select,poll int epoll_create(int size) 创建epoll实例（红黑树、双向链表位于内核区） 返回值：epfd int epoll_ctl 控制红黑树和双向链表 callback函数（通知）代替轮询 callback函数将事件拷贝到双向链表中 int epoll_wait 读取双向链表 将节点从双向链表中摘下存入events数组中 返回值：触发事件的数量 优点： 解决了每次用户区和内核区的大量数据交换","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"Linux系统编程","slug":"Linux系统编程","date":"2021-01-27T10:05:42.000Z","updated":"2021-03-06T02:20:30.516Z","comments":true,"path":"2021/01/27/Linux系统编程/","link":"","permalink":"http://example.com/2021/01/27/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/","excerpt":"","text":"Linux鸟哥私房菜 Unix环境高级编程 现代操作系统 Unix的网络编程 TCP/IP卷一16.04ltsctrl+alt+t打开终端ctrl+d关闭终端 gccC/C++编译器，将C/C++编译成可执行文件(a.out文件) 先将待编译文件编译成.o文件，最后在一起编译成可执行文件 好处：之后如果文件发生变化只需要将发生变化的文件重新编译成.o文件再一起编译成可执行文件即可，节约时间。 gcc编译过程 四步 预处理： 展开宏、头文件，替换条件编译，删除注释。（条件编译：ifdef endif等） 1gcc -E hello.c -o hello.i hello.c =&gt; hello.i hello.i仍是c文件 编译： 语法此法分析，检查语法规范。（解析字符串） 占用时间和系统资源最多（系统资源常至指内存和CPU） 1gcc -S hello.c -o hello.s -S做预处理以及编译 hello.c =&gt; hello.s hello.s为汇编语言文件 汇编： 将汇编指令翻译成机器语言 1gcc -c hello.c -o hello.o hello.c =&gt; hello.o hello.o为机器语言 链接： 符号决议（确保所有目标文件中的符号引用都有唯一的定义）等 没有主函数前三步都能做，这一步做不了。 12gcc hello.cgcc hello.c -o hello hello.c =&gt; hello\\a.out hello\\a.out为可执行文件 库定义：函数的集合。 目标文件（ELF） 可执行目标文件 可重定位目标文件 .o文件可重定位 1file filename 分析文件是什么文件 12gcc -c add.c -o add.ogcc main.c add.o 共享文件目标文件 .so 可以实现进程之间的资源共享 静态库&amp;动态库静态库libxxx.a：一些可重定位的目标文件，经过特殊的打包方式打包成独立文件，并且在链接生成可执行文件时，从这个单独的文件中”拷贝“它自己需要的内容到最终的可执行文件中。 1ar rcs libmymath.a add.o sub.o 创建libmymatch.a静态库文件 123456&#x2F;&#x2F;mymath.h#ifndef _MYMATH_H#define _MYMATH_Hint add(int a, int b); &#x2F;&#x2F;计算两数和int sub(int a, int b); &#x2F;&#x2F;计算两数差#endif 12&#x2F;&#x2F;main.c#include&quot;mymath.h&quot; 1234gcc -static main.c -o main -l mymath -L .&#x2F; -static静态编译-l指定库名字去掉lib前缀去掉.c后缀-L指定库路径 静态链接的链接过程 链接器从左往右依次编译，静态编译将用到的函数拷贝到可执行程序中，静态库编译后删除库可执行文件仍可运行。 故gcc -static main.c -o main -l mymath -L ./ 要把要编译的文件写在库前。 函数地址在编译时确定。 动态库libxxx.so 1234gcc -c add.c -o add.o -fPIC -fPIC生成与地址无关的代码gcc -c sub.c -o sub.o -fPICgcc -shared -o libmymath.so add.o sub.o 创建动态库文件gcc main.c -o main -l mymath -L .&#x2F; 动态链接的连接过程 无参数：gcc默认的链接方式就是动态链接。 gcc main.c -o main -l mymath -L ./ 拷贝符号表。 延迟绑定：函数地址在程序运行时确定。函数是程序运行加载的时候链接的。 动态链接器12345678export LD_LIBRARY_PATH&#x3D;&#x2F;home&#x2F;wwwhw&#x2F;文档&#x2F;class 添加临时的库文件路径，换一个终端就不好使了永久好使cd &#x2F;home&#x2F;wwwhwvim .&#x2F;bashrc 当前用户的配置文件在最后加上 export LD_LIBRARY_PATH&#x3D;&#x2F;home&#x2F;wwwhw&#x2F;文档&#x2F;class. .bashrc 第一种方法使配置文件生效source .bashrc 第二种方法使配置文件生效 动态库和动态库的区别※ 静态库 动态库 文件大小 静态库文件大 动态库文件小 从磁盘分析 静态库占用空间大 动态库占用空间小 扩展性和兼容性 静态库更新需要重新编译 动态库更新不用需要重新编译 依赖 静态链接的可执行文件不需要依赖其他内容即可运行 动态连接的可执行文件必须依赖动态库的存在 加载速度 静态库加载速度块 动态库加载速度慢 总结 耗费空间换取时间 耗费时间换取空间 makefile makefile：一种脚本语言，做工程项目管理，让你更方便的去编译你的项目文件 makefile依据文件夹进行工作 目标文件1 目标文件2:依赖条件1 依赖条件2 (Tab键)命令 例子： main.c编译生成可执行程序main（main.c为依赖条件，main为目标文件） 1234567main:main.c gcc main.c -o main#或main:main.c;gcc main.c -o main #但不建议这么写#运行时直接make 如果makefile名字不叫makefile ?? 例子： 12rm makefile mkmake 基本原理： 若想生成目标，必须检查规则中的依赖条件是否存在，如果不存在，则寻找是否有规则来生成该依赖文件。故生成依赖条件的规则需要写在下面。一般来讲，makefile有一个最终目标，他的第一行规则中的目标就作为最终目标。 12345678910main:main.o add.o sub.o mul.o gcc main.o add.o sub.o mul.o -o mainmain.o:main.c gcc -c main.c -o main.oadd.o:add.c gcc -c add.c -o add.osub.o:sub.c gcc -c sub.c -o sub.omul.o:mul.c gcc -c mul.c -o mul.o 可以使用ALL指定最终目标 1234567891011ALL:main #指定最终目标main.o:main.c gcc -c main.c -o main.oadd.o:add.c gcc -c add.c -o add.omain:main.o add.o sub.o mul.o gcc main.o add.o sub.o mul.o -o mainsub.o:sub.c gcc -c sub.c -o sub.omul.o:mul.c gcc -c mul.c -o mul.o 检查规则中的目标是否需要更新，必须先检查它的依赖条件，依赖条件中有任意一个被更新，则我们的规则必须更新。（通过判断依赖文件和最终文件的修改时间判断是否需要更新） add.c sub.c *.c表示add.c和sub.c %.c 依次表示add.c和sub.c 12345678910111213ALL:main #指定最终目标main.o:main.c gcc -c main.c -o main.oadd.o:add.c gcc -c add.c -o add.omain:main.o add.o sub.o mul.o gcc main.o add.o sub.o mul.o -o mainsub.o:sub.c gcc -c sub.c -o sub.omul.o:mul.c gcc -c mul.c -o mul.oclean: #伪目标 -rm -rf *.o main #-rm -rf循环递归强制删除，最前面的-现在加不加都行，以前的版本不行 make add.o #make 加最终目标 make clean 两个函数 src = $(wildcard *.c) obj = $(patsubst %.c,%.o,$(src)) 123456789101112131415ALL:main #指定最终目标WALL = -Wall #warning all显示所有警告信息 gcc a.c -Wallsrc = $(wildcard *.c) #当前文件夹下的*.c文件 main.c add.c sub.c mul.cobj = $(patsubst %.c,%.o,$(src)) #格式化的字符串替换，将src替换为 main.o add.o sub.o mul.omain:$(obj) gcc main.o add.o sub.o mul.o -o main $(WALL)main.o:main.c gcc -c main.c -o main.oadd.o:add.c gcc -c add.c -o add.osub.o:sub.c gcc -c sub.c -o sub.omul.o:mul.c gcc -c mul.c -o mul.o 三个变量 自动变量 $@ 在规则的命令中，表示规则的目标 1234main:$(obj) gcc main.o add.o sub.o mul.o -o $@ $(WALL)main.o:main.c gcc -c main.c -o $@ $^ 在规则的命令中，表示所有的依赖条件 1234main:$(obj) gcc $^ -o main $(WALL)main.o:main.c gcc -c $^ -o main.o $&lt; 在规则的命令中，表示规则的第一个依赖条件（如果用在模式规则中，它可将我们依赖条件列表中的依赖条件依次取出） 12main.o:main.c gcc -c $&lt; -o main.o 故真正使用时的makefile，模式规则。 1234567891011121314ALL:main #指定最终目标CC = gccsrc = $(wildcard *.c) #当前文件夹下的*.c文件 main.c add.c sub.c mul.cobj = $(patsubst %.c,%.o,$(src)) #格式化的字符串替换，将src替换为 main.o add.o sub.o mul.omain:$(obj) gcc $&lt; -o $@ $(WALL) %.o:%.c #去文件夹里自动匹配 $(CC) -c $&lt; -o $@ .PHONY:clean #声明伪目标,防止在文件夹内有与伪目标同名的文件时冲突clean: -rm -rf *.0 main make -n 模拟执行 文件io即为怎样处理文件 其中文件类型：- d目录 l软连接 c字符设备 b块设备 p管道文件 s套接字文件。前两个是真实存在的文件，后面四个是伪文件（不会占用磁盘空间） man page 所有函数 man man #1,2,3章有用 四个函数：open close read write 标准缓冲区 标准输入、输出、错误为设备文件 0 标准输入：存放输入数据 1 标准输出：实际printf是通过调用write函数向标准输出上写数据 2 标准错误：perror即通过调用write函数向标准错误上写数据 文件描述符 键值映射对 从0开始。 文件描述符的分配原则：操作系统会分配一个当前可用最小的文件描述符。 文件描述符：一些小值整数，通过他们访问打开的文件或设备。一个进程开始运行会有三个文件描述符： 1）0: 标准输入 STDIN_FILENO 2）1: 标准输出 STDOUT_FILENO 3）2: 标准错误 STDERR_FILENO 文件描述符的变化范围是：0~OPEN_MAX-1 (可通过ulmit -a 查看) 文件的访问 怎样唯一标识一个文件： 路径名 将文件映射成一个整数=&gt;文件描述符。 inode：元信息存储在inode节点中。每个inode都有一个号码，操作系统用inode号码来识别不同的文件。ls -i查看inode号。 文件：文件的属性 + 文件的内容 （文件的属性称为元数据/元信息。即文件的所有者，所在组，权限，大小等。） 1ls -i #查看inode号 目录文件：inode + 名字 （inode + 名字为一个目录项） 磁盘只支持覆盖不支持删除。删除操作实际上删除inode。 系统调用由操作系统实现并提供给外部应用程序的编程接口。(Application Programming Interface， API)。是应用程序同系统之间数据交互的桥梁。 eg：printf()通过调用write函数实现，write通过调用sys_write函数（内核区内核源码）实现，sys_write将数据写在显卡的缓冲区，再由驱动程序将缓冲区的数据显示在显示屏上。 open函数打开或创建文件，将文件映射成一个文件描述符，在之后对这个文件的操作都改为对文件描述符的操作。文件描述符是进程的属性。进程就是运行起来的程序。 12#include&lt;fcntl.h&gt;int open(const char *pathname, int flags); pathname指准备打开的文件或设备的路径名；flags用于指定打开文件所采取的动作；mode用于指定创建文件的权限，O_CREATE 才使用；flags 参数通过必需文件访问模式与其他可选模式相结合的方式来指定。 三个参数的open才可以创建文件。O_CREAT,O_EXCL保证创建的原子性,O_APPEND,O_TRUNC。成功返回文件描述符，失败返回-1。 O_RDONLY 以只读方式打开O_WRONLY 以只写方式打开O_RDWR 以读写方式打开可选模式组合：1） O_APPEND: 把写入数据追加在文件的末尾。2） O_TRUNC: 打开文件时把文件长度设置为零，丢弃已有的内容。3） O_CREAT: 如果需要，就按参数mode 中给出的访问模式创建文件。4） O_EXCL: 与O_CREAT一起使用，确保创建文件的原子操作。如果文件存在，创建将失败创建文件时，指定文件访问权限。权限同时受 umask 影响。 read函数从文件描述符中读取count个字节，并存入buf。 12#include&lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t count); 返回值：成功返回读取的字节数，失败返回-1并设置errno EAGAIN：文件描述符被设置了O_NONBLOCK非阻塞 EWOULDBLOCK：如果文件描述符被设置为非阻塞，当返回-1时 返回值为-1并且errno为EAGAIN或EWORLDBLOCK时表示当前套接字被设置成了非阻塞并且当前文件描述符中没有数据 一般参数为fd，100%是文件描述符。buf为缓冲区，count读取数据的数量，size_t为无符号int。 成功返回读到的字节数可能会小于count但不算错误（可供读取的字节数本身就比count小，read被信号打断，管道被破坏（如果fd是管道）），读到EOF时结束，0表示未读入任何数据，已到达了文件尾部。 -1表示出错，错误代号存放在全局变量errno里。 write函数12#include &lt;unistd.h&gt;ssize_t write(int fd, const void *buf, size_t count); 将buf中前count个字符写入文件中。 成功返回写入的字节数，可能小于count，0表示未写入任何数据，失败返回-1，错误代号存放在全局变量errno里。 close函数12#include&lt;unistd.h&gt;int close(int fd); 终止文件描述符fd 和对应文件(文件或设备)的关联。文件描述符被释放并能够被其他文件重新使用。close调用成功返回0，出错返回-1，并把errno设置成一个合适的值。 errno系统自动生成的全局变量，用来存放错问信息。 errno是一个整数，有宏。 程序必须在函数报告出错之后立刻检查errno变量，因为它可能马上就被下一个函数调用所覆盖，即使下一个函数没有出错，也可能会覆盖这个变量。 常用错误代码的取值和含义如下：l EPERM: 操作不允许l ENOENT: 文件或目录不存在。l EINTR: 系统调用被中断。l EAGAIN: 重试，下次有可能成功！l EBADF: 文件描述符失效或本身无效l EIO: I/O错误。l EBUSY: 设备或资源忙。l EEXIST: 文件存在。l EINVL: 无效参数。l EMFILE: 打开的文件过多。l ENODEV: 设备不存在。l EISDIR: 是一个目录。l ENOTDIR: 不是一个目录。 strerror函数把错误代号映射成一个字符串，该字符串对发生的错误类型进行说明。 12#include&lt;string.h&gt;char *strerror(int errnum); perror函数perror 函数也把errno 变量中报告的当前错误映射成一个字符串，并把它输出到标准错误输出流。只能应用于open等这类自动设置errno的函数。 12#include&lt;stdio.h&gt;void perror(const char *s); 例子12345678int main() &#123; int fd = open(&quot;./a.t&quot;, O_RDWT); if (fd == -1) &#123; printf(&quot;open error:%s\\n&quot;, strerror(errno)); printf(&quot;***********************************************&quot;) perror(&quot;open error&quot;); &#125;&#125; stat函数stat：返回的是该链接指向的文件的信息。 fstat：f为file。 lstat：s为，返回的时符号链接本身的信息。 st_mode 标志有一系列相关的宏,定义见 sys/stat.h 中，可用来测试文件类型，如：获取文件状态信息。 123456789#include&lt;sys/stat.h&gt;#include&lt;unistd.h&gt;int main() &#123; struct stat sb; stat(&quot;./main.c&quot;, &amp;sb); printf(&quot;main.c len = %lu\\n&quot;, sb.st_size); //%lu长整型 return 0;&#125; 一行是1024个字节。 printf有行缓冲，如果行不满就会等待，除非遇到\\n。 运行中的程序称为进程，每个进程都有与之关联的文件描述符。 dup和dup2函数复制文件描述符，达到通过两个或者更多不同的描述符来访问同一个文件的目的，主要用于多个进程间进行管道通信。 1234#include&lt;unistd.h&gt;int dup(int oldfd);int dup2(int oldfd, int newfd); 当调用dup函数时，内核在进程中创建一个新的文件描述符，此描述符是当前可用文件描述符的最小数值，这个文件描述符指向oldfd所拥有的文件表项。dup2和dup的区别就是可以用newfd参数指定新描述符的数值，如果newfd已经打开，则先将其关闭。如果newfd等于oldfd，则dup2返回newfd, 而不关闭它。dup2函数返回的新文件描述符同样与参数oldfd共享同一文件表项。 子进程的文件描述符与父进程无关，0，1，2也是。 dup例子 123456789101112#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;fcntl.h&gt;int main() &#123; open(&quot;a.t&quot;, O_RDWR)； printf(&quot;fd = %d\\n&quot;, fd); write(fd, &quot;hello world\\n&quot;, 12); int newfd = dup(fd); printf(&quot;fd = %d\\n&quot;, newfd); write(newfd, &quot;laskjdfla&quot;, 9); return 0;&#125; dup2例子 1234567891011#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;fcntl.h&gt;int main() &#123; open(&quot;a.t&quot;, O_RDWR)； printf(&quot;fd = %d\\n&quot;, fd); write(fd, &quot;hello world\\n&quot;, 12); dup2(fd, 1); printf(&quot;**********************\\n&quot;); return 0;&#125; lseek函数lseek 对文件描述符fd的读写指针(文件偏移位)进行设置。即设置文件的下一个读写位置。可根据绝对位置和相对位置(当前位置或文件尾部)进行设置。 1234#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence); offset为偏移量 whence是参照物： SEEK_SET：offset 是一个绝对位置(从文件的头位置开始计算)。 SEEK_CUR：offset 是一个相对位置(从文件的当前位置开始计算)。 SEEK_END：offset 是一个绝对位置(从文件的末尾开始计算)。 lseek成功返回从文件头到文件指针被设置处的字节偏移值，失败时返回-1. lseek可以用于拓展文件大小（使用SEEK_END）（但必须引起io操作） 通过dup2将文件描述符1与其他文件连接时，printf不会改变文件偏移位 例子 123456789101112#include&lt;stdio.h&gt;#include&lt;fcntl.h&gt;int main() &#123; char buf[1024]; int fd = open(&quot;a.t&quot;, O_RDWR); write(fd, &quot;hello world&quot;, 11); int rr = read(fd, buf, 5); printf(&quot;buf = %s&quot;, buf); printf(&quot;rr = %d&quot;, rr); return 0;&#125; 因为文件偏移位的问题，这样写完，输出的结果并不是想要的。 123456789101112131415#include&lt;stdio.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;int main() &#123; char buf[1024]; int fd = open(&quot;a.t&quot;, O_RDWR); write(fd, &quot;hello world&quot;, 11); //lseek(fd, 0, SEEK_SET); //文件偏移位设置为第一个字节 //lseek(fd, 3, SEEK_CUR); //当前位置向后偏移三个字节 int rr = read(fd, buf, 5); printf(&quot;buf = %s&quot;, buf); printf(&quot;rr = %d&quot;, rr); return 0;&#125; 123456789101112#include&lt;stdio.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;int main() &#123; char buf[1024]; int fd = open(&quot;a.t&quot;, O_RDWR); write(fd, &quot;hello world&quot;, 11); lseek(fd, 5, SEEK_END); write(fd, &quot;12345&quot;, 5); return 0;&#125; 预读入缓输出如果一个只读一个字节实现文件拷贝，使用read、write 效率高，还是使用对应的标库函数(fgetc、fputc)效率高呢？strace 命令shell 中使用 strace 命令跟踪程序执行，查看调用的系统函数。 主函数参数argc是命令行参数的数量（argv中有效的元素个数，只能是整型），argv是具体的参数（只能是字符串数组）。 12int main(int argc, char* argv[]);int main(int argc, char** argv); 123456789#include&lt;stdio.h&gt;int main(int argc, char* argv[]) &#123; printf(&quot;argc = %d\\n&quot;, argc); printf(&quot;argv[0] = %s\\n&quot;, argv[0]); printf(&quot;argv[1] = %s\\n&quot;, argv[1]); printf(&quot;argv[2] = %s\\n&quot;, argv[2]); return 0;&#125; ./main aaa bbb ccc 结果是 1234argc &#x3D; 4argv[0] &#x3D; .&#x2F;mainargv[1] &#x3D; aaaargv[2] &#x3D; bbb 作用 例如：cp a.t b.t就是通过主函数传参实现的 例子 自己写复制函数 123456789101112131415#include&lt;stdio.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;int main(int argc, char* argv[]) &#123; int fd = open(argv[1], O_RDONLY); int fd1 = open(argv[2], O_RDWR | O_CREAT | O_TRUNC, 0644); int rr = 1; char buf[1024]; while (rr) &#123; rr = read(fd, buf, 1024); write(fd1, buf, 1024); &#125; return 0;&#125; 虚拟内存程序和用到的相关数据必须要物理内存（RAM）里时cpu才能运行程序。（相关数据：指令和数据） 进程 一段程序的执行过程。程序是死的，跑起来才算进程。 进程是线程的容器，是程序的实体。 每个进程都有自己的地址空间 文本区域：存储处理器执行的代码 数据区域：存储变量和进程执行期间使用的动态分配的内存 堆栈区域：存储着活动过程调用的指令和本地变量 并发 对cpu的分时复用。宏观并行，围观串行。 不是真正意义上的同时进行，给每个进程分配时间片，时间片用完了就去运行别的进程，再重新分配时间片。 单道程序设计所有进程一个一个排队执行，一个阻塞了另一个只能等待。 多道程序设计同时存放多道相互独立的程序，相互穿插的运行。必须有硬件基础作为保证。 时钟中断：达到某些条件，强制让出进程占有的CPU资源。 进程控制块 PCB位于内核区 Linux内核的进程控制块是task_struct结构体，主要掌握以下部分： 进程ID：系统中每个进程有唯一的ID，在C语言中用pid_t类型表示，其实就是个非负整数。 进程的状态：就绪，运行，挂起等状态。 描述虚拟地址空间的信息。 文件描述符表。 进程切换时需要保存和恢复的一些CPU寄存器（用来存放运行中需要的数据），防止时间片结束数据丢失。 进程状态 运行态：进程占有cpu正在运行 就绪态：进程具备运行条件，等待系统分配cpu以便运行 阻塞/等待态：指进程不具备运行条件，正在等待某个事件的完成 多进程fork函数1234#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t fork(void); 创建进程：由父进程创建 1234567891011121314151617181920#include&lt;unistd.h&gt;int a = 100;int main() &#123; int pid = fork(); if (pid == 0) &#123; printf(&quot;i&#x27;m child\\n&quot;); printf(&quot;-a = %d\\n&quot;,a); a = 50; printf(&quot;--a = %d\\n&quot;,a); sleep(1); while(1) &#123; printf(&quot;------\\n&quot;); &#125; &#125; else &#123; printf(&quot;i&#x27;m parent\\n&quot;); printf(&quot;++a = %d\\n&quot;,a); sleep(20); &#125;&#125; 子进程独立于父进程，都可以被系统调用，父进程先被调用的可能性更大。 子进程与父进程只有pid不同。 子进程中变量等与父进程中的是独立的但是值相同，指针地址相同但是只是在自己的虚拟内存内的指针地址相同实际上也是独立的。并且读时共享，写时复制（创建子进程时不会立即复制父进程的数据段和堆栈段，只有当子进程修改这些数据内容是才发生复制操作）。 fork函数前的代码不会执行，但是变量有。 返回值： 创建子进程，id不同,创建成功父进程中返回子进程pid 子进程中返回0 创建失败父进程返回-1 123456789101112131415#include&lt;unistd.h&gt;int a = 100;int main() &#123; int pid = fork(); if (pid == 0) &#123; printf(&quot;i&#x27;m child\\n&quot;); printf(&quot;-a = %d\\n&quot;,a); exit(0); //结束子进程exit(1)会留存进程结束时的信息。 &#125; else &#123; printf(&quot;i&#x27;m parent\\n&quot;); printf(&quot;++a = %d\\n&quot;,a); sleep(20); &#125;&#125; 12345678910#include&lt;unistd.h&gt;int a = 100;int main() &#123; int pid = fork(); if (pid == 0) &#123; exit(48); &#125;&#125; 运行完在终端输入 echo $?会输出48 exit函数123#include&lt;unistd.h&gt;void exit(int status); 结束进程 status表示进程的退出状态 保存在全局变量$?中，可以通过echo $?查看 $?保存的是最近一次运行的进程的返回值 main函数运行结束，$?中保存main函数的返回值 程序运行中调用exit函数结束运行，$?中保存exit函数的参数 程序异常退出$?中保异常出错的错误号。 getpid、getppid函数getpid获得本进程id getppid获得父进程id 123456789101112#include&lt;unistd.h&gt;int a = 100;int main() &#123; int pid = fork(); if (pid == 0) &#123; printf(&quot;i&#x27;m child pid = %d ppid = %d\\n&quot;, getpid(), getppid()); &#125; else &#123; printf(&quot;i&#x27;m parent\\n pid = %d ppid = %d\\n&quot;, getpid(), getppid()); &#125; return 0;&#125; 循环创建多个子进程1234567891011#include&lt;unistd.h&gt;int a = 100;int main() &#123; int n = 3; int i; for (i = 0; i &lt; n; i++) &#123; fork(); &#125; printf(&quot;-------\\n&quot;); return 0;&#125; 出现了(2^3)八个进程。其中七个子进程。 需要加判断条件，不然子进程运行fork 123456789101112#include&lt;unistd.h&gt;int a = 100;int main() &#123; int n = 3; int i; for (i = 0; i &lt; n; i++) &#123; pid = fork(); if (pid == 0) break; &#125; printf(&quot;----%d---\\n&quot;, i); return 0;&#125; exec函数1234567891011121314#include &lt;unistd.h&gt; extern char **environ; int execl(const char *pathname, const char *arg, ... /* (char *) NULL */); int execlp(const char *file, const char *arg, ... /* (char *) NULL */); int execle(const char *pathname, const char *arg, ... /*, (char *) NULL, char *const envp[] */); int execv(const char *pathname, char *const argv[]); int execvp(const char *file, char *const argv[]); int execvpe(const char *file, char *const argv[], char *const envp[]); 参数中char* arg为可执行程序的第一个参数argv[0] 参数中char* NULL为哨兵，表示输入参数结束。 可执行程序必须是主函数。 echo $PATH 输出环境变量，显示系统的可执行程序存放的路径 execl执行自己定义的可执行程序 execlp调用环境便令执行系统指令 只有执行出错时才有返回值-1。 123456789101112131415161718#include&lt;unistd.h&gt;int a = 100;int main() &#123; pid = fork(); if (pid == 0) &#123; execl(&quot;./main&quot;, &quot;main&quot;, NULL); //&quot;main&quot;为可执行程序的第一个参数argv[0] printf(&quot;asjdlfjasdlflasdjkl\\n&quot;); &#125; printf(&quot;-------\\n&quot;); return 0;&#125; //main.c#include&lt;stdio.h&gt;int main(int argc, char* argv[]) &#123; printf(&quot;我是exec调用的&quot;); printf(&quot;argv[0] = %s&quot;, argv[0]);&#125; ps -aux | grep zoom 打印有zoom符号的所有进程的信息 ps -aux 打印所有进程信息 名字带[]是已经死了的进程（僵尸进程） 僵尸进程-exit,exit,return 能够使进程正常死亡 kill 进程id 杀死进程 僵尸进程已经死了，杀不掉 孤儿进程父进程死了，子进程还活着，子进程就是孤儿进程。 1号进程是所有的孤儿进程的父进程。 ps -aux看不到孤儿进程 123456789101112131415161718#include&lt;unistd.h&gt;int a &#x3D; 100;int main() &#123; int pid &#x3D; fork(); if (pid &#x3D;&#x3D; 0) &#123; printf(&quot;i&#39;m child pid &#x3D; %d, ppid &#x3D; %d\\n&quot;, getpid(), getppid()); sleep(10); printf(&quot;i&#39;m child pid &#x3D; %d, ppid &#x3D; %d\\n&quot;, getpid(), getppid()); while(1); return 0; &#125; else &#123; printf(&quot;i&#39;m parent\\n pid &#x3D; %d\\n&quot;, getpid()); sleep(5); printf(&quot;parent die\\n&quot;); &#125; return 0;&#125; ctrl+alt+F1 进程回收进程终止时会关闭所有文件描述符，释放在用户空间分配的内存，但PCB还保留着，内核在其中保存了一些信息:如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。Shell是它的父进程，故一个进程的退出状态可以在She11 中用特殊变量$?查看，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。 wait函数1234#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;pid_t wait(int *status); 传出参数 pid_t是pid类型 成功返回回收的子进程的pid，失败返回-1 wait会阻塞等待子进程死亡 一次wait只能回收一个子进程 status记录了进程死亡信息，status传空就表示不需要死亡信息 进程是不是正常死亡，如果正常死亡获取进程的返回值 如果是异常死亡获取是哪一个信号杀死了进程（在linux系统中进程异常死亡都是被信号杀死的） WIFEXITED(status)如果子进程正常死亡（exit或return）返回真值，否则返回 WEXITSTATUS(status)同上，并获取进程退出状态（exit参数） WIFSIGNALED(status)如果子进程被信号杀死（非正常死亡）返回true WTERMSIG(status)同上，并返回终止进程的信号的编号 WIFSTOPPED(status)当进程处于暂停状态时返回true WSTOPSIG(status)同上，并返回时进程暂停的信号的编号 WIFCONTINUED(status)如果WIFSTOPPED(status)为真，则返回true表示暂停后已经继续运行 waitpid函数1234#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;pid_t waitpid(pid_t pid, int *status, int options); ps -ajx pid_t pid &lt; -1 回收进程组id为abs(pid)中的任意一个子进程 -1回收任意一个子进程 == wait 0回收和父进程在同一进程组下的任意一个子进程（默认父进程创建的子进程与父进程同属于一个进程组，pgid是进程组id） &gt; 0回收指定pid进程 option WNOHANG 当没有进程死亡时不会等待，并返回0 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#int main() &#123; int pid[3]; for (int i = 0; i &lt; 3; i++) &#123; pid[i] = fork(); if (pid[i] == 0) &#123; printf(&quot;i&#x27;m %dth child, pid = %d, ppid = %d\\n&quot;, i, getpid(), getppid()); if (i == 0) &#123; sleep(5); &#125; printf(&quot;i&#x27;m %dth child, pid = %d, ppid = %d is to die\\n&quot;, i, getpid(), getppid()); return 0; &#125; &#125; printf(&quot;i&#x27;m&quot;); int status; while (1) &#123; int wr = waitpid(pid[0], &amp;status, WNOHANG); //option换成0试试 if (wr == -1) &#123; perror(&quot;wait error\\n&quot;); return 0; &#125; else if (wr != 0) &#123; printf(&quot;wr = %d\\n&quot;, wr); return 0; &#125; else &#123; printf(&quot;父进程先干别的事\\n&quot;); sleep(1); //模仿处理任务 &#125; &#125;&#125; 进程间通信父进程和子进程可能需要交换数据 可以通过文件、管道（匿名管道、命名管道）、信号、共享内存、套接字、消息队列等进行通信 管道 管道是内核中的一块缓冲区 一端为读端，一端为写端 要保证数据的单一流动性 先进先出 int pipe(int pipefd[2]) pipefd装的是两个文件描述符，pipefd[0]为读端，pipefd[1]为写端 匿名通道 只能用于有血缘关系的进程中通信，父进程创建pipe 1234567891011#include&lt;unistd.h&gt;int main() &#123; char buf[1024]; int pipefd[2]; int pr = pipe(pipefd); int wr = write(pipefd[1], &quot;hello world\\n&quot;, 12); int rr = read(fipefd[0], buf, wr); write(1, buf, rr); return 0;&#125; 12345678910111213141516#include&lt;unistd.h&gt;int main() &#123; char buf[1024]; int pipefd[2]; int pr = pipe(pipefd); int pid = fork(); if (pid == 0) &#123; write(pipefd[1], &quot;hello world\\n&quot;, 12); &#125; if (pid &gt; 0) &#123; read(fipefd[0], buf, wr); write(1, buf, rr); &#125; return 0;&#125; 1234567891011121314151617#include&lt;unistd.h&gt;int main() &#123; char buf[1024]; int pipefd[2]; int pr = pipe(pipefd); int pid = fork(); if (pid == 0) &#123; sleep(5); write(pipefd[1], &quot;hello world\\n&quot;, 12); &#125; if (pid &gt; 0) &#123; read(fipefd[0], buf, wr); write(1, buf, rr); &#125; return 0;&#125; 管道的读写 读管道： 管道中有数据：read返回读到的字节数 管道中没有数据： 没有进程持有管道的写端：read返回0 （子进程和父进程都close掉pipefd[1]） 有进程持有管道的端：read阻塞等待 写管道： 管道有读端： 管道已满：阻塞等待 管道未满：write返回写入字节数 管道没有读端：进程会异常终止（被13号信号SIGPIPE杀死） 管道不用的端口在一开始就必须关闭。 wc -l统计文件内容信息 回去”0“都结果 去标准输入”0”读数据 eg：wc -l 读取 ls -l的输出 1ls -l | wc -l 思考 写一个函数实现用wc -l 读取 ls -l的输出 mmapPAGE_SIZE：一页4096个字节即4kb malloc申请大空间时就使用了mmap 将一个文件或设备映射到内存中 1234#include&lt;sys/mman.h&gt;void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);int munmap(void *addr, size_t length); mmap返回值成功为映射空间（缓冲区）的首地址，失败返回 源文件大小必须不为0 void *addr：传入传出参数，可以不传入，用于指定映射空间（缓冲区）的首地址，一般传空 size_t length：映射空间（缓冲区）的长度，如果映射的是文件也表示文件的字节数。 int prot：常用的两个宏： PROT_READ映射出来的空间（缓冲区）可读 PROT_WRITE映射出来的空间（缓冲区）可写 int flags：MAP_开头的宏都是，常用的三个： MAP_SHARED，MAP_PRIVATE必须有一个 MAP_SHARED，MAP_PRIVATE进程之间是否共享内存缓冲区（用于进程间通讯） MAP_ANON用于创建 off_t offset：偏移位，大小必须是PAGE_SIZE的整数倍，即不允许从一页中间开始映射。 munmap的addr必须是mmap的返回值或者是mmap的addr，不能更改。 例子 12345678910111213141516171819202122232425262728#include&lt;fcntl.h&gt;#include&lt;sys/mman.h&gt;#include&lt;unistd.h&gt;int main() &#123; int fd = open(&quot;mmap.txt&quot;, O_RDWR | O_CREAT, 0644); if (fd &lt; 0) &#123; perror(&quot;open error:&quot;); exit(1); &#125; //lseek(fd, 500, SEEK_END); //write(fd, &quot;\\0&quot;, 1); ftruncate(fd, 1000); void* ptr = mmap(NULL, 200, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); //创建时会读文件故必须有O_RDONLY if (ptr == MAP_FAILED) &#123; perror(&quot;mmap error:&quot;); exit(1); &#125; int i = 0; while (1) &#123; sprintf(ptr, &quot;-----%d-----&quot;, i++); printf(&quot;ptr = %s\\n&quot;, ptr); sleep(1); &#125; munmap(ptr, 200); close(fd);//映射完后立刻关闭也可以，没有影响 return 0;&#125; 12345678910111213141516171819202122232425#include&lt;fcntl.h&gt;#include&lt;sys/mman.h&gt;#include&lt;unistd.h&gt;int main() &#123; int fd = open(&quot;mmap.txt&quot;, O_RDONLY); if (fd &lt; 0) &#123; perror(&quot;open error:&quot;); exit(1); &#125; void* ptr = mmap(NULL, 200, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0); //MAP_PRIVATE不会将数据同步到磁盘上，与文件打开权限无关，故可以用O_RDONLY if (ptr == MAP_FAILED) &#123; perror(&quot;mmap error:&quot;); exit(1); &#125; int i = 0; while (1) &#123; sprintf(ptr, &quot;-----%d-----&quot;, i++); printf(&quot;ptr = %s\\n&quot;, ptr); sleep(1); &#125; munmap(ptr, 200); close(fd); return 0;&#125; 进程间通信 mmap进程间通信效率最高，但很复杂。 1. 12345678910111213141516171819202122232425#include&lt;fcntl.h&gt;#include&lt;sys/mman.h&gt;#include&lt;unistd.h&gt;int main() &#123; int fd = open(&quot;mmap.txt&quot;, O_RDWR); void* ptr = mmap(NULL, 200, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if (ptr == MAP_FAILED) &#123; perror(&quot;mmap error:&quot;); exit(1); &#125; int pid = fork(); if (pid == 0) &#123; int i = 1000; sprintf(ptr, &quot;+++++%d+++++&quot;, i); printf(&quot;ptr = %s\\n&quot;, ptr); &#125; else &#123; sleep(1);//等待子进程写 printf(&quot;%s\\n&quot;, ptr); &#125; munmap(ptr, 200); close(fd); return 0;&#125; 2. 1234567891011121314151617181920212223242526//mmapw.c#include&lt;fcntl.h&gt;#include&lt;sys/mman.h&gt;#include&lt;unistd.h&gt;int main() &#123; int fd = open(&quot;mmap.txt&quot;, O_RDWR); if (fd &lt; 0) &#123; perror(&quot;open error:&quot;); exit(1); &#125; void* ptr = mmap(NULL, 200, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if (ptr == MAP_FAILED) &#123; perror(&quot;mmap error:&quot;); exit(1); &#125; while (1) &#123; int i = 1000; sprintf(ptr, &quot;-----%d-----&quot;, i--); printf(&quot;ptr = %s\\n&quot;, ptr); sleep(1); &#125; munmap(ptr, 200); close(fd); return 0;&#125; 123456789101112131415161718192021222324//mmapr.c#include&lt;fcntl.h&gt;#include&lt;sys/mman.h&gt;#include&lt;unistd.h&gt;int main() &#123; int fd = open(&quot;mmap.txt&quot;, O_RDWR); if (fd &lt; 0) &#123; perror(&quot;open error:&quot;); exit(1); &#125; void* ptr = mmap(NULL, 200, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if (ptr == MAP_FAILED) &#123; perror(&quot;mmap error:&quot;); exit(1); &#125; while (1) &#123; printf(&quot;ptr = %s\\n&quot;, ptr); sleep(1); &#125; munmap(ptr, 200); close(fd); return 0;&#125; 3.匿名映射 1234567891011121314151617181920212223#include&lt;fcntl.h&gt;#include&lt;sys/mman.h&gt;#include&lt;unistd.h&gt;int main() &#123; void* ptr = mmap(NULL, 200, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0);//匿名映射不用文件，只能用于有血缘关系的通信，匿名通讯必须是MAP_SHARED。 if (ptr == MAP_FAILED) &#123; perror(&quot;mmap error:&quot;); exit(1); &#125; int pid = fork(); if (pid == 0) &#123; int i = 1000; sprintf(ptr, &quot;+++++%d+++++&quot;, i); printf(&quot;ptr = %s\\n&quot;, ptr); &#125; else &#123; sleep(1);//等待子进程写 printf(&quot;%s\\n&quot;, ptr); &#125; munmap(ptr, 200); return 0;&#125; 12345678910111213141516171819202122232425//使用设备文件zero创建匿名文件#include&lt;fcntl.h&gt;#include&lt;sys/mman.h&gt;#include&lt;unistd.h&gt;int main() &#123; int fd = open(&quot;/dev/zero&quot;, O_RDWR); void* ptr = mmap(NULL, 200, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, fd, 0); if (ptr == MAP_FAILED) &#123; perror(&quot;mmap error:&quot;); exit(1); &#125; int pid = fork(); if (pid == 0) &#123; int i = 1000; sprintf(ptr, &quot;+++++%d+++++&quot;, i); printf(&quot;ptr = %s\\n&quot;, ptr); &#125; else &#123; sleep(1); printf(&quot;%s\\n&quot;, ptr); &#125; munmap(ptr, 200); return 0;&#125; ftruncate放文件I/O吧12345#include&lt;unistd.h&gt;#include&lt;sys&#x2F;types.h&gt;int ftruncate(int fd, off_t length); 线程 进程与线程区别： 进程：拥有独立地址空间，拥有PCB，实现了操作系统内的并发 线程：拥有PCB，没有独立地址空间（多个线程共享一个进程的地址空间，数据是同步的），实现了进程内的并发 Linux下： 线程：最小的执行单位 进程：最小分配资源单位可看成是只有一个线程的进程。 内核只能识别PCB，无法区分所谓进程和线程 lwp号： 注意：lwp号不是线程号 假设一个进程分为两个线程，原来的线程的lwp号保持原来的pid #ps -aux #ps -Lf PCB本质上就是结构体节点 线程共享资源 文件描述符表 每种信号的处理方式 当前工作目录 用户ID和组ID 内存地址空间（.text/，.data/，.bss/，heap/，共享库）※ text段存放代码 data端静态存储区存放已初始化的全局变量、静态变量和常量 bss段存放未初始化的全局变量 线程非共享资源 线程id 处理器现场和栈指针(内核栈) 存放cpu切换进程或线程时未处理完的数据等 独立的栈空间(用户空间栈) errno变量 信号屏蔽字 调度优先级 线程优、缺点 优点： 提高程序并发性 开销小 数据通信、共享数据方便 缺点： 库函数,不稳定（线程相关函数全是库函数） 调试、编写困难、不支持gdb 对信号支持不好 优点相对突出，缺点均不是硬伤。Linux 下由于实现方法导致进程、线程差别不是很大。 线程控制原语pthread_create创建线程 123#include &lt;pthread.h&gt;int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); 返回值：成功返回0，不成功返回errno pthread_t *thread：传出参数，在Linux系统中为unsigned long类型，创建的线程的线程id（非lwp） const pthread_attr_t *attr：传入参数，结构体，线程的属性，一般情况默认即可 void* (*start_routine) (void *)：，函数指针 void *arg：用作第三个参数的形参 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;pthread.h&gt; void *fun (void* arg)&#123; while(1) &#123; printf(&quot;this is fun thread\\n&quot;); sleep(1); &#125;&#125;int main() &#123; pthread_t thread; int pc = pthread_create(&amp;thread, NULL, fun, NULL); //传入函数指针，好处是：函数并不是被直接调用，而是在需要是才被调用。结构体里不能创建函数，所以只能使用函数指针 if (pc &lt; 0) &#123; printf(&quot;pthread_cread error:%s\\n&quot;, strerror(pc)); exit(1); &#125; while(1) &#123; printf(&quot;main thread\\n&quot;); sleep(1); &#125; return 0;&#125; 多进程的程序编译时要在最后要加-lpthread指定库名（使用-l指定pthread库） 父线程和子线程不一定谁先运行 pthread_self 获取调用该函数的线程ID 123#include &lt;pthread.h&gt;pthread_t pthread_self(void); 这个函数不会失败，返回值为调用该函数的线程ID 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;pthread.h&gt; void *fun (void* arg)&#123; printf(&quot;son thread id = %lu\\n&quot;, pthread_self()); return NULL;&#125;int main() &#123; printf(&quot;main thread id = %lu\\n&quot;, pthread_self());//%lu是无符号长整型 pthread_t thread; //创建线程 int pc = pthread_create(&amp;thread, NULL, fun, NULL); pc = pthread_create(&amp;thread, NULL, fun, NULL); sleep(1); return 0;&#125; 线程ID在同一进程下一定不相同 线程ID只用于进程内部区分线程 pthread_exit结束调用它的线程 123#include &lt;pthread.h&gt;void pthread_exit(void *retval); 返回值： void *retval： 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;pthread.h&gt; void *fun (void* arg)&#123; printf(&quot;son thread id = %lu\\n&quot;, pthread_self()); pthread_exit(NULL); printf(&quot;子线程还线程\\n&quot;); return NULL;&#125;int main() &#123; printf(&quot;main thread id = %lu\\n&quot;, pthread_self()); pthread_t thread; //创建线程 int pc = pthread_create(&amp;thread, NULL, fun, NULL); sleep(1); printf(&quot;父线程还活着\\n&quot;); return 0;//return出现在主函数中相当于exit(0)即结束一个进程&#125; return返回给函数的调用者 return在主线程中等于exit(0)，即结束调用它的进程。 多个线程位于一个进程中，任何一个线程运行了exit()都将结束整个进程=&gt;所有线程也都被结束。 在子线程中用return和pthread_exit功能一样都能结束线程 pthread_join回收一个已死亡的线程 123#include &lt;pthread.h&gt;int pthread_join(pthread_t thread, void **retval); 返回值：成功返回0，错误返回errno void **retval：传出参数，用于记录线程的返回值，线程的返回值为void *类型，故这个参数为**类型 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;typedef struct&#123; int a; int b;&#125;join_t;void *fun (void* arg)&#123; printf(&quot;son thread\\n&quot;); join_t *ret = (join_t*)malloc(sizeof(join_t)); ret-&gt;a = 10; ret-&gt;b = 50; sleep(5); //pthread_join会等待子线程死亡后回收，不死就阻塞 pthread_exit((void*)ret);&#125;int main() &#123; printf(&quot;main thread id = %lu\\n&quot;, pthread_self()); pthread_t thread; //创建线程 int pc = pthread_create(&amp;thread, NULL, fun, NULL); if (pc &lt; 0) &#123; printf(&quot;pthread_create error:%s\\n&quot;, strerror(pc)); &#125; join_t *retval; pthread_join(thread, (void **)&amp;retval); printf(&quot;ret.a = %d, ret.b = %d\\n&quot;, retval-&gt;a, retval-&gt;b); pthread_exit(NULL);&#125; pthread_join会等待子线程死亡后回收，不死就阻塞 线程分离pthread_detach 自动进行线程回收。 线程分离后，线程不允许手动回收。 123#include &lt;pthread.h&gt;int pthread_detach(pthread_t thread); 返回值：成功返回0，失败返回errno 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;typedef struct&#123; int a; int b;&#125;join_t;void *fun (void* arg)&#123; printf(&quot;son thread\\n&quot;); join_t *ret = (join_t*)malloc(sizeof(join_t)); ret-&gt;a = 10; ret-&gt;b = 50; sleep(5); //pthread_join会等待子线程死亡后回收，不死就阻塞 pthread_exit((void*)ret);&#125;int main() &#123; printf(&quot;main thread id = %lu\\n&quot;, pthread_self()); pthread_t thread; //创建线程 int pc = pthread_create(&amp;thread, NULL, fun, NULL); if (pc &lt; 0) &#123; printf(&quot;pthread_create error:%s\\n&quot;, strerror(pc)); exit(1); &#125; pthread_detach(thread); join_t *retval; int ret = pthread_join(thread, (void **)&amp;retval); if (ret &gt; 0) &#123; printf(&quot;pthread_join error:%s\\n&quot;, strerror(ret)); &#125; else &#123; printf(&quot;ret.a = %d, ret.b = %d\\n&quot;, retval-&gt;a, retval-&gt;b); &#125; pthread_exit(NULL);&#125; pthread_cancel杀死线程（非正常死亡） 123#include &lt;pthread.h&gt;int pthread_cancel(pthread_t thread); 返回值： 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void *fun (void* arg)&#123; printf(&quot;son thread id = %d\\n&quot;, pthread_self()); while(1) &#123; pthread_testcancel(); &#125; return (void*)10;//正常死亡返回10&#125;int main() &#123; pthread_t thread; //创建线程 int pc = pthread_create(&amp;thread, NULL, fun, NULL); sleep(5); pthread_cancel(thread); int a; int ret = pthread_join(thread, &amp;a); if (ret &gt; 0) &#123; printf(&quot;回收失败\\n&quot;); &#125; else &#123; printf(&quot;回收成功\\n&quot;); if (a == PTHREAD_CANCELED) &#123; printf(&quot;线程被异常终止\\n&quot;); &#125; printf(&quot;a = %d\\n&quot;, a);//如果返回值不是10就是非正常死亡 &#125; pthread_exit(NULL);&#125; 线程必须进内核（使用系统调用）才能被杀死 如果未进行系统调用需要加取消点pthread_testcancel() PTHREAD_CANCELED：宏定义 -1，用于标志线程被pthread_cancel杀死 线程共享全局变量同一进程下的线程可以共享全局变量 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;int a = 10;void *fun (void * arg) &#123; printf(&quot;son a = %d\\n&quot;, a); sleep(2); printf(&quot;更改之后\\n&quot;); printf(&quot;son a = %d\\n&quot;, a); return NULL;&#125;int main() &#123; pthread_t thread; int pc = pthread_create(&amp;thread, NULL, fun, NULL); printf(&quot;main thread a = %d\\n&quot;, a); sleep(1); a = 20; printf(&quot;main thread a = %d\\n&quot;, a); pthread_exit(NULL); return 0;&#125; 数据访问冲突两个线程同时访问同一块数据共享的数据区 例子：父子线程中全局变量a++,a++操作是将a从内存中取出，将a+1存入寄存器中，再将a = a + 1。当将a+1写入寄存器后，正要将a = a+1，线程时间片用完，切换到另一个线程，但a还是之前未+1的值。 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;int a = 0;void *fun (void * arg) &#123; for (int i = 0; i &lt; 100000; i++) &#123; a++; &#125; return NULL;&#125;int main() &#123; pthread_t thread; pthread_create(&amp;thread, NULL, fun, NULL); for (int i = 0; i &lt; 100000; i++) &#123; a++; &#125; pthread_join(thread, NULL); printf(&quot;a = %d\\n&quot;, a); pthread_exit(NULL); return 0;&#125; 线程同步※互斥锁/互斥量 建议锁 保证共享区域的数据同一时刻只允许一个线程访问 每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。 锁越简单越好 资源还是共享的，线程间也还是竞争的，通过锁将资源的访问编程互斥操作。 pthread_mutex_init1234#include &lt;pthread.h&gt;int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr);pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; 返回值 pthread_mutex_t *restrict mutex：锁的地址 const pthread_mutexattr_t *restrict attr：带attr的一般都是属性，一般写NULL pthread_mutex_destroy1234#include &lt;pthread.h&gt;int pthread_mutex_destroy(pthread_mutex_t *mutex);pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; pthread_mutex_lock123#include &lt;pthread.h&gt;int pthread_mutex_lock(pthread_mutex_t *mutex); pthread_mutex_trylock尝试加锁，加锁不成功立刻返回错误号（EBUSY），不会造成阻塞 123#include &lt;pthread.h&gt;int pthread_mutex_trylock(pthread_mutex_t *mutex); pthread_mutex_unlock123#include &lt;pthread.h&gt;int pthread_mutex_unlock(pthread_mutex_t *mutex); 例子1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;//使用互斥锁同步pthread_mutex_t mutex;//创建锁，全局变量int a = 0;void *fun (void * arg) &#123; for (int i = 0; i &lt; 100000; i++) &#123; //访问数据前先加锁 pthread_mutex_lock(&amp;mutex); a++; pthread_mutex_unlock(&amp;mutex); //访问数据后解锁 &#125; return NULL;&#125;int main() &#123; pthread_mutex_init(&amp;mutex, NULL); pthread_t thread; pthread_create(&amp;thread, NULL, fun, NULL); for (int i = 0; i &lt; 100000; i++) &#123; pthread_mutex_lock(&amp;mutex); a++; pthread_mutex_unlock(&amp;mutex); &#125; pthread_join(thread, NULL); printf(&quot;a = %d\\n&quot;, a); pthread_mutex_destroy(&amp;mutex); pthread_exit(NULL); return 0;&#125; 读写锁 读共享，写独占 写锁优先级高于读锁 写模式加锁时，解锁前所有对该锁枷锁的线程都会被阻塞 读模式加锁时，如果线程以读模式对其加锁会成功，如果线程以写模式加锁会阻塞 适用于数据结构读的次数远大于写的次数 情景： 1wr：wr 1w 2r 3w：wwr 1r 2w 3r：rrw和rwr都行，都有道理，Linux系统中是rrw 函数： pthread_rwlock_wrlock pthread_rwlock_rdlock pthread_rwlock_init pthread_rwlock_destroy pthread_rwlock_unlock 例子12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;pthread.h&gt;pthread_rwlock_t rwlock;//写线程void *th_write(void *arg) &#123; pthread_rwlock_wrlock(&amp;rwlock); printf(&quot;开始写\\n&quot;); printf(&quot;-------写\\n&quot;); printf(&quot;写完\\n&quot;); pthread_rwlock_unlock(&amp;rwlock);&#125;//读线程void *th_read(void *arg) &#123; pthread_rwlock_rdlock(&amp;rwlock); printf(&quot;开始读\\n&quot;); sleep(5); printf(&quot;读完\\n&quot;); pthread_rwlock_unlock(&amp;rwlock); return NULL;&#125;int main() &#123; pthread_t thread; pthread_rwlock_init(&amp;rwlock, NULL); pthread_create(&amp;thread, NULL, th_read, NULL); pthread_create(&amp;thread, NULL, th_write, NULL); pthread_create(&amp;thread, NULL, th_read, NULL); pthread_rwlock_destroy(&amp;rwlock); while(1); return 0;&#125; 死锁 死锁不是一个种锁，是在使用锁的期间可能产生的一种现象 线程试图对同一个互斥量A加锁两次 线程1拥有A锁，请求获得B锁，线程2拥有B锁，请求获得A锁 无解 条件变量本身不是锁，但可以造成线程阻塞，通常配合互斥锁使用给多线程提供一个会合的场所 pthread_cond_init初始化一个条件变量 123#include &lt;pthread.h&gt;int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); 返回值： pthread_cond_t *cond：要初始化的条件变量 pthread_condattr *cond_attr：条件变量属性,通常为默认值,传NULL即可 pthread_cond_destroy销毁一个条件变量 1int pthread_cond_destroy(pthread_cond_t *cond); pthread_cond_wait1.2必须一起做 阻塞等待一个条件变量 阻塞等待条件变量cond (参1)满足 释放已掌握的互斥锁(解锁互斥量)相当于pthread mutex_ unl ock (&amp;mutex) ; 1.2两步为一个原子操作（原子操作：不可分割）。 当被唤醒, pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁 pthread_mutex_lock (&amp;mutex) ; 123#include &lt;pthread.h&gt;int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); pthread_cond_timewait阻塞一段时间后自动解除阻塞 绝对时间：时间戳起点1970.1.1 0:00 123#include &lt;pthread.h&gt;int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime); 1234struct timespec &#123; time_v tv_sec;//秒 long tv_nsec;//纳秒&#125; pthread_cond_signal唤醒一个阻塞在条件变量上的线程 123#include &lt;pthread.h&gt;int pthread_cond_signal(pthread_cond_t *cond); pthread_cond_broadcast唤醒所有阻塞在条件变量上的线程 123#include &lt;pthread.h&gt;int pthread_cond_broadcast(pthread_cond_t *cond); 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;pthread_mutex_t mutex;pthread_cond_t cond;struct Food &#123; int num; struct Food* next;&#125;;struct Food *head = NULL;void *fun(void * l) &#123; printf(&quot;fun thread wake\\n&quot;); pthread_mutex_lock(&amp;mutex); //如果数据不够，阻塞等待 if(head == NULL) &#123; printf(&quot;条件不满足，阻塞等待\\n&quot;); pthread_cond_wait(&amp;cond, &amp;mutex); &#125; //条件满足，解除阻塞 printf(&quot;条件满足\\n&quot;); struct Food* node = head; head = head-&gt;next; printf(&quot;node-&gt;num = %d\\n&quot;, node-&gt;num); free(node); pthread_mutex_unlock(&amp;mutex); return NULL;&#125;int main() &#123; pthread_mutex_init(&amp;mutex, NULL); pthread_cond_init(&amp;cond, NULL); pthread_t thread; pthread_create(&amp;thread, NULL, fun, NULL); sleep(5); struct Food* node = (struct Food*)malloc(sizeof(struct Food)); node-&gt;num = 125; //操作全局变量必须加锁 pthread_mutex_lock(&amp;mutex); node-&gt;next = NULL; head = node; pthread_mutex_unlock(&amp;mutex); //数据准备好了，唤醒阻塞的线程 pthread_cond_signal(&amp;cond); sleep(1); pthread_mutex_destroy(&amp;mutex); pthread_cond_destroy(&amp;cond); return 0;&#125; 生产者消费者模型多线程需要进行数据交流 生产者：产生数据 消费者：处理数据 例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;pthread.h&gt;pthread_mutex_t mutex;pthread_cond_t cond;struct Food &#123; int num; struct Food* next;&#125;;struct Food *head = NULL;void *producter(void *arg) &#123; int i = 0; while(1) &#123; struct Food *node = (struct Food*)malloc(sizeof(struct Food)); node-&gt;num = i++; node-&gt;next = head; pthread_mutex_lock(&amp;mutex); head = node; pthread_mutex_unlock(&amp;mutex); printf(&quot;生产者生产\\n&quot;); usleep(rand()%10*10000);//usleep微秒 pthread_cond_signal(&amp;cond); &#125; return NULL;&#125;void *consumer(void *arg) &#123; while(1)&#123; pthread_mutex_lock(&amp;mutex); while(head == NULL) &#123;//释放锁后需要再次判断头节点是否为空 pthread_cond_wait(&amp;cond, &amp;mutex);//阻塞并释放锁，被唤醒后解除阻塞并重新加锁 //多个线程可能会在wait中阻塞在加锁处 &#125; struct Food *node = head; head = head-&gt;next; pthread_mutex_unlock(&amp;mutex); printf(&quot;消费者消费%d\\n&quot;, node-&gt;num); free(node); usleep(rand()%10*10000);//usleep微秒 &#125; return NULL;&#125;int main() &#123; pthread_mutex_init(&amp;mutex, NULL); pthread_cond_init(&amp;cond, NULL); pthread_t pro_tid; pthread_t con_tid; pthread_create(&amp;pro_tid, NULL, producter, NULL); pthread_create(&amp;con_tid, NULL, consumer, NULL); pthread_create(&amp;con_tid, NULL, consumer, NULL); pthread_create(&amp;con_tid, NULL, consumer, NULL); pthread_create(&amp;con_tid, NULL, consumer, NULL); pthread_join(pro_tid, NULL); pthread_join(con_tid, NULL); pthread_mutex_destroy(&amp;mutex); pthread_cond_destroy(&amp;cond); pthread_exit(1);&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"算法笔记","slug":"算法笔记","date":"2021-01-21T12:55:20.000Z","updated":"2021-02-23T01:24:09.060Z","comments":true,"path":"2021/01/21/算法笔记/","link":"","permalink":"http://example.com/2021/01/21/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","excerpt":"","text":"TOPKTOPK即数组中最大的k个数或，数组中最小的k个数。 1.用堆排序的思想解决取最小的k个数 对数组前k个元素进行堆调整。 将第k + 1个元素与堆顶元素比较，若nums[k + 1] &lt; nums[0]则互换并堆调整。 依次向后比较。 最后堆中剩下的就是最小的k个数。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;int&gt; smallestK(vector&lt;int&gt;&amp; arr, int k) &#123; vector&lt;int&gt; res; if (k == 0) &#123; return res; &#125; //先对前k个元素进行堆排 for (int i = (k / 2) - 1; i &gt;= 0; i--) &#123; heapAdjust(arr, i, k); &#125; //当k后的数组元素小于堆顶元素时，互换，堆调整 for (int i = k; i &lt; arr.size(); i++) &#123; if (arr[i] &lt; arr[0]) &#123; swap(arr[i], arr[0]); heapAdjust(arr, 0, k); &#125; &#125; for (int i = 0; i &lt; k; i++) &#123; res.push_back(arr[i]); &#125; return res; &#125; //堆调整 void heapAdjust(vector&lt;int&gt;&amp; vec, int start, int maxindex) &#123; int ch = 2 * start + 1; while (ch &lt; maxindex) &#123; if (ch + 1 &lt; maxindex &amp;&amp; vec[ch] &lt; vec[ch + 1]) &#123; ch++; &#125; if (vec[ch] &gt; vec[start]) &#123; swap(vec[ch], vec[start]); start = ch; ch = 2 * start + 1; &#125; else &#123; break; &#125; &#125; &#125;&#125;; 使用优先级队列实现堆调整 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; smallestK(vector&lt;int&gt;&amp; arr, int k) &#123; vector&lt;int&gt; res; if (k == 0) &#123; return res; &#125; priority_queue&lt;int&gt; que; for (int i = 0; i &lt; k; i++) &#123; que.push(arr[i]); &#125; for (int i = k; i &lt; arr.size(); i++) &#123; if (arr[i] &lt; que.top()) &#123; que.pop(); que.push(arr[i]); &#125; &#125; while (!que.empty()) &#123; res.push_back(que.top()); que.pop(); &#125; return res; &#125;&#125;; 2.快排思想 先尽量找到中间值，对数组进行一趟快排。 一趟快排过后，黄色中间区域为==哨兵值的元素，i左侧为小于哨兵的区域即为最小的i-l个数。 若i - L== k，则直接返回前k个数。 若i - L &lt; k,则再对黄色及黄色右边进行快排。 若i - L &gt; k,则在对黄色左边区域进行快排。 贪心算法每一步都找到当前最优解。 快慢指针应用 找链表中间节点：使用快慢指针遍历，快慢指针同时出发，慢指针每次走一步，快指针每次走两步。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。 判断链表是否有环：使用快慢指针遍历，快慢指针同时出发，慢指针每次走一步，快指针每次走两步。如果链表中有环的话，两指针必定会相遇。 异或在一个范围内，有唯一一个不重复的数或一个不存在的数，使用异或。 例题三个数，范围13-16，没有重复的数，找出没有出现的数。 将这三个数异或到一起，再将得到的数从13到16挨个异或一遍，最后得到的就是没出现的数。 大数据类型问题位图&amp;哈希分流例题第一题20亿数据，找出出现次数top100的数据，已知内存2G，外存无限 第一步： 将数据分成10份，一份一份处理，得到每一份数据的top10。 用哈希分流的思想，将数据分成10份=&gt;fun(数据) % 10。 解决了相同的数据分到同一个文件里面，并且每个文件的数据量一样 第二步： 堆排序，排value，得到每份文件的top10 第三步： 将每个文件的top10汇总，就得到了总体的top10 特殊情况：假如有19亿数据被哈希分流到一个文件内： 哈希分流时进行计数，当超过一定数量时，将超量的文件再分成n份进行存储。 第二题有10亿个数据，范围是0-10亿，这些数据中没有重复的数据，请找到0-10亿范围内，没有出现的那个数。 法一：数据每个拿出来进行异或运算，把异或的结果，再和0-10亿挨个异或，得到最终的结果就是哪个没出现的数 法二：位图 int==32位，10 ^ 9 / 32 约等于 3 * 10^7 int 也就是new 3*10^7 int这么大的空间，初始化为0 遍历一下10亿个数据，出现过的数据，就在相应位置标1。 第二步遍历完成后，遍历new出的数组，为0的位置就是没出现过的数。 第三题32位无符号整数的范围是0~4, 294, 967,295，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然存在没出现过的数。可以使用最多1GB的内存，怎么找到所有未出现过的数? 1G位图最多能存储80亿个数据：故可以用位图解决 int 32个数 1G = 2.5亿个int = 2.5*32 = 80亿 600M内存= 42亿 第四题32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多1GB的内存，找出所有出现了两次的数。 解法一：用两位表示一个数（位图）。 解法二：分奇偶文件 先处理奇数文件：第一位的00统计1出现的次数，第二位的00统计3出现的次数，第三位的00统计5出现的次数…… 解法三：将前20亿和后20亿存为两个文件 布隆过滤器 目的：有个大的样本集，要做一个集合，这个集合可以做查重操作。 注意：有失误率，可能将白名单判断成黑名单，但是黑名单不可能判断成白名单 eg：100亿URL 的黑名单，爬虫不重复爬已经爬过的网站 正解：将每个数据通过K个哈希函数，得到K个值，将每个值取模M,得到一个0到M-1的值，在相应的位置描黑,对100亿个操作都进行进行以上处理 断一个URL是不是名单的做法是： 将这个URL也用这K个哈希函数求值，取模M, 只要有一个点不是黑的， 就说明不是黑名单。 分段统计例题可以使用最多10MB的内存，怎么找到这40亿个整数（范围0-100万）的中位数 解法： ​ 10MB == 250万int 第一步：找到最大值和最小值0-100万 最多能分250万组(200万组)，200万组太多，分成1000组0-100 (统计这个区间的数据个数)100-2000 200-30000 外部排序例如要对外存中4500个记录进行归并，而内存大小只能容纳750个记录，在第一阶段，我们可以每次读取750个记录进行排序，这样可以分六次读取，进行排序，可以得到六个有序的归并段。 每个归并段的大小是750个记录，记住，这些归并段已经全部写到临时缓冲区(由个可用的磁盘充当)内了,这是第一步的排序结果。 接下来开始归并算法将内存空间划分为三份，每份大小25个记录,其中两个用作输入缓冲区，另外一个用作输出缓冲区。首先对Segment_ .1和Segment_ 2进行归并，先从每个归并段中读取250个记录到输入缓冲区，对其归并,归并结果放到输出缓冲区，当输出缓冲区满后，将其写道临时缓冲区内，如果某个输入缓冲区空了，则从相应的归并段中再读取250个记录进行继续归并，反复以上步骤，直至Segment_ 1和Segment 2全都排好序，形成-一个大小为1500的记录，然后对Segment 3和Segment 4、Segment _5和Segment 6进行同样的操作。对归并好的大小为1500的记录进行如同步骤1-样的操作，进行继续排序，直至最后形成大小为4500的归并段，至此，排序结束。如下图:","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Linux笔记","slug":"Linux笔记","date":"2021-01-21T11:55:42.000Z","updated":"2021-02-18T03:02:40.302Z","comments":true,"path":"2021/01/21/Linux笔记/","link":"","permalink":"http://example.com/2021/01/21/Linux%E7%AC%94%E8%AE%B0/","excerpt":"","text":"终端文件类型bin文件夹存储二进制文件（可执行文件）devroot超级用户的家目录tmp存放临时文件，会被定期清理etc存放配置文件home除了root用户以外的目录的家目录在这里白色 没法执行的普通文件蓝色 目录浅蓝色 链接文件红色 压缩文件黄色 设备文件绿色 可执行文件 基础指令指令主体 选项 操作对象 1234567891011121314ls 显示当前目录下所有文件ls -l 以详细信息显示 ls -a 显示所有文件，包括隐藏文件&#x2F;文件夹ls -la 上面俩个加起来ls -l &#x2F;home 显示根目录下home里的文件ls -l &#x2F;home .&#x2F; 显示当前文件夹下和根目录下home里的文件ls -lh 能清晰地看到文件大小第一个位置为- 普通文件类型； d 文件夹类型；c 字符设备文件b 块设备文件；l 软连接（像快捷方式）；p 管道文件；s 套接字总用量是占的块数1文件类型 234属主 567属组 8910 11文件个数&#x2F;目录下的文件个数 12该文件属主 13该文件属组 14默认情况下文件占多大 15文件最后的修改时间 16文件名 1history历史指令 1pwd 打印当前工作路径 1234567cd 改变当前目录相对路径：从当前文件夹开始描述绝对路径：从根目录开始描述.. 父级路径，上级目录.&#x2F; 当前目录&#x2F;代表根目录~代表当前用户的家目录 1234mkdir tt 在当前路径下创建一个叫tt文件夹mkdir &#x2F;home&#x2F;wwwhw&#x2F;tt&#x2F;abc 在指定路径下创建一个叫abc的文件夹mkdir -p .&#x2F;linux&#x2F;text 创建多级不存在的文件夹mkdir t1 t2 t3 创建多个文件夹 123touch a.c 创建a.c文件touch a.c b.c c.c 创建多个文件touch ..&#x2F;test.word 在指定目录创建一个文件 123cp .&#x2F;a.c .&#x2F;abc 将当前路径下的a.c 复制到当前文件夹的abc文件夹里cp .&#x2F;a.c .&#x2F;abc&#x2F;1.c 将当前路径下的a.c 复制到当前文件夹的abc文件夹里并重命名为1.ccp -r test tt循环递归的赋值当前文件夹，将test文件夹复制到tt文件夹里 123mv .&#x2F;test.word .&#x2F;abc 将test.word移动到当前文件夹下abc文件夹中mv tt test移动文件夹不需要加-rmv test.word new.word 将test.word重命名为new.word 123456rm new.word 删除new.wordrm -r .&#x2F;test&#x2F;tt 循环递归地删除test文件夹中的tt文件夹touch a.c b.c c.crm *.c 删除文件名以.c为结尾的文件touch a1 a2 a3rm a* 删除文件名以a为开头的文件 12ls .&#x2F; &gt; tmp.c 将输出重定向到tmp.c文件里，tmp.c不存在自动创建,覆盖tmp.c内的内容ls &#x2F; &gt;&gt; tmp.c 将输出重定向到tmp.c文件里，tmp.c不存在自动创建，在tmp.c内的内容后追加 12cat tmp.c 将文件打印在终端cat a.c tmp.c &gt; b.c 将a.c，tmp.c的内容打印到终端并重定向到b.c中 1df 查看磁盘空间 1234free -m 查看内存使用情况mem内存使用情况swap交换空间使用情况总的 已使用的 剩余的 被分享使用的 缓冲区&#x2F;高速缓冲区 被应用程序使用的内存大小 12head 查看文档的前几行，默认前10行head -2 a.c 查看a.c前2行 123tail 查看文档的最后后几行，默认tail -3 a.c 查看a.c最后三行tail -f a.c 动态显示a.c内容（多开一个终端改a.c内容试试） ctrl+c 或ctrl+z停止 123less .&#x2F; less tmp.c 查看文件中内容 自己试吧q推出 1234wc -l (lines) .&#x2F;tmp 查看文件里有多少行wc -w (word) .&#x2F;tmp 查看文件里有多少单词wc -c (char) .&#x2F;tmp 查看文件里有多少字节wc -lwc .&#x2F;tmp 查看文件里有多少行，单词，字节 顺序为lwc不变 1234date 输出时间date +%F 年月日date +&quot;%F %T&quot; 年月日 （注意这里的空格）时分秒date -d &quot;-2 day&quot; &quot;+%F&quot; 两天前的日期 123456cal 输出当前月份日历cal -1 输出当前月份日历cal -3 输出当前月上一个月，当前月，当前月下一个月 只能写-1 -3cal -y 输出当前年的日历cal 11 2021 输出2021年11月日历cal 20 输出20年日历 12clear傻瓜式清屏ctrl+l也是清屏 123ls .&#x2F; | 将输出结果作为管道的输入结果ls .&#x2F; | grep c 将输出结果作为管道的输入结果并筛选出带c的很多命令都能加 | VIM配置vim/etc/vim/vimrc 1234vim 文件名 用vim打开文件，如果文件不存在就新建一个这个文件vim +4 文件名 打开后光标处在第几行vim +&#x2F;a 文件名 打开文件a字符高亮vim打开多个文件 自己试 1.命令模式 在命令模式下进入编辑模式 i 在光标所在字符前插入 在命令模式下进入末行模式 2.编辑模式 esc推出编辑模式进出命令模式 命令模式下:进入末行模式 3.末行模式 退出 :q不保存退出 :wq保存退出 :q!强制退出不保存 ^ 光标移到行首 $ 光标移到行末 gg 光标移到首行 G 光标移到末行 ctrl b 向上翻页 ctrl f 向下翻页 yy 复制光标所在行 p 粘贴 2 yy 复制当前光标所在行开始2行 ctrl v 加方向键可视块 dd 删除光标所在行 2 dd 删除2行 D u 撤销 ctrl r 恢复 1234567## 软链接&#x2F;硬链接### 软链接* 相当于windows的快捷方式 ln -s /home/wwwhw/a.c ./桌面/a.cc 在桌面上生成一个a.c的软链接（快捷方式）名字叫a.cc 不写名字默认原名字 源文件必须写绝对路径 ln -s /home/wwwhw/text ./桌面 在桌面上生成一个text文件夹的软链接（快捷方式） 123456### 硬链接* 复制且同步更新的一个文件* 不能给文件夹生成硬链接 ln -d /home/wwwhw/a.c ./桌面 在桌面上生成一个a.c的硬链接 123## 压缩&#x2F;解压 tar -zxvf test.tar.gz 解压test.tar.gz tar -zcvf test.tar.gz ./test 将当前文件夹下的test文件压缩，名字叫test.tar.gz 重名的话直接覆盖 tar -zcvf ./桌面/test2.tar.gz ./test 将当前文件夹下的test文件压缩，放在指定路径 c创建文件 v显示过程 gzip、rar 需要安装 rar a aaa a2.c 将a2.c压缩成aaa.rar rar x aaa.rar 将aaa.rar解压 unrar x 解压 123## apt sudo apt install rar 安装 sudo apt remove rar 卸载 sudo apt-get update 123 cmatrix 代码雨 sl 小火车 sl -F sl -small cowsay &quot;hello&quot; cowsay -l 可选动物 cowsay -f hellokitty &quot;hello&quot; oneko 养猫 123456789## group## shadow## password没有密码的用户是无法登录的 sudo adduser test 添加名叫test的用户，没指定组时新生成一个同名组 sudo adduser -gid 6754 -uid 1212 lisi 添加一个叫lisi的用户id为1212，属于6754组，-gid gid为所属组（groupid） sudo usermod -u 1521 lisi 修改lisi的uid为1521sudo usermod -g 1001 lisi 修改lisi的gid为1521sudo usermod -l li lisi 将lisi名改为li sudo deluser –remove-home lisi 删除用户lisi和/home下的lisi文件夹sudo deluser lisi 删除用户lisi但不删除文件夹su 用户名 切换用户su 不加用户名切换到root用户 sudo password root 设置root用户密码 whoami 查看当前用户是谁 addgroup -gid 2345 class01 添加class01组，gid为2345 sudo groupmod -g 2346 class01 将class01组gid修改为2346sudo groupmod -n class class01 将class01组名修改为calss ls -l /home/wwwhw 查看wwwhw文件夹下所有文件详细信息 sudo chown test /home/wwwhw/a.c 将指定文件夹下的a.c所属主修改为testsudo chgrp class /home/wwwhw/a.c 将指定文件夹下的a.c所属组改为classsudo chown lisi:class ./a2.c 将指定文件夹下的a.c所属主和所属组修改为lisi和class 1234567891011121314151617添加用户是根目录会自动生成同名文件夹，在password中 用户名，密码占位符，uid，gid，描述，用户进入系统后默认位置## 权限管理ls显示的的：属主（owner） 属组（group） 其他用户（others） x表示execute（执行）&#96;&#96;&#96;shellchmod u+x a2.c #+增加chmod u-x,g-w,o-r a2.c #-去除chmod u&#x3D;rwx,g&#x3D;rw,o&#x3D;r a2.c #&#x3D;相当于覆盖#r:4 w:2 x:1 -:0chmod 764 a2.c","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"LeetCode刷题记录：27.移除元素","slug":"LeetCode刷题记录：27.移除元素","date":"2021-01-20T10:53:35.000Z","updated":"2021-01-20T10:56:21.546Z","comments":true,"path":"2021/01/20/LeetCode刷题记录：27.移除元素/","link":"","permalink":"http://example.com/2021/01/20/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/","excerpt":"","text":"法一 i,j分别从数组两端开始扫描， i扫描到值等于val元素时停下， j扫描到值等于val元素时length--,扫描到值不等于val的元素时停下 nums[i],nums[i]互换，length--。 1234567891011121314151617181920212223242526272829class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int length = nums.size(); if (length == 0) &#123; return 0; &#125; int i = 0, j = length - 1; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; nums[i] != val) &#123; i++; &#125; while (i &lt; j &amp;&amp; nums[j] == val) &#123; j--; length--; &#125; if (i &lt; j) &#123; swap(nums[i], nums[j]); i++; j--; length--; &#125; &#125; if (i == j &amp;&amp; nums[i] == val) &#123; length--; &#125; return length; &#125;&#125;; 法二 双指针，快慢指针 i，j同时先后扫描当nums[j] != val时将nums[j]赋值给nums[i]并且i++, j++。 当j扫描到数组尾部结束 1234567891011121314151617class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int length = nums.size(); if (length == 0) &#123; return 0; &#125; int i = 0, j = 0; while (j &lt; length) &#123; if (nums[j] != val) &#123; nums[i++] = nums[j]; &#125; j++; &#125; return i; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"双指针","slug":"LeetCode/双指针","permalink":"http://example.com/categories/LeetCode/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"LeetCode刷题记录：925.长按键入","slug":"LeetCode刷题记录：925.长按键入","date":"2021-01-20T09:10:35.000Z","updated":"2021-01-20T09:16:37.427Z","comments":true,"path":"2021/01/20/LeetCode刷题记录：925.长按键入/","link":"","permalink":"http://example.com/2021/01/20/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A925.%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5/","excerpt":"","text":"思路： 先判断两个字符串首字母是否相同，不同直接返回false i指向name第二个字符，j指向typed第二个字符先后扫描 i，j所指字符相同时i++,j++ i，j所指字符不同时，看j所指字符是不是长按造成的重复，即typed[j] == typed[j - 1] i，j所指字符不同时，且j所指字符不是长按造成的重复返回false 若j先扫描完，则typed内必不含name 若i先扫完，j向后扫描，若扫描到非长按造成的重复字符时返回false12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool isLongPressedName(string name, string typed) &#123; if(name[0] != typed[0])&#123; return false; &#125; int i = 1,j = 1; while (i &lt; name.size() &amp;&amp; j &lt; typed.size()) &#123; if (name[i] == typed[j]) &#123; i++; j++; &#125; else if (name[i] != typed[j] &amp;&amp; typed[j] == typed[j - 1]) &#123; j++; &#125; else &#123; return false; &#125; &#125; if(j == typed.size() &amp;&amp; i &lt; name.size())&#123; return false; &#125; while(j &lt; typed.size())&#123; if(typed[j] != typed[j - 1])&#123; return false; &#125; j++; &#125; return true; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"双指针","slug":"LeetCode/双指针","permalink":"http://example.com/categories/LeetCode/%E5%8F%8C%E6%8C%87%E9%92%88/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"LeetCode刷题记录：844. 比较含退格的字符串","slug":"LeetCode刷题记录：844.比较含推个的字符串","date":"2021-01-19T15:39:35.000Z","updated":"2021-01-19T15:43:07.909Z","comments":true,"path":"2021/01/19/LeetCode刷题记录：844.比较含推个的字符串/","link":"","permalink":"http://example.com/2021/01/19/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A844.%E6%AF%94%E8%BE%83%E5%90%AB%E6%8E%A8%E4%B8%AA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"法一：双指针 双指针，两个指针分别再两个字符串的最后一位 用skip记录该跳过几个字符 每当遇到#时skip++，遇到字符且skip不为0时跳过并且skip– 比较两个指针所指字符是否相同 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: bool backspaceCompare(string S, string T) &#123; int i = S.length() - 1, j = T.length() - 1; int skipS = 0, skipT = 0; while (i &gt;= 0 || j &gt;= 0) &#123; while (i &gt;= 0) &#123; if (S[i] == &#x27;#&#x27;) &#123; skipS++, i--; &#125; else if (skipS &gt; 0) &#123; skipS--, i--; &#125; else &#123; break; &#125; &#125; while (j &gt;= 0) &#123; if (T[j] == &#x27;#&#x27;) &#123; skipT++, j--; &#125; else if (skipT &gt; 0) &#123; skipT--, j--; &#125; else &#123; break; &#125; &#125; if (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; if (S[i] != T[j]) &#123; return false; &#125; &#125; else &#123; if (i &gt;= 0 || j &gt;= 0) &#123; return false; &#125; &#125; i--, j--; &#125; return true; &#125;&#125;; 法二：栈","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：26. 删除排序数组中的重复项","slug":"LeetCode刷题记录：26.删除排序数组中的重复项","date":"2021-01-19T12:07:35.000Z","updated":"2021-01-19T15:38:50.128Z","comments":true,"path":"2021/01/19/LeetCode刷题记录：26.删除排序数组中的重复项/","link":"","permalink":"http://example.com/2021/01/19/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A26.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","excerpt":"","text":"两个指针i,j一开始都为1，j向后扫描当nums[j - 1] != nums[j]时给i赋值i++ 12345678910111213141516class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() == 0) &#123; return 0; &#125; int i = 1, j = 1; while (j &lt; nums.size()) &#123; if (nums[j - 1] != nums[j]) &#123; nums[i++] = nums[j]; &#125; j++; &#125; return i; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：1260.二维网格迁移","slug":"LeetCode刷题记录：1260.二维网格迁移","date":"2021-01-19T11:45:35.000Z","updated":"2021-01-19T11:47:43.251Z","comments":true,"path":"2021/01/19/LeetCode刷题记录：1260.二维网格迁移/","link":"","permalink":"http://example.com/2021/01/19/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A1260.%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E8%BF%81%E7%A7%BB/","excerpt":"","text":"创建一个新的二维数组 第i行第j列元素应移到第((k + j) / n + i) % m第(k + j) % n列 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; shiftGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) &#123; int m = grid.size(); //行数 int n = grid[0].size(); //列数 vector&lt;vector&lt;int&gt;&gt; res; res.resize(m); for (int i = 0; i &lt; m; i++) &#123; res[i].resize(n); &#125; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; res[((k + j) / n + i) % m][(k + j) % n] = grid[i][j]; &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：1672.最富有客户的资产总量","slug":"LeetCode刷题记录：1672. 最富有客户的资产总量","date":"2021-01-19T08:28:35.000Z","updated":"2021-01-19T08:29:56.315Z","comments":true,"path":"2021/01/19/LeetCode刷题记录：1672. 最富有客户的资产总量/","link":"","permalink":"http://example.com/2021/01/19/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A1672.%20%E6%9C%80%E5%AF%8C%E6%9C%89%E5%AE%A2%E6%88%B7%E7%9A%84%E8%B5%84%E4%BA%A7%E6%80%BB%E9%87%8F/","excerpt":"","text":"扫描每一行找出最大值 1234567891011121314151617class Solution &#123;public: int maximumWealth(vector&lt;vector&lt;int&gt;&gt;&amp; accounts) &#123; int max = 0; int temp = 0; for (int i = 0; i &lt; accounts.size(); i++) &#123; temp = 0; for (int j = 0; j &lt; accounts[0].size(); j++) &#123; temp += accounts[i][j]; &#125; if (temp &gt; max) &#123; max = temp; &#125; &#125; return max; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：832.反转图像","slug":"LeetCode刷题记录：832.反转图像","date":"2021-01-19T08:21:35.000Z","updated":"2021-01-19T08:22:47.686Z","comments":true,"path":"2021/01/19/LeetCode刷题记录：832.反转图像/","link":"","permalink":"http://example.com/2021/01/19/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A832.%E5%8F%8D%E8%BD%AC%E5%9B%BE%E5%83%8F/","excerpt":"","text":"对每一行逆序的同时进行取反 123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; int i, j, k,temp; for (i = 0; i &lt; A.size(); i++) &#123; j = 0; k = A[0].size() - 1; while (j &lt; k) &#123; temp = A[i][j]; A[i][j] = !A[i][k]; A[i][k] = !temp; j++; k--; &#125; if (j == k) &#123; A[i][k] = !A[i][k]; &#125; &#125; return A; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：287.寻找重复数","slug":"LeetCode刷题记录：287.寻找重复数","date":"2021-01-19T07:54:35.000Z","updated":"2021-01-19T07:55:54.486Z","comments":true,"path":"2021/01/19/LeetCode刷题记录：287.寻找重复数/","link":"","permalink":"http://example.com/2021/01/19/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A287.%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/","excerpt":"","text":"法一 使用哈希表 1234567891011121314class Solution &#123;public: int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; map&lt;int, int&gt; mp; for (int i = 0; i &lt; nums.size(); i++) &#123; //边存边判断 if (mp[nums[i]] &gt; 0) &#123; return nums[i]; &#125; mp[nums[i]]++; &#125; return 0; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：867.转置矩阵","slug":"LeetCode刷题记录：867.转置矩阵","date":"2021-01-18T16:49:35.000Z","updated":"2021-01-18T16:51:01.751Z","comments":true,"path":"2021/01/19/LeetCode刷题记录：867.转置矩阵/","link":"","permalink":"http://example.com/2021/01/19/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A867.%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/","excerpt":"","text":"将每一列的第i个行存入temp 将temp插入到trans中 temp清空 循环 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; transpose(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; int row = A.size(); //行数 int column = A[0].size(); //列数 vector&lt;vector&lt;int&gt;&gt; trans; vector&lt;int&gt; temp; //将每一列的第i个行存入temp,再将temp插入到trans中 for (int j = 0; j &lt; column; j++) &#123; for (int i = 0; i &lt; row; i++) &#123; temp.push_back(A[i][j]); &#125; trans.push_back(temp); temp.clear(); &#125; return trans; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：747.至少是其他数字两倍的最大数","slug":"LeetCode刷题记录：747.至少是其他数字两倍的最大数","date":"2021-01-18T16:15:35.000Z","updated":"2021-01-19T07:53:17.807Z","comments":true,"path":"2021/01/19/LeetCode刷题记录：747.至少是其他数字两倍的最大数/","link":"","permalink":"http://example.com/2021/01/19/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A747.%E8%87%B3%E5%B0%91%E6%98%AF%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E4%B8%A4%E5%80%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0/","excerpt":"","text":"先找出最大值，再与其他元素依次比较 当遇到元素*2大于最大值的情况返回-1 否则返回最大值的索引 当数组只有一个元素时返回0 1234567891011121314151617181920212223class Solution &#123;public: int dominantIndex(vector&lt;int&gt;&amp; nums) &#123; int length = nums.size(); if (length == 1) &#123; return 0; &#125; //找出最大值 int max = 0; for (int i = 0; i &lt; length; i++) &#123; if (nums[max] &lt; nums[i]) &#123; max = i; &#125; &#125; //遍历数组看是否有元素*2大于最大值的情况 for (int i = 0; i &lt; length; i++) &#123; if (i != max &amp;&amp; nums[i] * 2 &gt; nums[max]) &#123; return -1; &#125; &#125; return max; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：1266. 访问所有点的最小时间","slug":"LeetCode刷题记录：1266.访问所有点的最小时间","date":"2021-01-18T12:33:35.000Z","updated":"2021-01-18T12:43:03.313Z","comments":true,"path":"2021/01/18/LeetCode刷题记录：1266.访问所有点的最小时间/","link":"","permalink":"http://example.com/2021/01/18/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A1266.%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4/","excerpt":"","text":"切比雪夫距离 当当前位置x，y均与目标点不同时，需斜向移动目标点与当前点横纵坐标差值的绝对值中最小的数个单位，再横向或纵向移动剩余位置。移动次数之和正好是目标点与当前点横纵坐标差值的绝对值中最大的数。 时间复杂度低，当空间消耗较多 12345678910class Solution &#123;public: int minTimeToVisitAllPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; int count = 0; //记录步数 for (int i = 1; i &lt; points.size(); i++) &#123; count += max(abs(points[i][0] - points[i - 1][0]), abs(points[i][1] - points[i - 1][1])); &#125; return count; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：1588.所有奇数长度子数组的和","slug":"LeetCode刷题记录：1588.所有奇数长度字数组的和","date":"2021-01-18T09:13:35.000Z","updated":"2021-01-18T12:42:55.692Z","comments":true,"path":"2021/01/18/LeetCode刷题记录：1588.所有奇数长度字数组的和/","link":"","permalink":"http://example.com/2021/01/18/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A1588.%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%97%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/","excerpt":"","text":"法一： 从头开始扫描，扫描到一个数时，找到每一个以该元素作为开始的奇数子数组并计入。 12345678910111213141516class Solution &#123;public: int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) &#123; int length = arr.size(); int length = arr.size(); int sum = 0; for (int i = 0; i &lt; length; i++) &#123; for (int j = 0; i + j &lt; length; j += 2) &#123; for (int k = 0; k &lt;= j; k++) &#123; sum += arr[i + k]; &#125; &#125; &#125; return sum; &#125;&#125;; 法二：第i个数左边有i个数，右边有length-i-1（length为数组长度）个数。只有当左右都选奇数个或者都选偶数个时，加上自身个数才为奇数 123456789101112131415161718class Solution &#123;public: int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) &#123; int length = arr.size(); int count = 0, sum = 0; for (int i = 0; i &lt; length; i++) &#123; //奇，i两边各选奇数个数情况的数量 count = i / 2 + i % 2; count *= (length - i - 1) / 2 + (length - i - 1) % 2; sum += arr[i] * count; //偶，i两边各选偶数个数情况的数量 count = i / 2 + 1; count *= (length - i - 1) / 2 + 1; sum += arr[i] * count; &#125; return sum; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：35.搜索插入位置","slug":"LeetCode刷题记录：35.搜索插入位置","date":"2021-01-17T16:10:35.000Z","updated":"2021-01-18T17:02:20.247Z","comments":true,"path":"2021/01/18/LeetCode刷题记录：35.搜索插入位置/","link":"","permalink":"http://example.com/2021/01/18/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A35.%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/","excerpt":"","text":"由于序列是有序的，当目标值大于数组最后一个元素时表明数组中没有等于目标值的元素，插入位置为数组长度 由于序列是有序的，当目标值小于数组第一个元素时表明数组中没有等于目标值的元素，插入位置为0 使用折半查找法进行查找，找到目标值位置或插入位置 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int low, high, mid; low = 0; high = nums.size() - 1; //目标值大于数组最后一个元素和目标值小于数组第一个元素情况 if (target &gt; nums[high]) &#123; return high + 1; &#125; else if (target &lt; nums[low]) &#123; return low; &#125; else &#123; //折半查找法进行查找，找到目标值位置或插入位置 while (low &lt;= high) &#123; mid = (low + high) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target) &#123; low = mid + 1; &#125; else &#123; high = mid - 1; &#125; &#125; return low; &#125; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：66.加一","slug":"LeetCode刷题记录：66.加一","date":"2021-01-17T15:31:35.000Z","updated":"2021-01-18T08:10:03.334Z","comments":true,"path":"2021/01/17/LeetCode刷题记录：66.加一/","link":"","permalink":"http://example.com/2021/01/17/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A66.%E5%8A%A0%E4%B8%80/","excerpt":"","text":"12345678910111213141516171819class Solution &#123;public: std::vector&lt;int&gt; plusOne(std::vector&lt;int&gt;&amp; digits) &#123; int length = digits.size(); int i = length - 1; //加一之后某一位需要进位则该位前每一位都为9 for (i = length - 1; i &gt;= 0 &amp;&amp; digits[i] == 9; i--) &#123; digits[i] = 0; &#125; //当最高位加一后仍需进位（即i == -1）时，在数组头插入1 if (i == -1) &#123; digits.insert(digits.begin(), 1); &#125; else &#123; digits[i]++; &#125; return digits; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"}]},{"title":"LeetCode刷题记录：8.字符串转换整数(atoi)","slug":"LeetCode刷题记录：字符串转换整数-atoi","date":"2021-01-09T09:02:35.000Z","updated":"2021-01-18T12:42:48.256Z","comments":true,"path":"2021/01/09/LeetCode刷题记录：字符串转换整数-atoi/","link":"","permalink":"http://example.com/2021/01/09/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi/","excerpt":"","text":"请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下： 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0 。 注意： 本题中的空白字符只包括空格字符 &#39; &#39; 。 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31, 2^31 − 1]。如果数值超过这个范围，请返回2^31 − 1或−2^31 。 *示例 1:**12输入: &quot;42&quot;输出: 42 *示例 2:**1234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 *示例 3:**123输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。 *示例 4:**1234输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。 因此无法执行有效的转换。 *示例 5:**1234输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 *提示：** 0 &lt;= s.length &lt;= 200 s由英文字母（大写和小写）、数字、 、+、-和.组成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int myAtoi(char * a) &#123; //判空 if (a == NULL) &#123; return 0; &#125; //丢弃无用的开头空格字符 while (*a == &#x27; &#x27;) &#123; a++; &#125; //判断是否为负数 int index = 1; switch (*a) &#123; case &#x27;-&#x27;: index = -1; a++; break; case &#x27;+&#x27;: a++; break; &#125; //计数 long long sum = 0; unsigned long max = 2147483647; unsigned long min = 2147483648; while (*a != &#x27;\\0&#x27; &amp;&amp; *a != &#x27; &#x27;) &#123; if (*a &gt;= &#x27;0&#x27; &amp;&amp; *a &lt;= &#x27;9&#x27;) &#123; sum = sum * 10 + *a - &#x27;0&#x27;; //判断数字是否超过有符号整型范围 if (index == -1) &#123; if (sum &gt; min) &#123; return INT_MIN; &#125; &#125; else &#123; if (sum &gt; max) &#123; return INT_MAX; &#125; &#125; &#125; else if (*a = &#x27;.&#x27;) &#123; break; &#125; else &#123; //如果在数字中出现其他字符返回0 return 0; &#125; a++; &#125; return sum * index;&#125;int main() &#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); char *num = (char *)malloc(n * sizeof(char)); getchar(); gets(num); int re_num = myAtoi(num); printf(&quot;%d&quot;, re_num);&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"字符串","slug":"LeetCode/字符串","permalink":"http://example.com/categories/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"数据结构&算法笔记","slug":"数据结构-算法笔记","date":"2021-01-07T12:55:20.000Z","updated":"2021-02-22T07:11:49.120Z","comments":true,"path":"2021/01/07/数据结构-算法笔记/","link":"","permalink":"http://example.com/2021/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","excerpt":"","text":"数据结构的定义 数据结构是相互之间存在一种或多种特定关系的数据元素的集合 数据 算法五个基本特性 输入 输出 有穷性 确定性 可行性 算法的要求 正确性 可读性 健壮性 时间复杂度和空间复杂度低 事前分析估算方法 在计算机程序编制前，依据统计方法对算法进行估算 一个程序的运行时间，依赖于算法的好坏和问题的输入规模，所谓问题输入规模是指输入量的多少 在分析程序的运行时间时，最重要的是把程序看成独立于程序设计语言的算法或一系列步骤 常见的时间复杂度O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n) 树二叉树二叉搜索树的建立遍历先序遍历递归12345678void Tree::preOrder(treenode * root) &#123; if (root == NULL) &#123; return; &#125; cout &lt;&lt; root-&gt;val &lt;&lt; endl; preOrder(root-&gt;left); preOrder(root-&gt;right);&#125; 非递归 首先申请一个新的栈，记为stack。 然后将根节点root压入stack中。 每次从stack中弹出栈顶节点，记为cur，然后打印cur节点的值。如果cur右孩子不为空的话，将cur的右孩子先压入stack中。最后如果cur的左孩子不为空的话，将cur的左孩子压入stack中。即可实现中左右。 不断重复步骤3，知道stack为空。 1234567891011121314151617void Tree::preOrderFor(treenode* root) &#123; stack&lt;treenode*&gt; ans; treenode* cur; ans.push(root); while (!ans.empty()) &#123; cur = ans.top(); cout &lt;&lt; cur-&gt;val &lt;&lt; &quot; &quot;; ans.pop(); if (cur-&gt;right) &#123; ans.push(cur-&gt;right); &#125; if (cur-&gt;left) &#123; ans.push(cur-&gt;left); &#125; &#125; cout &lt;&lt; endl;&#125; 中序遍历递归12345678void Tree::inOrder(treenode* root) &#123; if (root == NULL) &#123; return; &#125; inOrder(root-&gt;left); cout &lt;&lt; root-&gt;val &lt;&lt; endl; inOrder(root-&gt;right);&#125; 非递归 首先申请一个新的栈，记为stack。申请一个变量cur初始时令cur等于根节点。 先把cur节点压入栈中，对以cur节点为根的整颗子树来说，依次把整棵树的左边界压入栈中。 从stack中弹出一个节点记为cur，打印cur的值，将cur右子树的根节点压入栈中，cur = cur-&gt;right，重复步骤2。即可实现左中右。 不断重复步骤3，知道stack为空。 123456789101112131415161718192021222324void Tree::inOrderFor(treenode * root)&#123; stack&lt;treenode*&gt; ans; treenode* cur = root; ans.push(cur); while (cur-&gt;left) &#123; ans.push(cur-&gt;left); cur = cur-&gt;left; &#125; while (!ans.empty()) &#123; cur = ans.top(); ans.pop(); cout &lt;&lt; cur-&gt;val &lt;&lt; &quot; &quot;; if (cur-&gt;right) &#123; ans.push(cur-&gt;right); cur = cur-&gt;right; &#125; while (cur-&gt;left) &#123; ans.push(cur-&gt;left); cur = cur-&gt;left; &#125; &#125; cout &lt;&lt; endl;&#125; 后序遍历递归12345678void Tree::postOrder(treenode* root) &#123; if (root == NULL) &#123; return; &#125; postOrder(root-&gt;left); postOrder(root-&gt;right); cout &lt;&lt; root-&gt;val &lt;&lt; endl;&#125; 非递归 法一：使用两个栈实现具体过程如下∶ 申请一个栈，记为s1，然后将头节点压入s1中。 从s1中弹出的节点记为cur，然后先把cur的左孩子压入s1中，然后把cur1的右孩子压入s1中。 在整个过程中，每一个从s1中弹出的节点都放进第二个栈s2中。 不断重复步骤2和步骤3会直到s1为空，过程停止。 12345678910111213141516171819202122void Tree::postOrderFor(treenode * root) &#123; stack&lt;treenode*&gt; ans1; stack&lt;treenode*&gt; ans2; treenode* cur = root; ans1.push(cur); while (!ans1.empty()) &#123; cur = ans1.top(); ans1.pop(); ans2.push(cur); if (cur-&gt;left) &#123; ans1.push(cur-&gt;left); &#125; if (cur-&gt;right) &#123; ans1.push(cur-&gt;right); &#125; &#125; while (!ans2.empty()) &#123; cout &lt;&lt; ans2.top()-&gt;val &lt;&lt; &quot; &quot;; ans2.pop(); &#125; cout &lt;&lt; endl;&#125; 法二:使用一个栈实现具体过程如下: 申请一个栈，记为stack，将头节点压入stack ,同时设置两个变量h和c。在整个流程中，h代表最近一次弹出并打印的节点，c代表当前stack的栈顶节点,初始时令h为头节点，c为null. 每次令c等于当前stack的栈顶节点，但是不从stack中弹出节点，此时分以下三种情况： (1) 如果c的左孩子不为空，并且h不等于c的左孩子，也不等于c的右孩子，则把c的左孩子压入stack中。 (2)如果情况1不成立，并且c的右孩子不为空，并且h不等于c的右孩子,则把c的右孩子压入stack中。 (3)如果情况1和情况2都不成立，那么从stack中弹出c并打印，然后令h等于c. 一直重复步骤2，直到stack为空，过程停止。 层次遍历 将根节点放入队列 每次从队列中弹出一个节点，记为node 看这个node有没有左孩子，如果有左孩子把左孩子放入到队列中，如果node有右孩子，把右孩子放入到队列中 重复步骤二和步骤三，直到队列为空 123456789101112131415void Tree::layerOrder(treenode* root) &#123; queue&lt;treenode*&gt; res; res.push(root); while (!res.empty()) &#123; cout &lt;&lt; res.front()-&gt;val &lt;&lt; &#x27; &#x27;; if (res.front()-&gt;left) &#123; res.push(res.front()-&gt;left); &#125; if (res.front()-&gt;right) &#123; res.push(res.front()-&gt;right); &#125; res.pop(); &#125; cout &lt;&lt; endl;&#125; 特殊的二叉树 参考文档：http://www.cnblogs.com/skywang12345/p/3603935.html 平衡二叉树 AVL树是高度平衡的二叉树。它的特点是：AVL树中任何节点的两个子树的高度最大差别为1。 伸展树 能在O(lgn)内完成插入，查找和删除操作。 伸展树属于二叉查找树 当某个节点被访问时，伸展树会通过旋转使该节点成为树根。这样下次要访问该节点时，能够迅速的访问到该节点。 高频用户时间复杂度低。 红黑树 O(lgn) 每个节点是黑色或红色 根节点是黑色 每个叶子节点（NIL）是黑色。这里的叶子节点是指为空（NIL或NULL）的叶子节点 如果一个节点是红色的，则它的子节点必须是黑色的 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。（确保没有一条路径会比其他路径长出两个红色节点。因此红黑树是相对接近平衡的二叉树） B树&amp;B+树B树B树是一种平衡的多分树，通常我们说m阶的B树，它必须满足如下条件: 每个节点最多只有m个子节点。 每个非叶子节点(除了根)有至少（m/2）向上取整个子节点。 如果根不是叶节点，则根至少有2个子节点。 具有k个子节点的非叶节点包含k -1个键。 所有叶子节点都在同一层，没有任何信息(高度一致)。 B+树B+树的特征: 有m个子树的中间节点包含有m个元素(B树中是k-1个元素)， 每个元素不保存数据，只用来索引; 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。(而B 树的叶子节点并没有包括全部需要查找的信息); 所有的非终端结点可以看成是索引部分,结点中仅含有其子树根结点中最大(或最小)关键字。(而B树的非终节点也包含需要查找的有效信息)。 图 unordered_map map 底层实现 哈希表 红黑树 时间复杂度 O(1) O(logn) 顺序 无序 有序 广度优先遍历1234567891011121314151617181920void Graph::BFS(int startPoint)&#123; queue&lt;int&gt; que; que.push(startPoint); unordered_set&lt;int&gt; visited; visited.insert(startPoint); //与树的层次遍历类似，需要一个visited数组记录已经访问过的节点 while (!que.empty()) &#123; int cur = que.front(); cout &lt;&lt; (char)cur &lt;&lt; &quot; &quot;; que.pop(); int temp = cityIndex[cur]; for (int i = 0; i &lt; matrix[temp].size(); i++) &#123; if (matrix[temp][i] &amp;&amp; visited.find(cities[i]) == visited.end()) &#123; que.push(cities[i]); visited.insert(cities[i]); &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 深度优先遍历 非递归深度优先遍历 123456789101112131415161718192021void Graph::DFSFor(int startPoint) &#123; stack&lt;int&gt; s; unordered_set&lt;int&gt; visited; s.push(startPoint); visited.insert(startPoint); //与先序遍历二叉树类似，需要一个visited数组记录已经访问过的节点 while (!s.empty()) &#123; int cur = s.top(); cout &lt;&lt; (char)cur &lt;&lt; &quot; &quot;; s.pop(); int index = cityIndex[cur]; for (int i = 0; i &lt; matrix[index].size(); i++) &#123; if (matrix[index][i] &amp;&amp; visited.find(cities[i]) == visited.end()) &#123; s.push(cities[i]); visited.insert(cities[i]); break; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 递归深度优先遍历 12345678910void Graph::DFS(int startPoint, unordered_set&lt;int&gt;&amp; visited) &#123; visited.insert(startPoint); cout &lt;&lt; char(startPoint) &lt;&lt; endl; int index = cityIndex[startPoint]; for (int i = 0; i &lt; matrix[index].size(); i++) &#123; if (matrix[index][i] &amp;&amp; visited.find(cities[i]) == visited.end()) &#123; DFS(cities[i], visited); &#125; &#125;&#125; Prim算法 最小生成树（无向图） 从点出发。 每次选择与最小生成树相连的边中权重最小的边，并将该边相连的节点纳入最小生成树。 123456789101112131415161718192021222324252627282930313233343536373839404142434445struct priority_cmp &#123; bool operator()(const Edge *a, const Edge *b) &#123; return a-&gt;value &gt; b-&gt;value; &#125;&#125;;vector&lt;Edge*&gt; Graph::Prim(int startPoint)&#123; //小顶堆用于查找与当前已纳入节点相连的边中权重最小的边 priority_queue&lt;Edge*,vector&lt;Edge*&gt;,priority_cmp&gt; miniheap; unordered_set&lt;int&gt; visited; vector&lt;Edge*&gt; res; Edge *temp; int n = cities.size() - 1; while (n) &#123; visited.insert(startPoint); int startindex = cityIndex[startPoint]; //将以新纳入最小二叉树的节点为起点的边存入miniheap for (int i = 0; i &lt; matrix[startindex].size(); i++) &#123; if (matrix[startindex][i] &amp;&amp; visited.find(cities[i]) == visited.end()) &#123; temp = new Edge(cities[startindex], cities[i], matrix[startindex][i]); miniheap.push(temp); &#125; &#125; //将终点已经纳入最小二叉树的边弹出miniheap while (!miniheap.empty() &amp;&amp; visited.find(miniheap.top()-&gt;end) != visited.end()) &#123; temp = miniheap.top(); miniheap.pop(); delete temp; &#125; //纳入新节点 if (!miniheap.empty()) &#123; res.push_back(miniheap.top()); startPoint = miniheap.top()-&gt;end; visited.insert(startPoint); miniheap.pop(); &#125; n--; &#125; while (!miniheap.empty()) &#123; temp = miniheap.top(); miniheap.pop(); delete temp; &#125; return res;&#125; kruskal算法 位图int==4B 1B==8位 int==32位 用下标对应数据 存储（0-99）只需要4int，极大地节省了空间 找到这个i所对应位图的位置：数组的第几个元素，是在这个元素的第几位。 没办法统计次数。 123456789int *arr = new int[10];int i = 178;//找到这个i所对应位图的位置int numIndex = 178 / 32;int bitIndex = 178 % 32;//拿到178位的状态int s = ((arr[numIndex]&gt;&gt;(bitIndex)) &amp; 1);//将178位的状态改为1arr[numIndex] = arr[numIndex] | (1&lt;&lt;bitIndex); 哈希表哈希表中对数据的增删改查操作时间复杂度为O(1) 哈希函数 输入域无穷大，输出域有限 有可能不同的输入，对应相同的输出 如果输入的参数是一样的，输出结果一定是相同的，没有任何随机的成分分 均匀性：类似的输入，通过打乱，可以得到均匀 链地址法 扩容：链表已经很长，影响效率。扩容代价很大，但一次扩容成倍增长，可以保持效率。扩容的过程不会影响用户使用 开放地址法 线性探测 平方探测 再哈希法查找顺序查找顺序查找(Sequential Search)又叫线性查找，是最基本的查找技术，它的查找过程是:从表中第一个(或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录;如果直到最后一个(或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。 123456789int Sequential_Search_1(int *a, int len, int key) &#123; for (int i = 1; i &lt;= len; i++) &#123; if (a[i] == key) &#123; return i; &#125; &#125; return 0;&#125; 优化设置一个哨兵使其不需要每次让i与n比较（防止越界） 12345678910int Sequential_Search_2(int *a, int len, int key) &#123; int i; a[0] = key; // 设置a[0]为哨兵 i = len; while (a[i] != key) &#123; i--; &#125; return i;&#125; 时间复杂度最好的情况：第一个元素就是key O(1) 最坏的情况：最后一个元素是key O(n) 平均时间复杂度：n*(n+1)/2 O(n) 有序表查找折半查找折半查找（Binary Search)技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序（通常从小到大有序)，线性表必须采用顺序存储。折半查找的基本思想是:在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功;若给定值小于中间记录的关键字，则在中间记录的左半区继续查找;若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。 123456789101112131415161718int Binary_Search(int *a, int n, int key) &#123; int low = 1; int high = n; int mid; while (low &lt;= high) &#123; mid = (low + high) / 2; if (a[mid] == key) &#123; return mid; &#125; else if (a[mid] &lt; key) &#123; low = mid + 1; &#125; else &#123; high = mid - 1; &#125; &#125; return 0;&#125; 时间复杂度具有n个结点的完全二叉树的深度为$$\\left\\lfloor { { {\\log }_2}n} \\right\\rfloor + 1$$ 折半查找判定二叉树并不是完全二叉树，但同样相同的推导可以得出，最坏情况是查找到关键字或查找失败的次数为$$\\left\\lfloor { { {\\log }_2}n} \\right\\rfloor + 1$$故时间复杂度为$$O({\\rm{log}}n)$$注意：由于折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，比较适合折半查找。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。 插值查找插值查找(Interpolation Search)是折半查找的改进方案，是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式$$\\fracNaNNaN$$ 12345678910111213141516171819//插值查找int Interpolation_Search(int *a, int n, int key) &#123; int low = 1; int high = n; int mid = 0; while (low &lt;= high) &#123; mid = low + (key - a[low]) * (high - low) / (a[high] - a[low]); if (a[mid] == key) &#123; return mid; &#125; else if (a[mid] &lt; key) &#123; low = mid + 1; &#125; else &#123; high = mid - 1; &#125; &#125; return 0;&#125; 时间复杂度时间复杂度仍是$$O({\\rm{log}}n)$$,但对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多。反之，数组中如果分布类似{,1,2,00200….999998, 99999}这种极端不均匀的数据，用插值查找未必是很合适的选择。 排序时间复杂度快些归队：O(n*logn) 其中希尔是$$O(n_{}^{3/2})$$剩下的都是$$O(n_{}^2)$$ 稳定性快些选一堆 不稳定 内排序与外排序 根据在排序过程中待排序的记录是否全部被放置在内存中，排序分为:内排序和外排序。 内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。 外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。 时间性能在内排序中，主要进行两种操作:比较和移动。比较指关键字之间的比较。移动指记录从一个位置移动到另一个位置，移动可以通过改变记录的存储方式来予以避免。高效率的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。 辅助空间评价排序算法的另一个主要标准是执行算法所需要的辅助存储空间。辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。 算法的复杂性这里指的是算法本身的复杂度，而不是指算法的时间复杂度。算法过于复杂会影响排序的性能。根据排序过程中借助的主要操作，我们把内排序分为:插入排序、交换排序、选择排序和归并排序。 封装成类※ 封装成模板※ 冒泡排序（Bubble Sort） 交换排序 思想：两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止。 1234567891011121314void Sort::bubbleSort(std::vector&lt;int&gt;&amp; vec, int n) &#123; for (int j = n - 1; j &gt;= 1; j--) &#123; bool flag = false; for (int i = 0; i &lt; j; i++) &#123; if (vec[i] &gt; vec[i + 1]) &#123; std::swap(vec[i], vec[i + 1]); flag = true; &#125; &#125; if (flag = false) &#123; break; &#125; &#125;&#125; 时间复杂度 最好情况下：没有发生数据交换，时间复杂度为 $$ O(n) $$ 最坏情况下：待排序表为逆序，时间复杂度为 $$ O(n_{}^2) $$ 平均时间复杂度为 $$ O(n_{}^2) $$ 简单选择排序(Simple Selection Sort)通过n次关键字间的比较，从n-i+1个记录中选出关键字最大的记录，并和第n-i+1(1&lt;i&lt;n)个记录交换之。 12345678910111213void Sort::selectSort(vector&lt;int&gt;&amp; vec, int n) &#123; for (int j = n - 1; j &gt;= 1; j--) &#123; int maxIndex = 0; for (int i = 1; i &lt;= j; i++) &#123; if (vec[i] &gt; vec[maxIndex]) &#123; maxIndex = i; &#125; &#125; if (maxIndex != j) &#123; swap(vec[maxIndex], vec[j]); &#125; &#125;&#125; 时间复杂度$$O(n_{}^2)$$ 虽然时间复杂度和冒泡排序一样，但性能上要略优于冒泡 直接插入排序(Straight Insertion Sort)基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。 123456789101112void Sort::straightSort(vector&lt;int&gt;&amp; vec, int n) &#123; int i,j,temp; for (i = 1; i &lt; n; i++) &#123; if (vec[i] &lt; vec[i - 1]) &#123; //当插入有序表需要移动记录时 temp = vec[i]; //设置哨兵 for (j = i - 1; j &gt;= 0 &amp;&amp; vec[j] &gt; temp; j--) &#123; vec[j + 1] = vec[j]; //大于哨兵的记录后移 &#125; vec[j + 1] = temp; //插入到正确位置 &#125; &#125;&#125; 时间复杂度 最好的情况：本身已经有序，时间复杂度为 $$ O(n) $$ 最坏的情况：逆序，时间复杂度为 $$ O(n_{}^2) $$ 平均时间复杂度为 $$ O(n_{}^2) $$ 性能比冒泡和简单选择好 希尔排序 先使序列基本有序。所谓的基本有序,就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间。 采取跳跃分割的策略:将相距某个‘增量” 的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。 增量序列的最后一个增量值必须为1. 12345678910111213141516void Sort::shellSort(vector&lt;int&gt;&amp; vec, int n) &#123; int i, j; int gap = n / 2; //增量序列 while (gap &gt;= 1) &#123; for (i = gap + 1; i &lt;= n; i++) &#123; if (vec[i] &lt; vec[i - gap]) &#123; vec[0] = vec[i]; for (j = i - gap; j &gt; 0 &amp;&amp; vec[0] &lt; vec[j]; j -= gap) &#123; vec[j + gap] = vec[j]; &#125; vec[j + gap] = vec[0]; &#125; &#125; gap--; &#125;&#125; 时间复杂度当增量序列为$$dlta[k] = 2_{}^{t - k + 1} - 1(0 \\le k \\le t \\le \\left\\lfloor { { {\\log }2}(n + 1)} \\right\\rfloor )$$时，可以获得时间复杂度$$O(n{}^{3/2})$$ 堆排序（Heap Sort）利用堆(假设利用大顶堆)进行排序的方法。它的基本思想是，将待排序的序列构造成-一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走(其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的n-1个序列重新构造成-一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列了。 难点 如何由一个无序序列构建成-一个堆? 如果在输出堆顶元素后，调整剩余元素成为一个新的堆? 堆排序 1234567891011void Sort::heapSort(vector&lt;int&gt;&amp; vec, int n) &#123; int fa = (n / 2) - 1; //初始堆调整 while (fa &gt;= 0) &#123; heapAdjust(vec, fa--, n); &#125; for (int i = n - 1; i &gt; 0; i--) &#123; swap(vec[i], vec[0]); heapAdjust(vec, 0, i); &#125;&#125; 堆调整 123456789101112131415161718void Sort::heapAdjust(vector&lt;int&gt;&amp; vec, int fa, int maxindex) &#123; //数组从下标0开始存放 int ch; ch = 2 * fa + 1; while (ch &lt; maxindex) &#123; if (ch + 1 &lt; maxindex &amp;&amp; vec[ch] &lt; vec[ch + 1]) &#123; ch = ch + 1; &#125; else if (vec[fa] &lt; vec[ch]) &#123; swap(vec[fa], vec[ch]); fa = ch; ch = 2 * fa + 1; &#125; else &#123; break; &#125; &#125;&#125; 时间复杂度堆排序对原始记录的排序状态不敏感，最好、最坏和平均时间复杂度都是$$O(n\\log n)$$ 桶排序（基数排序）原理:将数值作为桶号，遍历整个数组，将相应的桶进行计数。数据较为密集时比较好。稳定。 第一步 遍历原数组，找到最大值max,并且申请max+1个桶,初始化都为0（下标从0到max），即vector&lt;int&gt;bucket(max+1,0); 第二步 遍历原数组，找到每个数值对应的桶号，并对桶计数++，即bucket[a[i]]++; 第三步 遍历桶数组，看对应的桶内计数为几就取出几个下标值，放到原数组，即 while(bucket[i]--) a[index++] = bucket[i]; 123456789101112131415161718192021void Sort::bucketSort(vector&lt;int&gt;&amp; vec, int n) &#123; //找到最大值 int bucket_max = vec[0]; for (int i = 1; i &lt; n; i++) &#123; if (vec[i] &gt; bucket_max) &#123; bucket_max = vec[i]; &#125; &#125; //将数据存入桶中 vector&lt;int&gt; bucket(bucket_max + 1, 0); for (int i = 0; i &lt; n; i++) &#123; bucket[vec[i]]++; &#125; //遍历桶 int j = 0; for (int i = 0; i &lt;= bucket_max; i++) &#123; while (bucket[i]--) &#123; vec[j++] = i; &#125; &#125;&#125; 时间复杂度O(n) 空间复杂度O(n) 快速排序(Quick Sort) 通过一趟排序将待排记录分割成独立的两部分，其中- -部分记录的关键字均比另一部分 记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。 每趟排序都会有一个元素达到最终位置 三色旗稳定 拓扑排序有向无环图","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"C语言例题7：输出和为s的数组元素","slug":"C语言例题7：输出和为s的数组元素","date":"2021-01-06T12:59:39.000Z","updated":"2021-01-11T10:27:10.874Z","comments":true,"path":"2021/01/06/C语言例题7：输出和为s的数组元素/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%987%EF%BC%9A%E8%BE%93%E5%87%BA%E5%92%8C%E4%B8%BAs%E7%9A%84%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0/","excerpt":"输出和为s的数组元素Description输入一个递增排序的数组和数字s.在数组中查找两个数，使得他们的和恰好为s。如果有多对数字的和等于s，输出两个数的乘积最小的","text":"输出和为s的数组元素Description输入一个递增排序的数组和数字s.在数组中查找两个数，使得他们的和恰好为s。如果有多对数字的和等于s，输出两个数的乘积最小的 Input输入第一个数 n 表示数组长度输入第二个数 s 表示两个数之和其余数组中的数按空格分开输入 Output输出满足条件的两个元素 解法思想 先从后向前找最后一个小于s的数记为j（可以减少主循环次数），从第一个元素开始到j依次两两相加，查找符合条件（和为s且乘积最小）的两个数 矩形面积，周长相等时，正方向面积大于长方形面积。故和相等时，差值越大乘积越小 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int n = 0; int target = 0; scanf(&quot;%d %d&quot;,&amp;n,&amp;target); int *nums = (int *)malloc(n*sizeof(int)); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;,&amp;nums[i]); &#125; int i = 0; int j = n - 1; while (i &lt; j) &#123; if (nums[i] + nums[j] &gt; target) &#123; j--; &#125; if (nums[i] + nums[j] &lt; target) &#123; i++; &#125; else if (nums[i] + nums[j] == target) &#123; printf(&quot;%d %d&quot;,nums[i],nums[j]); return 0; &#125; &#125; return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"习题","slug":"C-C/习题","permalink":"http://example.com/categories/C-C/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"C/C++习题","slug":"C-C-习题","permalink":"http://example.com/tags/C-C-%E4%B9%A0%E9%A2%98/"}]},{"title":"C语言例题6：查看亮灯情况","slug":"C语言例题6：查看亮灯情况","date":"2021-01-06T12:44:14.000Z","updated":"2021-01-11T10:27:25.281Z","comments":true,"path":"2021/01/06/C语言例题6：查看亮灯情况/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%986%EF%BC%9A%E6%9F%A5%E7%9C%8B%E4%BA%AE%E7%81%AF%E6%83%85%E5%86%B5/","excerpt":"查看亮灯情况Descriopion一条长廊里依次装有n(1 ≤ n ≤ 65535)盏电灯，从头到尾编号1、2、3、…n-1、n。 每盏电灯由一个拉线开关控制。开始，电灯全部关着。 有n个学生从长廊穿过。第一个学生把号码凡是1的倍数的电灯的开关拉一下； 接着第二个学生把号码凡是2的倍数的电灯的开关拉一下； 接着第三个学生把号码凡是3的倍数的电灯的开关拉一下； 如此继续下去，最后第n个学生把号码凡是n的倍数的电灯的开关拉一下。 n个学生按此规定走完后，长廊里电灯有几盏亮着。 注：电灯数和学生数一致。","text":"查看亮灯情况Descriopion一条长廊里依次装有n(1 ≤ n ≤ 65535)盏电灯，从头到尾编号1、2、3、…n-1、n。 每盏电灯由一个拉线开关控制。开始，电灯全部关着。 有n个学生从长廊穿过。第一个学生把号码凡是1的倍数的电灯的开关拉一下； 接着第二个学生把号码凡是2的倍数的电灯的开关拉一下； 接着第三个学生把号码凡是3的倍数的电灯的开关拉一下； 如此继续下去，最后第n个学生把号码凡是n的倍数的电灯的开关拉一下。 n个学生按此规定走完后，长廊里电灯有几盏亮着。 注：电灯数和学生数一致。 Input 1输入n个学生 Output 1输出当有n个学生的时候还有几盏灯亮着 解法碰过i号灯的人都是i的因子，当因子个数为奇数时灯亮。（完全平方数因子有重复，如：9 = 3 * 3） 12345678910111213#include&lt;stdio.h&gt;int main()&#123; int n &#x3D; 0; scanf(&quot;%d&quot;,&amp;n); int i &#x3D; 1; while(i * i &lt;&#x3D; n) &#123; i++; &#125; printf(&quot;%d&quot;,i-1); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"习题","slug":"C-C/习题","permalink":"http://example.com/categories/C-C/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"C/C++习题","slug":"C-C-习题","permalink":"http://example.com/tags/C-C-%E4%B9%A0%E9%A2%98/"}]},{"title":"C语言例题5：厄拉多塞筛选法","slug":"C语言例题5：厄拉多塞筛选法","date":"2021-01-06T12:40:00.000Z","updated":"2021-01-11T10:27:32.319Z","comments":true,"path":"2021/01/06/C语言例题5：厄拉多塞筛选法/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%985%EF%BC%9A%E5%8E%84%E6%8B%89%E5%A4%9A%E5%A1%9E%E7%AD%9B%E9%80%89%E6%B3%95/","excerpt":"厄拉多塞筛选法乘法运算的速度没有加法快西元前250年，希腊数学家厄拉多塞(Eeatosthese)想到了一个非常美妙的质数筛法，减少了逐一检查每个数的的步骤，可以比较简单的从一大堆数字之中，筛选出质数（素数）来，这方法被称作厄拉多塞筛法(Sieve of Eeatosthese)。","text":"厄拉多塞筛选法乘法运算的速度没有加法快西元前250年，希腊数学家厄拉多塞(Eeatosthese)想到了一个非常美妙的质数筛法，减少了逐一检查每个数的的步骤，可以比较简单的从一大堆数字之中，筛选出质数（素数）来，这方法被称作厄拉多塞筛法(Sieve of Eeatosthese)。 具体操作：先将 2~n 的各个数放入表中，然后在2的上面画一个圆圈，然后划去2的其他倍数；第一个既未画圈又没有被划去的数是3，将它画圈，再划去3的其他倍数；现在既未画圈又没有被划去的第一个数 是5，将它画圈，并划去5的其他倍数……依次类推，一直到所有小于或等于 n 的各数都画了圈或划去为止。这时，表中画了圈的以及未划去的那些数正好就是小于 n 的素数。 其实，当你要画圈的素数的平方大于 n 时，那么后面没有划去的数都是素数，就不用继续判了。如下图： Description输出1到1000以内所有素数 123456789101112131415161718#include &lt;stdio.h&gt;int main ()&#123; int nums[1001] &#x3D; &#123;0&#125; ; for (int i &#x3D; 2 ; i &lt;&#x3D; 1000 ; i++) &#123; if (nums[i] &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;证明是素数 printf( &quot;%d\\n&quot;, i); for (int j &#x3D; i + i; j&lt;&#x3D; 1000; j +&#x3D; i) &#123;&#x2F;&#x2F;把i的倍数都刷掉 nums[j]&#x3D; 1 ; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"习题","slug":"C-C/习题","permalink":"http://example.com/categories/C-C/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"C/C++习题","slug":"C-C-习题","permalink":"http://example.com/tags/C-C-%E4%B9%A0%E9%A2%98/"}]},{"title":"C语言例题4：股神","slug":"C语言例题4：股神","date":"2021-01-06T12:15:46.000Z","updated":"2021-01-11T10:27:38.770Z","comments":true,"path":"2021/01/06/C语言例题4：股神/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%984%EF%BC%9A%E8%82%A1%E7%A5%9E/","excerpt":"股神Description假设买入1元股票，股票的变化规律是第一天不变（0），第二天涨1元（1），第三天跌1元（-1），第四天涨1元（1），第五天涨1元（1），第六天跌1元（-1），第七天涨1元（1），第八天涨1元（1），第九天涨1元（1），第十天跌1元（-1）…求N天后的股票剩余价格","text":"股神Description假设买入1元股票，股票的变化规律是第一天不变（0），第二天涨1元（1），第三天跌1元（-1），第四天涨1元（1），第五天涨1元（1），第六天跌1元（-1），第七天涨1元（1），第八天涨1元（1），第九天涨1元（1），第十天跌1元（-1）…求N天后的股票剩余价格 法一12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; int n &#x3D; 0; int i &#x3D; 1; int j &#x3D; 2; int count &#x3D; 0; scanf(&quot;%d&quot;,&amp;n); while ( i + j &lt;&#x3D; n) &#123; i &#x3D; i + j; j &#x3D; j + 1; count++; &#125; printf(&quot;%d&quot;, n - 2 * count); return 0; &#125; 法二1234567891011121314151617181920#include&lt;stdio.h&gt;int main()&#123; int n &#x3D; 0; scanf(&quot;%d&quot;,&amp;n); int count &#x3D; 0; &#x2F;&#x2F;-1的总天数 int i &#x3D; 1; &#x2F;&#x2F;第i天为-1 int sum &#x3D; 0; for (; i &lt;&#x3D; n; i++) &#123; i &#x3D; 2*i + 1; count++; &#125; sum &#x3D; n - 2 * count;&#x2F; printf(&quot;%d&quot;,sum); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"习题","slug":"C-C/习题","permalink":"http://example.com/categories/C-C/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"C/C++习题","slug":"C-C-习题","permalink":"http://example.com/tags/C-C-%E4%B9%A0%E9%A2%98/"}]},{"title":"C语言例题3：求s=1+(1+2)+...+(1+2+3+...+n)","slug":"C语言例题3：求s-1-1-2-1-2-3-n","date":"2021-01-06T12:10:32.000Z","updated":"2021-01-11T10:27:44.197Z","comments":true,"path":"2021/01/06/C语言例题3：求s-1-1-2-1-2-3-n/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%983%EF%BC%9A%E6%B1%82s-1-1-2-1-2-3-n/","excerpt":"求s=1+(1+2)+(1+2+3)+…+(1+2+3+…+n)的值Description编写一个程序，求s=1+(1+2)+(1+2+3)+…+(1+2+3+…+n)的值","text":"求s=1+(1+2)+(1+2+3)+…+(1+2+3+…+n)的值Description编写一个程序，求s=1+(1+2)+(1+2+3)+…+(1+2+3+…+n)的值 123456789101112131415#include&lt;stdio.h&gt;int main()&#123; int a = 0; scanf(&quot;%d&quot;,&amp;a); int sum = 0; int j = 0; for (int i = 1; i &lt;= a; i++) &#123; j += i; sum = sum + j; &#125; printf(&quot;%d&quot;,sum); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"习题","slug":"C-C/习题","permalink":"http://example.com/categories/C-C/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"C/C++习题","slug":"C-C-习题","permalink":"http://example.com/tags/C-C-%E4%B9%A0%E9%A2%98/"}]},{"title":"C语言例题2：输出一个数的二进制有多少个1","slug":"C语言例题2：输出一个数的二进制有多少个1","date":"2021-01-06T12:03:22.000Z","updated":"2021-01-11T10:27:49.136Z","comments":true,"path":"2021/01/06/C语言例题2：输出一个数的二进制有多少个1/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%982%EF%BC%9A%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA1/","excerpt":"输出一个数的二进制有多少个1法一：依次消去二进制中的1，并计数","text":"输出一个数的二进制有多少个1法一：依次消去二进制中的1，并计数 1234567891011121314int main()&#123; int a = 0; int count = 0; scanf(&quot;&amp;d&quot;,&amp;a); while(a != 0) &#123; a = a &amp; (a - 1);//去掉二进制中倒数第一个1 count++; &#125; printf(&quot;%d&quot;,count); return 0;&#125; 法二：int整型变量有32位二进制代码，对每一位按位于1 12345678910111213int main()&#123; int a = 0; int count = 0; scanf(&quot;&amp;d&quot;,&amp;a); for( int i = 0; i &lt; 32; i++) &#123; if( 1 &lt;&lt; i &amp; a) count++; &#125; printf(&quot;%d&quot;,count); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"习题","slug":"C-C/习题","permalink":"http://example.com/categories/C-C/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"C/C++习题","slug":"C-C-习题","permalink":"http://example.com/tags/C-C-%E4%B9%A0%E9%A2%98/"}]},{"title":"C语言例题1：数值比较","slug":"C语言例题1：数值比较","date":"2021-01-06T11:55:18.000Z","updated":"2021-01-11T10:27:54.875Z","comments":true,"path":"2021/01/06/C语言例题1：数值比较/","link":"","permalink":"http://example.com/2021/01/06/C%E8%AF%AD%E8%A8%80%E4%BE%8B%E9%A2%981%EF%BC%9A%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83/","excerpt":"数值比较Description输入两个整数，输出较大的值，要求不允许使用if，&lt;，&gt;，?运算符","text":"数值比较Description输入两个整数，输出较大的值，要求不允许使用if，&lt;，&gt;，?运算符 思想 123456789#include&lt;stdio.h&gt;int main()&#123; int a = 0; int b = 0; scanf(&quot;%d %d&quot;,&amp;a,&amp;b); int f = (a - b) &gt;&gt; 31 &amp; 1; printf(&quot;%d&quot;,a - (a - b) * f); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"习题","slug":"C-C/习题","permalink":"http://example.com/categories/C-C/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"C/C++习题","slug":"C-C-习题","permalink":"http://example.com/tags/C-C-%E4%B9%A0%E9%A2%98/"}]},{"title":"设计模式笔记","slug":"设计模式笔记","date":"2021-01-06T09:17:36.000Z","updated":"2021-01-08T10:08:57.094Z","comments":true,"path":"2021/01/06/设计模式笔记/","link":"","permalink":"http://example.com/2021/01/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/","excerpt":"","text":"设计模式单例工厂简单工厂模式面向对象——活字印刷拿活字印刷举例子 可维护——可以改字 可复用——字并非只用一次，可在后来的印刷中使用 可拓展——可以加字 灵活性好——可随意排版 面向对象的好处通过封装、继承、多态把程序的耦合度降低，用设计模式使得程序更加灵活，容易修改，易于复用 封装使耦合度下降 紧耦合和松耦合代理策略模式模版方法","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"编程基础","slug":"编程基础","date":"2021-01-06T09:09:47.000Z","updated":"2021-02-22T03:28:03.419Z","comments":true,"path":"2021/01/06/编程基础/","link":"","permalink":"http://example.com/2021/01/06/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/","excerpt":"","text":"学习编程的基础四大件数据结构和算法学完之后要刷leetcode（剑指offer） 计算机网络tcp/ip协议栈（tcp/ip详解） 操作系统进程和线程并发锁内存分布调度等等 （深入理解操作系统） 设计模式单例工厂代理策略模式模版方法（大话设计模式） 实践Linux操作系统掌握《linux就该这么学》 shell编程脚本 编译/调试工具GUN官方GCC和GDB文档《debugging with gdb 》中文版《跟我一起写makefile》陈皓 Linux平台上 gccmakefile《跟我一起写makefile》 要会写 gdb调试工具 Linux系统编程《unix环境高级编程》《linux高性能服务器编程》《posix多线程程序设计》 多线程编程网络编程（unix环境高级编程）（Linux高性能服务器编程）（posix多线程程序设计）","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"}],"tags":[{"name":"学习路线","slug":"学习路线","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"}]},{"title":"C++学习笔记","slug":"C++学习笔记","date":"2021-01-06T01:45:56.000Z","updated":"2021-02-28T07:32:43.631Z","comments":true,"path":"2021/01/06/C++学习笔记/","link":"","permalink":"http://example.com/2021/01/06/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"头文件C++中头文件没有.h 常用的头文件有cstdio，string，iostream。 处理格式化输入和输出的iostream库 ​ cin标准输入 ​ cout标准输出 ​ cerr标准错误 ​ clog产生程序执行的一般信息 12345678910#include&lt;iostream&gt; //input output streamusing namespace std;int main()&#123; int a = 100; int b = 100; cout &lt;&lt; a &lt;&lt; &#x27; &#x27; &lt;&lt; b &lt;&lt; &quot;hello&quot;; //泛型 return 0;&#125; cout是一个对象&lt;&lt;是cout的成员函数 1234567891011#include&lt;iostream&gt; //input output streamusing namespace std;int main()&#123; int n = 0; int v2 = 0; cin &gt;&gt; n &gt;&gt; v2; cout &lt;&lt; n &lt;&lt; &quot; and &quot; &lt;&lt; v2 &lt;&lt; endl; return 0;&#125; 输出结果 123132 456132 and 456 endl是一个特殊值，称为操纵符，将它写入输出流时，具有输出换行的效果，并刷新与设备相关联的缓冲区。通过刷新缓冲区，用户可立即看到写入到流中的输出。 经常在调试过程中插入输出语句，这些语句都应该刷新输出流。忘记刷新输出流可能会造成输出停留在缓冲区中，如果程序崩溃，将会导致程序错误推断崩溃位置。 命名空间三种方式 1234命名空间::print();using namespace 命名空间; //谨慎使用全局函数 ::print(); 作用防止变量或函数等重名，因为标准库定义的名字是定义在命名空间中， 所以我们可以按自己的意图使用相同的名字 。有重名情况需要在重名的东西前加要使用的命名空间名字::，::称为作用域限定符 1234567891011121314151617181920212223242526#include&lt;iostream&gt; //input output streamusing namespace std;namespace my1&#123; int a = 100; void print() &#123; printf(&quot;%d&quot;,a); &#125;&#125;namespace my2&#123; int a = 100; void print() &#123; printf(&quot;%d&quot;,a); &#125;&#125;using namespace my1;int main()&#123; print(); return 0;&#125; 123456789101112131415161718192021222324252627#include&lt;iostream&gt; //input output streamusing namespace std;namespace my1&#123; int a = 100; void print() &#123; printf(&quot;%d&quot;,a); &#125;&#125;namespace my2&#123; int a = 200; void print() &#123; printf(&quot;%d&quot;,a); &#125;&#125;using namespace my1;using namespace my2;int main()&#123; my1::print(); return 0;&#125; 全局函数与命名空间内函数重名1234567891011121314151617181920#include&lt;iostream&gt; //input output streamusing namespace std;namespace my1&#123; int a = 100; void print() &#123; printf(&quot;%d&quot;,a); &#125;&#125;void print()&#123; printf(&quot;%d&quot;,200);&#125;using namespace my1;int main()&#123; ::print(); //单写::就是使用全局空间 return 0;&#125; 新增变量类型bool只占一个字节 可以等于True或False 本质上时对char的封装 1bool b = false; 宽字符wchar_t1typedef short in wchar_t; 引用类型引用就是对象的另一个名字 特点※ 引用被创建的同时必须被初始化。（指针则可以在任何时候被初始化）。 不能有NULL引用，引用应该必须与合法的存储单元关联（指针则可以是NULL）。 一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。 本质上是对指针的封装 123int n = 100;int &amp;j = n; //j就是n，是同一个变量cout &lt;&lt; &amp;j &lt;&lt; &quot; &quot; &lt;&lt; &amp;n; 输出结果 10x61fe14 0x61fe14 j就是n，n就是j 例子交换两个变量 123456789101112void swap(int &amp;a, int &amp;b) &#123; //a,b和传入的参数是同一个变量 int t = a; a = b; b = t;&#125;int main() &#123; int a = 10; int b = 20; swap(a,b); cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; endl; return 0;&#125; 输出结果 120 10 强弱类型12345678int main()&#123; int n = 100; int x = 200; char *p = &amp;x;//这句话不合法，类型必须相同 char *q = (char *)malloc(sizeof(int));//这句合法，因为所有32位下的指针类型都是4个字节 return 0;&#125; 函数重载 相同声明域（都在全局或都在一个类下）函数名字相同但是参数列表不同（类型和个数不完全相同）。 只有返回值类型不同不算重载函数。 函数传入的参数必须能够被明确是调用的哪个函数。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;void func_1() &#123; cout &lt;&lt; &#x27;1&#x27; &lt;&lt; endl;&#125;void func_1(int a) &#123; cout &lt;&lt; a &lt;&lt; endl;&#125;void func_1(double b) &#123; cout &lt;&lt; b &lt;&lt; endl;&#125;void func_1(int&amp; c) &#123; cout &lt;&lt; c &lt;&lt; endl;&#125;void func_2() &#123; cout &lt;&lt; &#x27;2&#x27; &lt;&lt; endl;&#125;void func_2(int) &#123;//函数参数起不起名都行，如果函数内需要用到这个参数就需要起名。 cout &lt;&lt; &#x27;3&#x27; &lt;&lt; endl;&#125;int main() &#123; func_1(); //既有func_1(int&amp; c),还有func_1(int b)编译器不能明确调用的是哪个函数然后报错。 //func_1(12); //func_1(int&amp; c)引用类型是引用的变量，12是常量。 func_1(15.6); func_2(); func_2(12); return 0;&#125; 输出结果 12345611215.623 函数参数默认值 c++可以从后向前的设置参数的默认值(缺省值) 不能定义相同的函数，参数不同算不同的函数 调用函数时，必须能明确调用的是哪个函数 123456789101112131415161718#include&lt;iostream&gt;using namespace std;void func(int a, int b, int c, int d = 24) &#123; cout &lt;&lt; 1 &lt;&lt; endl;&#125;void func(int a, int b, int c = 10) &#123; cout &lt;&lt; 2 &lt;&lt; endl;&#125;void func(int a, int b = 12) &#123; cout &lt;&lt; 3 &lt;&lt; endl;&#125;int main() &#123; //func(12,35,56);//会报错，多个函数匹配传入的参数 func(12); return 0;&#125; 输出结果 123 函数指针 函数指针是指指向函数而非指向对象的指针。 函数类型由其返回类型以及形参表确定， 而与函数名无关关。 bool (*pf) (const string &amp;, const string &amp;);这句话将 pf 声明为指向函数的指针，它所指向的函数带有两个 const string&amp; 类型的形参和 bool 类型的返回值。 函数指针就是4个字节的小指针，不是对象 使用typedef简化函数指针的定义 typedef bool (*pf) (const string &amp;, const string &amp;); 这句话表示pf是一种指向函数的指针类型的名字。该指针类型为指向返回bool 类型并带有两个const string &amp;形参的函数的指针。在要使用这种函数指针类型时，只需直接使用pf即可，不必每次都把整个类型声明全部写出来。 函数指针赋值和初始化 函数指针只能通过同类型的函数或函数指针或 0 值常量表达式进行初始化或赋值。 将函数指针初始化为 0，表示该指针不指向任何函数。 指向不同函数类型的指针之间不存在转换。 通过函数指针调用函数 指向函数的指针可用于调用它所指向的函数。可直接通过指针调用函数。 函数指针作为形参 有两种写法 void useBigger(const string &amp;, const string &amp;,bool(const string &amp;, const string &amp;)); void useBigger(const string &amp;, const string &amp;,bool (*)(const string &amp;, const string &amp;));函数指针作为返回值 有两种写法 int (*ff(int)) (int *, int); 从内向外读，先看ff(int)，将ff声明为一个带有int形参的函数。 ff(int)的返回值是int (*) (int *, int) int (*) (int *, int)是一个返回值为int，并带有两个分别为int*和int的形参 先声明函数指针，再将函数指针作为返回值 12typedef int (*PF) (int *, int);PF ff(int); 允许将形参定义为函数类型，但函数的返回类型则必须是指向函数的指针，而不能是函数。 具有函数类型的形参所对应的实参将被自动转换为指向相应函数类型的指针。但是，当返回的是函数时，同样的转换操作则无法实现。 指向重载函数的函数指针 C++ 语言允许使用函数指针指向重载的函数： 123void ff(vector&lt;double&gt;);void ff(unsigned int);void (*pf1)(unsigned int) = &amp;ff; 指针的类型必须与重载函数的一个版本精确匹配。如果没有精确匹配的函数，则对该指针的初始化或赋值都将导致编译错误。 成员函数的函数指针 需要加上作用域 123456789101112131415161718class ND &#123;public: void run() &#123; this; &#125; static void sr() &#123; cout &lt;&lt; &quot;调用静态成员函数&quot; &lt;&lt; endl; &#125;&#125;void memberFunctionPointer() &#123; void (ND::*p)() = &amp;ND::run; void (*f)() = &amp;ND::sr;//静态成员函数，就可以用全局函数的函数指针指向 ND n; ND* pn = &amp;n; (n.*p)();//调用成员函数指针,方法一 (pn-&gt;*f)();//调用成员函数指针，方法二&#125; 类类与结构体区别class与struct在编译过程基本没有区别，只有缺省权限不同，class是私有，struct是共有。 成员成员变量与成员函数也称为属性和方法 书写格式类是抽象的，对象是实例 概念 描述 类成员函数 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 类访问修饰符 类成员可以被定义为public、private或 protected。默认情况下是定义为private。 构造函数&amp;析构函数 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。 拷贝构造函数 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 友元函数 友元函数可以访问类的private和protected成员。 内联函数 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。 this指针 每个对象都有一个特殊的指针this，它指向对象本身。 指向类的指针 指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。 静态成员 类的数据成员和函数成员都可以被声明为静态的。 访问修饰符 与结构体不同，类必须写访问修饰符public或private或protected。 缺省情况下默认是private，结构体默认是public。 私有成员变量不允许通过对象进行访问，但可以被共有成员函数访问。 访问修饰符 作用 public 公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值 private 私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。 protected protected（受保护）成员变量或函数与私有成员十分相似，但有一点不同，protected（受保护）成员在派生类（即子类）中是可访问的。 12345678910111213#include&lt;iostream&gt;using namespace std;class People&#123;public: int age; &#125;;int main()&#123; People p; p.age = 10; return 0;&#125; 属性（成员变量）下面的代码中People是类，p是对象 age、weight、sex、name是属性（成员变量） 12345678910111213141516#include&lt;iostream&gt;using namespace std;class People&#123;public: int age; int weight; int sex; char name[12];&#125;;int main()&#123; People p; p.age = 10; return 0;&#125; 方法（成员函数）私有成员变量不允许通过对象进行访问，但可以被公有成员函数访问。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;class People&#123;private: int age = 0; int weight; int sex; char name[12];public: int getAge() &#123; return age; &#125; void setAge() &#123; age++; &#125;&#125;;int main()&#123; People p; //p.age = 10; p.setAge(); int age = p.getAge(); cout &lt;&lt; age &lt;&lt; endl; return 0;&#125; 输出结果 121 成员函数可以定义在类定义内部，或者单独使用范围解析运算符 ::来定义。 thisthis代表调用当前函数的对象的地址 构造函数 构造函数是类的一种特殊成员函数，一般情况下，构造函数是专门用于初始化成员变量的，所以最好不要在构造函数中进行与对象的初始化无关的操作 构造函数的函数名一定与类的名称完全相同，而且没有返回值（不是说返回值是void或者int，而是说不允许指定返回值） 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;class People&#123;private: int age; int weight;public: //成员函数声明 People() //无参构造函数 &#123; age = 1; &#125; People(int w)//构造函数可以重载 &#123; weight = w; &#125; int getAge(); int getWeight();&#125;;//成员函数定义int People::getAge() &#123; return age;&#125;int People::getWeight() &#123; return weight;&#125;int main()&#123; People p;//创建对象时会运行构造函数,p是通过People()出生的 People xx(8);//xx是通过People(int w)出生的 //p.age = 10; cout &lt;&lt; p.getAge() &lt;&lt; &quot; &quot; &lt;&lt; xx.getWeight() &lt;&lt; endl; return 0;&#125; 输出结果 121 8 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;class People&#123;private: int age; int weight;public: //成员函数声明 People(int weight) &#123; age = 1; this-&gt;weight = weight; &#125; int getWeight();&#125;;//成员函数定义int People::getWeight() &#123; return weight;&#125;int main()&#123; People p(8); cout &lt;&lt; p.getWeight() &lt;&lt; endl; return 0;&#125; 输出结果 128 析构函数 只要是对象的生命期结束时，会自动启用析构函数。 析构函数不能重载。 ~类名 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class People&#123;private: int age; int weight; char *name;public: People() &#123; name = (char *)malloc(100); strcpy(name,&quot;123456&quot;); &#125; ~People()//不能重载 &#123; free(name); &#125;&#125;;int main()&#123; People p; return 0;&#125; 初始化列表 赋值先后顺序与书写顺序无关 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class People&#123;private: int age; int weight; char *name;public: People() : age(0),weight(8),name(NULL) &#123; name = (char *)malloc(100); strcpy(name,&quot;123456&quot;); &#125; ~People()//不能重载 &#123; free(name); &#125;&#125;;int main()&#123; People p; return 0;&#125; 拷贝构造函数※拷贝构造函数是特殊的成员函数 调用时机1. 通过使用另一个同类型的对象来初始化新创建的对象1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class People&#123;private: int age; int weight; char *name;public: //成员函数声明 People() &#123; &#125; People(const People&amp; p)//拷贝构造函数 &#123; this-&gt;age = p.age; &#125; void setAge(int age); int getAge();&#125;;//成员函数定义void People::setAge(int age) &#123; this-&gt;age = age;&#125;int People::getAge() &#123; return age;&#125;int main()&#123; People p1; p1.setAge(10); cout &lt;&lt; p1.getAge() &lt;&lt; endl; People p2(p1); cout &lt;&lt; p2.getAge() &lt;&lt; endl; return 0;&#125; 输出结果 1231010 2. 复制对象把它作为参数传递给函数12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class People&#123;private: int age; int weight; char *name;public: People() &#123; &#125; People(const People&amp; p)//拷贝构造函数 &#123; this-&gt;age = p.age; cout &lt;&lt; &quot;拷贝&quot; &lt;&lt; endl; &#125; ~People() &#123; cout &lt;&lt; &quot;game over&quot; &lt;&lt; endl; &#125; void setAge(int age); int getAge();&#125;;void People::setAge(int age) &#123; this-&gt;age = age;&#125;int People::getAge() &#123; return age;&#125;void printPeople(People p)&#123; cout &lt;&lt; p.getAge() &lt;&lt; endl;&#125;int main()&#123; People p; p.setAge(10); printPeople(p); return 0;&#125; 输出结果 12345拷贝10game overgame over 创建出了两个对象 主函数构造一个 printPeople构造一个 先输出的是printPeople的析构函数 后输出的是主函数的析构函数 3. 复制对象，并从函数返回这个对象1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class People&#123;private: int age; int weight; char *name;public: People() &#123; &#125; People(const People&amp; p)//拷贝构造函数 &#123; this-&gt;age = p.age; cout &lt;&lt; &quot;拷贝&quot; &lt;&lt; endl; &#125; ~People() &#123; cout &lt;&lt; &quot;game over&quot; &lt;&lt; endl; &#125; void setAge(int age); int getAge();&#125;;void People::setAge(int age) &#123; this-&gt;age = age;&#125;int People::getAge() &#123; return age;&#125;People printPeople(People p)&#123; return p;&#125;int main()&#123; People p; p.setAge(10); People t = printPeople(p); cout &lt;&lt; t.getAge() &lt;&lt; endl; return 0;&#125; 输出结果 1234567拷贝拷贝game over10game overgame over 第一个拷贝是printPeople(p)传入参数时拷贝构造函数输出的 第二个拷贝是将printPeople(p)返回值赋值给t时拷贝构造函数输出的 第一个game over是printPeople传入参数创造出的对象结束时输出的 第二个是t结束时输出的 第三个是p结束时输出的 浅拷贝123456789101112131415161718192021222324252627282930using namespace std;class Student &#123; char* name;public: Student() &#123; &#125; Student(const char* name) &#123; this-&gt;name = (char *)malloc(12); strcpy(this-&gt;name, name); cout &lt;&lt; name &lt;&lt; endl; &#125; Student(const Student &amp;rgh) &#123;//默认拷贝构造函数 this-&gt;name = rgh.name; &#125; ~Student() &#123; free(this-&gt;name); &#125; char* get_name();&#125;;char* Student::get_name() &#123; return name;&#125;int main() &#123; Student stu(&quot;abc&quot;); Student ss(stu); cout &lt;&lt; stu.get_name() &lt;&lt; endl;&#125; 输出异常。空间被释放了两次。 深拷贝12345678910111213141516171819202122232425262728293031using namespace std;class Student &#123; char* name;public: Student() &#123; &#125; Student(const char* name) &#123; this-&gt;name = (char *)malloc(12); strcpy(this-&gt;name, name); cout &lt;&lt; name &lt;&lt; endl; &#125; Student(const Student &amp;rgh) &#123;//默认拷贝构造函数 this-&gt;name = (char* )malloc(12); strcpy(this-&gt;name,name); &#125; ~Student() &#123; free(this-&gt;name); &#125; char* get_name();&#125;;char* Student::get_name() &#123; return name;&#125;int main() &#123; Student stu(&quot;abc&quot;); Student ss(stu); cout &lt;&lt; stu.get_name() &lt;&lt; endl;&#125; 输出结果 12abcabc 防止使用拷贝构造函数拷贝函数私有化。 12private: Student(const Student &amp;rgh); 为什么参数是引用类型防止循环拷贝进入死循环。 友元函数 类的友元函数是定义在类外部，但有权访问类的所有私有private成员和保护protected成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。 友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。 如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend。 一般情况下不使用，会破坏封装性 主函数也可以设成友元函数 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;class People&#123;private: int age;public: //成员函数声明 void setAge(int age); //友元函数声明 friend int getAge(People p);&#125;;//成员函数定义void People::setAge(int age) &#123; this-&gt;age = age;&#125;//友元函数定义int getAge(People p) &#123; return p.age;&#125;int main() &#123; People p; p.setAge(20); int age = getAge(p); cout &lt;&lt; age &lt;&lt; endl;&#125; 注意：printWidth() 不是任何类的成员函数 输出结果 1220 友元类1234567891011class People &#123; int age; frined class Animal;&#125;;class Animal &#123;public: void printAge(People&amp; p);&#125;;void Animal::printAge(People&amp; p) &#123; cout &lt;&lt; p.age &lt;&lt; endl;&#125; 静态成员变量/函数 静态成员变量必须在类外初始化 不能在类中使用 静态成员是属于类的，不是对象的 可以不通过对象访问，可以直接通过类访问 静态成员函数只能访问静态成员变量 因为静态成员函数属于类，故没有this。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;class People &#123;public: int age; static int water; //静态成员变量 void drink(); static void drink_2(); //静态成员函数&#125;;int People::water = 100;void People::drink() &#123; water--;&#125;void People::drink_2() &#123; //age = 100; water--;&#125;int main() &#123; People p1; p1.drink(); cout &lt;&lt; p1.water &lt;&lt; endl; People p2; p2.drink(); cout &lt;&lt; p2.water &lt;&lt; endl; cout &lt;&lt; People::water &lt;&lt; endl; //这种形式多为静态成员 People::drink_2(); cout &lt;&lt; p1.water &lt;&lt; endl; return 0;&#125; 输出结果 1234599989897 如果想通过静态成员函数访问非静态成员变量需要设置参数 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;class People &#123;public: int age; static int water; //两种传参方法 static void setAge(People* p, int age); static void setAge_2(People&amp; p, int age);&#125;;int People::water = 100;void People::setAge(People* p, int age) &#123; p-&gt;age = age;&#125;void People::setAge_2(People&amp; p, int age) &#123; p.age = age;&#125;int main() &#123; People p; p.setAge(&amp;p, 10); cout &lt;&lt; p.age &lt;&lt; endl; p.setAge_2(p, 20); cout &lt;&lt; p.age &lt;&lt; endl; return 0;&#125; 输出结果 1231020 嵌套类/内部类12345678910111213class People &#123;public: class babe &#123; public: int age; &#125;; babe b;&#125;;int main()&#123; People::babe b; b.age = 1; return 0;&#125; 内联函数 C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。 对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。 如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。 在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。 析构函数不能是内联函数 内联函数可以看作是宏函数 内联函数应尽可能短小 作用是效率高 1234567class People &#123; int age;public: inline void printAge() &#123; cout &lt;&lt; age &lt;&lt; endl; &#125;&#125;; 既然宏函数和内联函数效率高为什么不把所有函数都设成宏函数 宏多，编译时间长 常函数1234567class People &#123; int age;public: int getAge() const &#123; //不可修改类成员变量 return age; &#125;&#125;; 封装作用防止数据被随意修改 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;class Student &#123; int age; int score; int weight;public: void setAge(int age); int getAge();&#125;;void Student::setAge(int age) &#123; this-&gt;age = age;&#125;int Student::getAge() &#123; return age;&#125;int main() &#123; Student stu; stu.setAge(10); cout &lt;&lt; stu.getAge() &lt;&lt; endl;&#125; 输出结果 1210 继承 继承允许我们依据另一个类来定义一个类，达到了重用代码功能和提高执行效率的效果。 当创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。 继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。 定义派生类可以从多个基类继承数据和函数,使用一个类派生列表来指定基类 1class derived-class: access-specifier base-class 访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;using namespace std;//基类——人class People&#123;private: int age; int weight;public: //成员函数声明 void setAge(int age); void setWeight(int weight); int getAge(); int getWeight();&#125;;//成员函数定义void People::setAge(int age) &#123; this-&gt;age = age;&#125;void People::setWeight(int weight) &#123; this-&gt;weight = weight;&#125;int People::getAge() &#123; return age;&#125;int People::getWeight() &#123; return weight;&#125;//人的派生类——学生class Student :public People&#123;private: int number;public: //成员函数声明 void setNumber(int number); int getNumber();&#125;;//成员函数定义void Student::setNumber(int number) &#123; this-&gt;number = number;&#125;int Student::getNumber() &#123; return number;&#125;int main() &#123; Student s; s.setAge(20); int age = s.getAge(); cout &lt;&lt; age &lt;&lt; endl;&#125; 输出结果 1220 有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。 1.public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private 2.protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private 3.private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private 但无论哪种继承方式，上面两点都没有改变： 1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问； 2.protected 成员可以被派生类访问。 继承方式/基类成员 public成员 protected成员 private成员 public继承 public protected 不可见 protected继承 protected protected 不可见 private继承 private private 不可见 函数隐藏 如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名（只要函数名相同），那么就会隐藏从基类继承过来的成员。就是在派生类中使用该成员，实际上使用的是派生类新增的成员，而不是从基类继承的。 使用基类的成员函数。 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;//基类——人class People&#123;private: int age;public: //成员函数声明 int getAge();&#125;;//成员函数定义int People::getAge() &#123; cout &lt;&lt; &quot;People&quot; &lt;&lt; endl; return 0;&#125;//人的派生类——学生class Student: public People&#123;public: //成员函数声明 int getAge();&#125;;//成员函数定义int Student::getAge() &#123; cout &lt;&lt; &quot;student&quot; &lt;&lt; endl; return 0;&#125;int main() &#123; Student s; s.getAge();&#125; 输出结果 1student 若想使用People类的getAge()则主函数中s.getAge();应改为s.People::getAge(); 基类和派生类的构造析构顺序12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;class People &#123;public: People() &#123; cout &lt;&lt; &quot;people&quot; &lt;&lt; endl; &#125; ~People() &#123; cout &lt;&lt; &quot;~people&quot; &lt;&lt; endl; &#125;&#125;;class Student : public People&#123;public: Student() &#123; cout &lt;&lt; &quot;Student&quot; &lt;&lt; endl; &#125; ~Student() &#123; cout &lt;&lt; &quot;~Student&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; Student stu; return 0;&#125; 输出结果 12345peoplestudent~student~people 多继承类轻易不用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;using namespace std;//基类——人class People&#123;private: int age; int weight;public: //成员函数声明 void setAge(int age); void setWeight(int weight); int getAge(); int getWeight();&#125;;//成员函数定义void People::setAge(int age) &#123; this-&gt;age = age;&#125;void People::setWeight(int weight) &#123; this-&gt;weight = weight;&#125;int People::getAge() &#123; return age;&#125;int People::getWeight() &#123; return weight;&#125;//基类——动物class Animal&#123;public: //成员函数声明 void eat();&#125;;//成员函数定义void Animal::eat() &#123; cout &lt;&lt; &quot;吃 吃 吃&quot; &lt;&lt; endl;&#125;//人的派生类——学生class Student: public People,public Animal&#123;private: int number;public: //成员函数声明 void setNumber(int number); int getNumber();&#125;;//成员函数定义void Student::setNumber(int number) &#123; this-&gt;number = number;&#125;int Student::getNumber() &#123; return number;&#125;int main() &#123; Student s; s.setAge(20); int age = s.getAge(); cout &lt;&lt; age &lt;&lt; endl; s.eat();&#125; 输出结果 12320吃 吃 吃 虚继承 为什么存在 现象:假如我们有类A是父类，类B和类C继承了类A，而类D既继承类B又继承类C(这种菱形继承关系)。当我们实例化D的对象的时候，每个D的实例化对象中都有了两·份完全相同的A的数据。因为保留多份数据成员的拷贝，不仅占用较多的存储空间，还增加了访问这些成员时的困难，容易出错，而实际上，我们并不需要有多份拷贝。 解决方法1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;//基类——人class People &#123; //抽象类public: int age; //成员函数声明 void doWork() &#123; cout &lt;&lt; &quot;吃饭 睡觉&quot; &lt;&lt; endl; &#125;&#125;;class Worker : virtual public People &#123;&#125;;class Farmer : virtual public People &#123;&#125;;class MigrantWorker : virtual public Worker, virtual public Farmer &#123;&#125;;int main() &#123; MigrantWorker m; m.age = 10; //虚继承解决访问不明确的问题 return 0;&#125; new和malloc的区别 new/delete是C++运算符，需要编译器支持。malloc/free是库函数，需要头文件支持。 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。 new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void ，需要通过强制类型转换将void指针转换成我们需要的类型。 new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。 new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现)。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存(通常底层使用free实现)。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。 123456789101112int main() &#123; int* a = (int *)malloc(4); free(a); int* b = new int; delete b; int* c = new int[10]; delete[]c; return 0;&#125; 1234567891011121314151617181920class People&#123; int age;public: //成员函数声明 People() &#123; cout &lt;&lt; &quot;people&quot; &lt;&lt; endl; &#125; ~People() &#123; cout &lt;&lt; &quot;~people&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; People *p = (People *)malloc(sizeof(People)); free(p); People *n = new People; delete n; return 0;&#125; 输出结果 123people~people 虚析构常常把析构函数设置成虚函数 什么要加虚析构？如果不是虚析构，子类析构不会运行，有可能发生内存泄漏 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;//基类——人class People &#123; //抽象类 int age;public: //成员函数声明 People() &#123; cout &lt;&lt; &quot;people&quot; &lt;&lt; endl; &#125; //如果不是虚析构，子类析构不会运行。,有可能发生内存泄漏 virtual ~People() &#123; cout &lt;&lt; &quot;~people&quot; &lt;&lt; endl; &#125;&#125;;//人的派生类——学生class Student : public People &#123;public: virtual void play() &#123; cout &lt;&lt; &quot;打游戏&quot; &lt;&lt; endl; &#125; ~Student() &#123; cout &lt;&lt; &quot;~student&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; People *p = new Student; delete p; cout &lt;&lt; sizeof(People) &lt;&lt; endl; return 0;&#125; 输出结果 12345people~student~people8 为什么默认的析构函数不是虚析构？虚函数会在类中产生一个虚指针，浪费空间 类一个变量没有时sizeof()得1，用来占位。 类的大小和结构体一样，字节对齐。虚指针也占空间。 vs里默认32位。 纯虚函数 纯虚函数即虚函数等于0 包含纯虚函数的类是抽象类，抽象类不允许实例化 子类如果不重写父类的纯虚函数，那么这个子类也是抽象类 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;//基类——人class People &#123; //抽象类 int age;public: //成员函数声明 virtual void play() = 0; //纯虚函数&#125;;//人的派生类——学生class Student : public People &#123;public: virtual void play() &#123; cout &lt;&lt; &quot;打游戏&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; //People p; //不允许实例化 Student s; return 0;&#125; 多态多态的实现在满足函数重写/函数覆盖的条件下，父类指针指向子类对象，调用子类成员函数。 函数重写/函数覆盖通过虚函数实现函数覆盖 父类定义虚函数 子类实现虚函数功能 函数隐藏：指针变量类型是谁就调用谁的成员函数 函数覆盖：函数重写 new谁调用谁的成员函数 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;//基类——人class People &#123; int age;public: //成员函数声明 void eat() &#123; cout &lt;&lt; &quot;eat&quot; &lt;&lt; endl; &#125; virtual void play() &#123; cout &lt;&lt; &quot;play&quot; &lt;&lt; endl; &#125;&#125;;//人的派生类——学生class Student: public People &#123;public: void eat() &#123; cout &lt;&lt; &quot;eat meat&quot; &lt;&lt; endl; &#125; virtual void play() &#123; cout &lt;&lt; &quot;打游戏&quot; &lt;&lt; endl; &#125;&#125;;int main() &#123; People *p = new Student; p-&gt;eat; //函数隐藏 p-&gt;play(); //函数覆盖/函数重写 delete p; return 0;&#125; 输出结果 123eat打游戏 重载操作符※ 类外重载需两个参数，重复的话优先类内的 操作符函数参数数量和操作数数量相同，类内有this指针作为其中一个参数，类外没有this指针所以需要自己往函数里传参。 不允许重载的运算符：. * :: sizeof ?: 必须放在类内重载的运算符：() &#123;&#125; - &gt; = 当对象创建完之后再=才调用重载操作符函数，否则调用拷贝构造函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;using namespace std;class People &#123; int age;public: People(int a) &#123; age = a; &#125; People() &#123; age = 1; &#125; //=运算符重载(默认产生) People&amp; operator=(const People&amp; aa) &#123; this-&gt;age = aa.age; return *this; //eg:p3 = p2 = p1 //返回引用类型是因为，如果不是引用类型会运行拷贝构造函数， //即拷贝构造函数第三种调用时机， &#125; void operator=(const char* str) &#123; //c++中char*表示字符串必须加const cout &lt;&lt; str &lt;&lt; endl; //引用可加可不加，看需求 &#125; void operator+=(const People&amp; aa) &#123; this-&gt;age += aa.age; &#125; void operator++() &#123; //++p &#125; void operator++(int) &#123; //p++ &#125; int getAge();&#125;;int People::getAge() &#123; return age;&#125;void operator+=(People&amp; aa, int n) &#123;&#125;int main() &#123; People p1 = 10; //重载构造函数,相当于构造函数 People p2; //需要有一个无参的构造函数 People p3; p2 = p1; //&lt;===&gt; p2.operator=(p1); p3 = p2 = p1; //p2 = p1的返回值是p2 cout &lt;&lt; p2.getAge() &lt;&lt; endl; p3 = 20; //先People p = 20; 再p3.operator=(p); 即新创建了一个对象 p3 = &quot;你好&quot;; //函数重载 p2 += p1; return 0;&#125; 字符串 C++中操作字符串的头文件是cstring C++编译器会在初始化数组时，自动把 \\0放在字符串的末尾。 函数 目的 strcpy(s1,s2) 复制字符串 s2 到字符串 s1。 strcat(s1,s2) 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 + 号。 strlen(s1) 返回字符串 s1 的长度。 strcmp(s1,s2) 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。 strchr(s1,ch) 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 strstr(s1,s2) 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 String类 常用操作 s.empty() 如果 s 为空串，则返回 true，否则返回 false。 s.size() 返回 s 中字符的个数 s[n] 返回 s 中位置为 n 的字符，位置从 0 开始计数 s1 + s2 把 s1 和 s2 连接成一个新字符串， 返回新生成的字符串（+=也可以） s1 = s2 把 s1 内容替换为 s2 的副本 v1 == v2 比较 v1 与 v2 的内容，相等则返回 true，否则返 回 false !=, &lt;, &lt;=, &gt;, and &gt;= 保持这些操作符惯有的含义 实例12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; int main ()&#123; string str1 = &quot;runoob&quot;; string str2 = &quot;google&quot;; string str3; int len ; // 复制 str1 到 str3 str3 = str1; cout &lt;&lt; &quot;str3 : &quot; &lt;&lt; str3 &lt;&lt; endl; // 连接 str1 和 str2 str3 = str1 + str2; cout &lt;&lt; &quot;str1 + str2 : &quot; &lt;&lt; str3 &lt;&lt; endl; // 连接后，str3 的总长度 len = str3.size(); cout &lt;&lt; &quot;str3.size() : &quot; &lt;&lt; len &lt;&lt; endl; //打印str3第三个元素 cout &lt;&lt; str3[2] &lt;&lt; endl; return 0;&#125; 重写string类mystring.h文件123456789101112131415#pragma once#include&lt;iostream&gt;class mystring &#123;private: char * my_data;public: mystring(const char * str = 0); //通用构造函数 mystring(const mystring &amp; another); //拷贝构造函数 ~mystring(); //析构函数 mystring &amp; operator=(const mystring &amp; mys); //赋值函数 mystring operator+(const mystring &amp; mys); //重载操作符+ friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const mystring &amp; mys);&#125;;std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const mystring &amp; mys); mystring.cpp文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &quot;mystring.h&quot;#include&lt;string.h&gt;//new char(0);//申请了一个空间，与[]不同//构造函数mystring::mystring(const char * str) &#123; if (str == 0) &#123; my_data = new char(0); &#125; else &#123; my_data = new char[strlen(str) + 1]; strcpy(this-&gt;my_data, str); &#125;&#125;//拷贝构造函数mystring::mystring(const mystring &amp; another) &#123; this-&gt;my_data = new char[strlen(another.my_data) + 1]; strcpy(this-&gt;my_data, another.my_data);&#125;//析构函数mystring::~mystring() &#123; delete[]my_data;&#125;//重载操作符=mystring &amp; mystring::operator=(const mystring &amp; mys) &#123; delete[]this-&gt;my_data; this-&gt;my_data = new char[strlen(mys.my_data) + 1]; strcpy(this-&gt;my_data, mys.my_data); return *this;&#125;//重载操作符+mystring mystring::operator+(const mystring &amp; mys) &#123; mystring mys2; char * str = new char[strlen(this-&gt;my_data) + strlen(mys.my_data) + 1]; strcpy(str, this-&gt;my_data); strcpy(str + strlen(this-&gt;my_data), mys.my_data); delete[]mys2.my_data; //mys2构造时会创建一块空间，如果直接赋值，那块空间就丢了，会导致内存泄漏 mys2.my_data = str; return mys2;&#125;std::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const mystring &amp; mys)&#123; os &lt;&lt; mys.my_data; return os;&#125; main.cpp文件1234567891011121314151617#include&lt;iostream&gt;#include&quot;mystring.h&quot;using namespace std;int main() &#123; mystring str1 = &quot;123asd&quot;; mystring str2 = str1; mystring str3; mystring str4(str1); str3 = str2 = str1; cout &lt;&lt; str3 &lt;&lt; &#x27; &#x27; &lt;&lt; str4 &lt;&lt; endl;//这一步需要对&lt;&lt;函数进行函数重载 str3 = str2 + str1; cout &lt;&lt; str3 &lt;&lt; endl; return 0;&#125; 输出结果 123123asd 123asd123asd123asd 模板模板函数1template(模板)&lt;class/typename name&gt; 在模板函数定义中typename和class作用相同。 1234567891011121314151617181920#include&lt;iostream&gt;#include&quot;mystring.h&quot;using namespace std;template&lt;class T&gt; void add(T a, T b) &#123; cout &lt;&lt; a + b &lt;&lt; endl;&#125; //template(模板)&lt;class/typename name&gt; T就是一个泛型template&lt;class T,class H&gt; void add1(T a, H b) &#123; //参数类型可以不同也可以相同 cout &lt;&lt; a + b &lt;&lt; endl;&#125; //泛型编程int main() &#123; mystring str1 = &quot;123456&quot;; mystring str2 = &quot;asdqwe&quot;; add(10, 20); add(15.1, 61.8); add(str1, str2); add1(10, 35.99); add1(10, 30); return 0;&#125; 输出结果 1234563076.9123456asdqwe45.9940 模板类1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;string&gt;#include&quot;mystring.h&quot;using namespace std;template&lt;class Type&gt; class List &#123; Type val; List* next;public: List(Type v) &#123; this-&gt;val = v; &#125;&#125;;int main() &#123; List&lt;int&gt; L(32); //要加&lt;&gt;，声明Type的类型 List&lt;double&gt; L(15.5); return 0;&#125; list容器 123456789101112131415#include&lt;iostream&gt;#include&lt;list&gt;using namespace std;int main() &#123; list&lt;int&gt; lis; list&lt;double&gt; lss; lis.push_back(10); //将10放在链表最后 lis.push_front(20); //将20放在链表前面 lis.pop_back(); //删除最后一个节点 lis.pop_front(); //删除第一个节点 cout &lt;&lt; lis.size() &lt;&lt; endl; return 0;&#125; STL迭代器1容器名&lt;元素类型&gt;::iterator it = values.begin(); list容器 实际上就是个双链表。 使用时需包含头文件#include&lt;list&gt; list类定义在std中，是个class template 创建一个有n个元素的list，每个元素的值都是相应类型的默认值。 1std::list&lt;elemtype&gt; values(n); 创建一个自定义的list。 1std::list&lt;int&gt; a1&#123; 1,2,3,4,5 &#125;; 创建一个有n个值为10的list。 1std::list&lt;int&gt; values(n,10); 拷贝其他list创建新的list，保证新旧容器元素类型一样 12std::list&lt;int&gt; values(10);std::list&lt;int&gt; values2(values); 拷贝其他类型容器中指定区域内的元素，eg:数组。 12int c[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;std::list&lt;int&gt; values(c,c+10); 用迭代器遍历list123456789101112#include&lt;iostream&gt;#include&lt;list&gt;int main() &#123; int c[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;; std::list&lt;int&gt; values(c,c+10); for (std::list&lt;int&gt;::iterator it = values.begin(); it != values.end(); it++) &#123; std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; std::cout &lt;&lt; std::endl; return 0;&#125; 输出结果 121 2 3 4 5 6 7 8 9 10 vector容器定义sort规则123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;struct Node&#123; int num; int score; Node(int n, int s) &#123; num = n; score = s; &#125;&#125;;//定义比较规则：按分数降序，当分数相同时，学号小的在前static bool Comp(const Node &amp;a, const Node &amp;b) &#123; return a.score &gt; b.score || a.score == b.score &amp;&amp; a.num &lt; b.num;&#125;int main() &#123; vector&lt;Node&gt; v; v.push_back(Node(1, 45)); v.push_back(Node(2, 67)); v.push_back(Node(3, 49)); v.push_back(Node(4, 79)); v.push_back(Node(5, 86)); v.push_back(Node(6, 13)); v.push_back(Node(7, 46)); v.push_back(Node(8, 86)); v.push_back(Node(9, 47)); sort(v.begin(), v.end(), Comp); //二维数组排序默认以第0列开始排 for (vector&lt;Node&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; it-&gt;num &lt;&lt; &#x27; &#x27; &lt;&lt; it-&gt;score &lt;&lt; endl; &#125; return 0;&#125; 输出结果 123456789105 868 864 792 673 499 477 461 456 13 map容器map初始化 1map&lt;type1, type2&gt; mp; map遍历123456789101112char firstUniqChar(string s) &#123; map&lt;char, int&gt; mp; for (int i = 0; i &lt; len; i++) &#123; mp[s[i]]++; &#125; for (map&lt;char, int&gt;::iterator it = mp.begin(); it != mp.end(); it++) &#123; if (it-&gt;second == 1) &#123; return it-&gt;first; &#125; &#125; return &#x27; &#x27;;&#125; 优先级队列123456789101112131415int main() &#123; //优先级队列，默认将数据调整成最大堆 priority_queue&lt;int&gt; pq; pq.push(3); pq.push(9); pq.push(8); pq.push(2); pq.push(1); while (!pq.empty()) &#123; cout &lt;&lt; pq.top() &lt;&lt; endl; pq.pop(); &#125; return 0;&#125; 123456789101112131415int main() &#123; //优先级队列，最小堆 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq; pq.push(3); pq.push(9); pq.push(8); pq.push(2); pq.push(1); while (!pq.empty()) &#123; cout &lt;&lt; pq.top() &lt;&lt; endl; pq.pop(); &#125; return 0;&#125; auto自动识别类型，增强for循环 123for (auto val : res)&#123; cout &lt;&lt; vall &lt;&lt; &quot; &quot;;&#125; C++11宏常用宏1234567//__STDC_HOSTED__ 是否包含完整的标准C库 1/0//__FUNCTION__ 当前函数名//__FILE__ 当前物理文件名，包括路径//__LINE__ 当前行数//__DATE__ 当前日期 ”MMM DD YYYY“//__TIME__ 当前时间 ”HH:MM:SS“格式，实际是可执行文件的生成时间//__cplusplus 支持C++03中值为199711L，C++11中值为201103L。版本越高只会越大。 常用宏指令12345678910111213#define sum(a,b) ((a)+(b))#if 条件 //如果条件为真则编译下面的代码#endif //结束#if#elif 条件 //否则如果#else //否则#pragma once //该头文件只编译一次，但是不通用，有一些编译器不支持//等于下列写法#ifndef __INC_FILENAME_ #define __INC_FILENAME_代码#endif 例子1234567891011121314151617181920212223242526#include&lt;iostream&gt;#define PI 3.14#define sum(a,b) ((a)+(b))#if 2int globaVar = 25;#endif#if 2//代码1#elif 1//代码2#else//代码3#endifusing namespace std;void run() &#123; cout &lt;&lt; &quot;当前函数&quot; &lt;&lt; __FUNCTION__ &lt;&lt; endl;&#125;int main() &#123; run(); cout &lt;&lt; __FILE__ &lt;&lt; endl; cout &lt;&lt; __LINE__ &lt;&lt; endl; cout &lt;&lt; __DATE__ &lt;&lt; endl; cout &lt;&lt; __TIME__ &lt;&lt; endl; return 0;&#125; C/C++混合编程 C语言中，函数a和全局变量b会被编译成_a和_b这两种格式。 C++中，函数c和全局变量d会被编译成类似?c@@YAXXZ和?d@@3HA（为了能够实现函数重载）。 使用extern &quot;C&quot;&#123;函数声明;&#125;解决 注意：将extern “C” 放入头文件中会导致这句代码被预处理到**.c文件中从而编译失败**。故不让extern &quot;C&quot;在.c中参与编译。 1234extern &quot;C&quot; &#123; //告诉C++编译器，内部的内容全以C的结构来编译 float getPi(); //不适用C++的”函数名重整技术“这样就可以兼容C，类等不受影响。&#125; 例子1234567891011121314151617//CppTool.h#define Pi 3.14#ifndef __CppTOOL_H__#define __CppTOOL_H__#if __cplusplusextern &quot;C&quot; &#123;#endif float getpi();#ifdef __cplusplus&#125;#endif#endif // !__CppTOOL_H__ 123456//CppTool.cpp#include&quot;CppTool.h&quot;float getpi() &#123; return Pi;&#125; 12345678//main.c#include&lt;stdio.h&gt;#include&quot;CppTool.h&quot;int main() &#123; float p = getpi(); printf(&quot;p = %f\\n&quot;, p);&#125; const const变量 const修饰的变量是只读变量 C++变量关于const变量初始化为字面量有一个优化 const变量对应的内存空间被修改后const变量的值不变 C中const变量对应的内存空间被修改后const变量的值改变 &amp;c 是一个const int*类型变量 如果想修改const变量，只能直接修改cosnt变量对应的内存空间 C++ 123456789101112131415#include&lt;iostream&gt;using namespace std;int main() &#123; const int a = 10; cout &lt;&lt; &quot;a地址：&quot; &lt;&lt; &amp;a &lt;&lt; &quot; a值：&quot; &lt;&lt; a &lt;&lt; endl; int *pa = (int*)(&amp;a);//&amp;a 是一个const int*类型变量 *pa = 20; cout &lt;&lt; &quot;修改a对应内存后&quot; &lt;&lt; endl; cout &lt;&lt; &quot;a地址：&quot; &lt;&lt; &amp;a &lt;&lt; &quot; ta值：&quot; &lt;&lt; a &lt;&lt; endl;//a不变，类似宏定义一样 cout &lt;&lt; &quot;*pa地址：&quot; &lt;&lt; pa &lt;&lt; &quot; *pa值：&quot; &lt;&lt; *pa &lt;&lt; endl; return 0;&#125; C 12345678910111213#include&lt;stdio.h&gt;int main() &#123; int a = 10; printf(&quot;a的地址：%d %t a的值：%d\\n&quot;, &amp;a, a);//%p为输出指针类型 //a这个标识符对应了内存中4个字节的空间。但不可以通过a来修改这个空间。 //只能通过非法的方式修改a int *p = (int*)&amp;a;//把a的地址当成int类型的地址。 *p = 100; printf(&quot;a对应的内存修改后\\n&quot;); printf(&quot;a的地址：%d %t a的值：%d\\n&quot;, &amp;a, a); return 0;&#125; const修饰指针 123int *const p1 = &amp;a;//const挨着p，即p不可修改const int * p2 = &amp;a;//const挨着*p，即*p不可修改const int * const p3 = &amp;a;//都挨着，都不可修改 constexpr常量表达式 常量表达式是编译器在编译时就能够计算出结果的整型表达式。 修饰的变量变为常量。可以修饰函数返回值或者变量。 修饰变量时，该变量只能赋值成编译期间确定的常量。 如果修饰函数返回值,如果该返回值编译期间可确定，就是常量，否则就是普通函数。 123456789101112131415161718192021//constexpr常量表达式constexpr int getSize() &#123; return 5;&#125;int getSize2() &#123; return 6;&#125;void constExprTest() &#123; constexpr int d = 5; int arr[d]; int c = 53; getSize(); //int arr3[getSize2()]; int arr2[getSize()];//创建数组时传入的参数必须是常量，constexpr getSize()的返回值在编译期间可确定，故该函数可看作是常量 //constexpr int d2 = c;不可以&#125;int main() &#123; constExprTest(); return 0;&#125; const成员函数 非常成员函数中：this指针是 T* const this 常成员函数中：this指针是 const T* const this 常函数中不允许调用其他非常函数 面试题：如何在常函数中修改成员变量 将this指针强转成非const指针，用新指针修改成员变量：T* p=(T*)this 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;class NODE &#123; int value;public: NODE() &#123;&#125; NODE (const NODE&amp; o) &#123; &#125; void run() &#123; this-&gt;value = 25; (*this).value = 25; &#125; void print() &#123; cout &lt;&lt; &quot;调用非常函数成功&quot; &lt;&lt; endl; &#125; void crun() const&#123; //声明一个函数对当前对象不会修改 //常函数和非常函数区别就是this指针类型不同 //常函数不允许调用任何非常函数 //this-&gt;value = 25; //(*this).value = 25; //print(); &#125; void cfxg() const &#123; ((NODE*)this)-&gt;value = 33; &#125;&#125;int gv = 66;int main() &#123; NODE a; NODE b(a); //这种情况下如果拷贝构造函数不加const会报错 const NODE c; NODE d(c); &#125; 杂项 using 重定义类型名，只在写模板函数才有区别 nullptr 空指针 auto 自动根据赋值的类型推导数据类型 auto arr2 = arr1; auto是值类型 auto&amp; arr3 = arr1; 引用需要加&amp; auto* arr4 = &amp;arr1; 指针需要加* for(auto i : arr) 增强for循环 本质是迭代器 增强for循环中不允许修改数组 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;vector&gt;using aab = int;template&lt;class T&gt; using v=std::vector&lt;T&gt;;typedef int aac;int main() &#123; v&lt;int&gt; arr; acc d = 25; auto val = 25; std::vector&lt;std::vector&lt;int&gt;&gt; arr1; auto arr2 = arr1;//auto是值类型 auto&amp; arr3 = arr1;//引用需要加&amp; auto* arr4 = &amp;arr1;//指针需要加* for (auto i = arr1.begin(); i != arr1.end(); i++) &#123; cout &lt;&lt; (*i) &lt;&lt; &quot;\\t&quot;; &#125;cout &lt;&lt; endl; //增强for循环,本质是迭代器,增强for循环中不允许修改数组 for (auto i : arr1) &#123; cout &lt;&lt; i &lt;&lt; &quot;\\t&quot;; &#125;cout &lt;&lt; endl;&#125; 强枚举类型 c语言中的枚举，不可以改变底层的数据类型(强制为4个字节的n)，相同作用域下不同枚举的枚举值相同会冲突。 C++11中，引入了枚举类来解决c语言中枚举问题 enum class states &#123; state1, state2, state3&#125; 枚举类型所使用的类型默认为int类型，也可指定其他类型 enum class HeroState : char&#123; state1, state2, state3 &#125; 想要使用枚举值必须加作用域。HeroState::state1 头文件&lt;limits. h&gt;里边存储了各种基本类型变量的长度和一些信息，用宏的方式表示。方便写可以跨平台的C/C++程序。 12345678910111213enum class Hero : char &#123; state1, state2, state3 &#125;;int main() &#123; Hero herostate = Hero::state1; cout &lt;&lt; &quot;state1 = &quot; &lt;&lt; (char)Hero::state1 &lt;&lt; endl; cout &lt;&lt; &quot;state2 = &quot; &lt;&lt; (char)Hero::state2 &lt;&lt; endl; cout &lt;&lt; &quot;state3 = &quot; &lt;&lt; (char)Hero::state3 &lt;&lt; endl; enum class color : char &#123; red, black, green&#125;; cout &lt;&lt; &quot;color is &quot; &lt;&lt; (char)color::red &lt;&lt; endl; return 0;&#125; 整型提升规则 所有表达式和变量计算时，如果计算的操作数小于4个字节，就转换为4个字节来计算。 char和short,进行计算时，会直接转为int计算 32位系统，底层的CPU操作数据的基本单位是4个字节，无法单独操作char和short,所以需要转换为int 同类型的有符号和无符号运算，会转换为无符号变量再运算 原始字符串（Raw String） const char* str=R&quot;(字符串内容)&quot;;可以将字符串内容原原本本的转换为字 符串(转义字符或回车等都可以被识别成原本含义) R自定义结束符&quot;(字符串内容)自定义结束符&quot;;可以自定义结束符防止重复 1234567891011int main() &#123; const char* html = R&quot;(meta name = &quot;ap content = &quot;yes&quot; /&gt;\\n \\t)&quot;; const char* nn = R&quot;sajkldjlf(meta name = &quot;ap content = &quot;yes&quot; /&gt;\\n \\t)sajkldjlf&quot;; cout &lt;&lt; &quot;html = &quot; &lt;&lt; html &lt;&lt; endl; cout &lt;&lt; &quot;************************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;nn = &quot; &lt;&lt; nn &lt;&lt; endl; return 0;&#125; 定义字面量后缀 25l是long类型的变量，25. f是float类型的变量。也可以自定义带后缀的字面的功能。 返回值 operator&quot;&quot;后缀名(参数) &#123;代码&#125; 参数只能为char，unsigned long long 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;class Node &#123;public: int val;&#125;;//返回值是啥都行Node operator&quot;&quot;zz(unsigned long long l) &#123; Node rtn; rtn.val = l; return rtn;&#125;int operator&quot;&quot;square(unsigned long long l) &#123; return l * l;&#125;//参数只能为char，unsigned long longint main() &#123; Node t = 25zz; cout &lt;&lt; t.val &lt;&lt; endl; cout &lt;&lt; (35zz).val &lt;&lt; endl; cout &lt;&lt; 9square &lt;&lt; endl; return 0;&#125; 函数对象 C++中引入了函数对象（仿函体），能代替函数指针来做一些功能 C++用来代替C语言中的函数指针，作为一个对象，可以存储状态，有各种属性和行为 12345678910void functionObject() &#123; vector&lt;int&gt; arr = &#123;123,512,213,5&#125;; sort(arr.begin(), arr.end(), greater&lt;int&gt;()); /*这句相当于 greater&lt;int&gt; g; sort(arr.begin(), arr.end(), g);*/ for (int i : arr) &#123; cout &lt;&lt; i &lt;&lt; &quot;\\t&quot;; &#125;cout &lt;&lt; endl;&#125; 自己写仿函体 1234567891011121314class gt &#123;public: bool operator()(int a, int b) &#123; return a &gt; b; &#125;&#125;void functionObject() &#123; vector&lt;int&gt; arr = &#123;123,512,213,5&#125;; gt g; sort(arr.begin(), arr.end(), g); for (int i : arr) &#123; cout &lt;&lt; i &lt;&lt; &quot;\\t&quot;; &#125;cout &lt;&lt; endl;&#125; lambda表达式 本质是生成了一个函数对象，因为是函数对象，所以可以有成员变量，在创建该对象时捕获所有[]中表明的变量 123456789101112131415161718struct lambda_1 &#123; void operator() ()&#123; &#125;&#125;stuct lambda_2 &#123; void operator()(int a, int b)&#123; return a &gt; b; &#125;&#125;void lambda表达式() &#123; []()&#123;&#125;; /*相当于lambada_1 ();//匿名对象*/ auto f = []() &#123;&#125;; auto f2 = lambda_1(); vector&lt;int&gt; arr = &#123;12,52,255,33,122&#125;; sort(arr.begin(), arr.end(). [](int a, int b) &#123;return a &gt; b;&#125;); sort(arr.begin(), arr.end(), lambda_2());&#125; 最简单的lambda表达式[]&#123;&#125;; 相当于 123struct lambda_1 &#123; void operator()() &#123;&#125;;&#125; 无参，返回值类型void[]() &#123;&#125; 有参1[](int, int) &#123;&#125;; 显示定义返回值12auto c = [](double)-&gt;bool &#123;return false;&#125;;//显式定义返回值是bool类型，定义返回什么都可以c(35); 自动推导返回值类型 返回类型不能有歧义，即所有分支下的返回类型必须相同 12auto f2 = []() &#123;return 5;&#125;;f2(); 加()可以直接调用1auto f2 = []() &#123;return 5;&#125; (); 捕获功能 lambda可以捕获一些变量 捕获的本质是成员变量 123456int lambda表达式捕获功能() &#123; int a = 53; int b = 66; int c = 77; auto f = [a, b, &amp;c]() &#123; cout &lt;&lt; a + b &lt;&lt; endl; &#125;;&#125; 值捕获 a，b是值捕获 值捕获不允许修改内容，相当于字面值与原变量无关 加mutable就可以修改内容了，但与原变量无关 123auto f = [a, b, &amp;c]()mutable &#123; cout &lt;&lt; a + b &lt;&lt; endl;&#125; 只能捕获lambda语句之前就有的变量 引用捕获 c是引用捕获 引用捕获可以修改内容 捕获this指针 this指针只能值捕获 12345678910class tt &#123; int a; int b; void test() &#123; [this]() &#123; this-&gt;a = 35; b = 60 &#125; &#125;&#125; 方便的捕获 自动值捕获里边用的所有变量 123[=]() &#123; cout &lt;&lt; a + b &lt;&lt; endl;&#125; 自动引用捕获里边用的所有变量 123[&amp;]() &#123; cout &lt;&lt; a + b &lt;&lt; endl;&#125; 可执行体function对象 头文件是functional funtion&lt;void()&gt;就是一个接受可执行体。返回值是void，参数是()类型的可执行体才能传入 C++中常用可执行体包括：函数指针，成员函数指针，仿函体，lambda对象， function可以用于保存并调用任何可调用的东西，比如move函数、lambda函数、std::bind表达式、仿函体、指向对象成员的指针 function对象专门用于包装可执行体 1234function&lt;void()&gt; f = []()&#123; cout &lt;&lt; &quot;可以用function来存储对应类型的可执行体&quot; &lt;&lt; endl; &#125;;function&lt;int(int, int)&gt; f2 = [](int, int)-&gt;int &#123; return 0;&#125;; 12345678910111213141516171819202122void func(void(*p)()) &#123;&#125;void accpetFunction(std::function&lt;void()&gt; f)&#123; &#125;struct tn &#123; void run() &#123; cout &lt;&lt; &quot;成员函数&quot; &lt;&lt; endl; &#125;&#125;void function可执行体() &#123; accpetFunction([]() &#123; cout &lt;&lt; &quot;lambda表达式&quot; &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125;); int a = 4; int b = 35; //func([a, b]() &#123;&#125;); accpetFunction([a, b]() &#123;&#125;); //function存成员函数 function(void (tn)) f = &amp;tn::run; tn n; f(n);&#125; 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;functional&gt;#include&lt;vector&gt;using namespace std;void fun() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot;运行&quot; &lt;&lt; endl;&#125;void f2() &#123; vector&lt;function&lt;void()&gt;&gt; arr; for (int i = 0; i &lt; 5; i++) &#123; arr.push_back(fun); &#125; for (auto i : arr) &#123; i(); &#125;&#125;function&lt;void()&gt; getlocalVal() &#123; int a = 5, b = 20; auto f = [a, &amp;b]() &#123; cout &lt;&lt; &quot;a&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b&quot; &lt;&lt; b &lt;&lt; endl; &#125;; return f;&#125;int main() &#123; cout &lt;&lt; &quot;开始运行&quot; &lt;&lt; endl; f2(); auto a = getlocalVal(); a();//引用捕获当局部变量消失后，就变成了野引用 return 0;&#125; bind可以将一个参数列表的函数适配成另一种 123456789101112131415161718192021222324252627282930313233#include&lt; iostream&gt;#include&lt;functional&gt;using namespace std;void socket1(int a) &#123; cout &lt;&lt;&quot; 参数a:&quot; &lt;&lt; a &lt;&lt; endl;&#125;void socket2(int a, int b) &#123; cout &lt;&lt; &quot;参数a:&quot; &lt;&lt; a &lt;&lt; &quot;参数b:&quot; &lt;&lt; b &lt;&lt; endl;&#125;void socket3(int a, int b, int c) &#123; cout &lt;&lt; &quot;参数a:&quot; &lt;&lt; a &lt;&lt; &quot;参数b:&quot; &lt;&lt; b &lt;&lt; &quot;参数c:&quot; &lt;&lt; C &lt;&lt; endl;&#125;void socket4(int a, int b, int c, int d) &#123; cout &lt;&lt; &quot;参数a:&quot; &lt;&lt; a &lt;&lt; &quot;参数b:&quot; &lt;&lt; b &lt;&lt; &quot;参数c:&quot; &lt;&lt; c &lt;&lt; &quot;参数d:&quot; &lt;&lt; d &lt;&lt; endl;&#125;void 充电(function&lt;void(int, int)&gt; sock) &#123; cout &lt;&lt; &quot;准备插入插槽&quot; &lt;&lt; endl; sock(2, 5);//传入2A，5V cout &lt;&lt; &quot;充电完毕”&lt;&lt; endl;&#125;int main() &#123; //函数适配器 //可以使用placeholder进行占位 //socket3接受3个int，第一个参数绑定31，第二个参数为第二个实参，第三个参数为第一个实参 function&lt;void(int,int)&gt; f = bind(socket3,31,placeholder::_2,placeholder::_1); f(7,9); //socket1绑定1个参数，第一个参数绑定为第一个实参 function&lt;void(int,int)&gt; f2 = bind(socket1,placeholder::_1); 充电(bind(socket1, placeholder::_1)); 充电(socket2); 充电(bind(socket3, placeholder::_1, placeholder::_2, 10)); return 0;&#125; 成员函数使用时需要加取地址符&amp; 123456789101112131415//将成员函数绑定为全局函数class BO &#123;public: void run(int) &#123; cout &lt;&lt; &quot;调用了run&quot; &lt;&lt; this &lt;&lt; endl; &#125;&#125;int main() &#123; BO b; function&lt;void()&gt; t = bind(&amp;BO::run, b, placeholder::_1); t(); return 0;&#125; 类型转换 c语言风格的强制转换功能强大，但它把多种本质区别很大的类型转换用同一种写法表示 C++11引入了四种类型转换来替代C风格的强制转换 123456789void C风格强制转换() &#123; double a = 53.156; short f = (short)a; cout &lt;&lt; f &lt;&lt; endl; char *p = (char*)malloc(700); const int d = 5; const int* cpd = &amp;d; int *pd = (int*)cpd;//将const类型指针赋值给一个非const型指针也需要强制转换&#125; 静态类型转换 static_cast&lt;&gt;()：用于在基本类型之间转换以及编译期间确定的指针类型转换 子类指针转换成父类指针安全，父类指针转换成子类指针不一定安全 不同类型指针转换不一定安全 可以转换数据，也可以转换指针类型，不能用来去掉const 1234567void 静态类型转换() &#123; int c = static_cast&lt;int&gt;(35.3); char *p = static_cast&lt;char*&gt;(malloc(700)); const int d = 5; const int *cpd = &amp;d; //int *pd = static_cast&lt;int*&gt;(cpd);&#125; const类型转换 const_cast&lt;&gt;()：专门用于去掉const和volatile，只能用于操作指针 123456void const类型转换() &#123; const int d = 5; const int *cpd = &amp;d; int *pd = const_cast&lt;int*&gt;(cpd); int *pd2 = const_cast&lt;int*&gt;(&amp;d);&#125; 动态类型转换 dynamic_cast&lt;&gt;() 可以尝试性的将父类指针转换为子类指针，如果安全，就正常转换。转换指针时如果不安全，就返回空指针；转换应用时如果不安全，就抛出bad_cast异常 要转换的指针对应的类必须有虚函数 12345678910111213141516171819202122232425262728293031323334353637class A &#123; virtual void run() &#123;&#125;;&#125;;class B : public A &#123;&#125;;class C : public B &#123;&#125;;void 动态类型转换() &#123; B b; A* a = &amp;b;//子类对象父类指针安全 //把父类指针强转成子类指针不一定安全 B *b2 = (B*)a;//因为a指向的对象本质是B类对象，安全 C *c2 = (C*)a;//因为a指向的对象本质是B类对象，所以不安全 B *b3 = dynamic_cast&lt;B*&gt;(a); C *c3 = dynamic_cast&lt;C*&gt;(a); cout &lt;&lt; &quot;b3：&quot; &lt;&lt; b3 &lt;&lt; &quot;和c3：&quot; &lt;&lt; c3 &lt;&lt; endl; if (b3) &#123; //如果b3不是空指针，说明转换成功，这时再使用b3 &#125; A&amp; ra = b; try &#123; B&amp; b3 = dynamic_cast&lt;B&amp;&gt;(ra); &#125; catch (bad_cast bc) &#123; cout &lt;&lt; bc.what() &lt;&lt; __LINE__ &lt;&lt; endl; &#125; try &#123; C&amp; c3 = dynamic_cast&lt;C&amp;&gt;(ra); &#125; catch (bad_cast bc) &#123; cout &lt;&lt; bc.what() &lt;&lt; __LINE__ &lt;&lt; endl; &#125;&#125; 重新解释转换 reinterpret_cast&lt;&gt;()使用的很少，用来将指针的二进制数据转换成新类型的指针，不会改变二进制内容 1234567void 重新解释转换() &#123; A a; A *pa = &amp;a; B *b = reinterpret_cast&lt;B*&gt;(pa); C *c = reinterpret_cast&lt;C*&gt;(pa); cout &lt;&lt; &quot;b：&quot; &lt;&lt; b &lt;&lt; &quot;和c：&quot; &lt;&lt; c &lt;&lt; endl;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"笔记","slug":"C-C/笔记","permalink":"http://example.com/categories/C-C/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"}]},{"title":"C语言学习笔记","slug":"C语言学习笔记","date":"2021-01-05T08:50:02.000Z","updated":"2021-02-22T16:33:26.732Z","comments":true,"path":"2021/01/05/C语言学习笔记/","link":"","permalink":"http://example.com/2021/01/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"主函数main函数的返回值类型必须是int，这样返回值才能传递给程序的激活者（如操作系统）。如果main函数的最后没有写return语句的话，C99 规定编译器要自动在生成的目标文件中（如 exe 文件）加入return 0; ，表示程序正常退出。任何其他非零的返回值都有操作系统定义的含义。通常非零返回值表明有错误出现。每一种操作系统都有自己的方式告诉用户main函数返回什么内容。 变量类型 int整型（通常为 16 位，其取值范围在-32768～32767 之间，也有用 32 位表示的int类型） float浮点型（通常是 32 位，它至少有 6 位有效数字，取值范围一般在 10-38～1038之间） char字符——一个字节 short短整型 long长整型 double双精度浮点型 在 C 语言及许多其它语言中，整数除法操作将执行舍位，结果中的任何小数部分都会被舍弃。但是，如果某个算术运算符有一个浮点型操作数和一个整型操作数，则在开始运算之前整型操作数将会被转换为浮点型。 const1234567891011int main() &#123; int a = 100; int b = 200; int *const p1 = &amp;a;//const挨着p，即p不可修改 const int * p2 = &amp;a;//const挨着*p，即*p不可修改 const int * const p3 = &amp;a;//都挨着，都不可修改 //p1 = &amp;b; //*p2 = 100; return 0;&#125; 类型转换unsighed类型unsighed类型只能是正数或0 unsigned比int高级，n &lt;= i时n被隐式类型转换，无符号数负数变为最大值。 12345678910111213#include&lt;stdio.h&gt;void test(int n)&#123; for (unsigned int i = 0; n &lt;= i; n--) &#123; printf(&quot;%d&quot;,n); &#125;&#125;int main()&#123; test(10); return 0;&#125; 输出结果 1死循环 1.强制类型转换123int a = 2;int b = 3;printf(&quot;%f&quot;,(float)a / b); 2.隐式类型转换123int a = 2;int b = 3;printf(&quot;%f&quot;,(a * 1.0) / b); 符号常量 在程序中使用”幻数”-就是具体的数，反映不出数字所代表的意义-无法向以后阅读该程序的人提供什么信息，使程序的修改变得更加困难。处理这种幻数的一种方法是赋予它们有意义的名字。#define指令可以把符号名（或称为符号常量）定义为一个特定的字符串。 1#define 名字 替换文本 程序中出现的所有在#define中定义的名字（既没有用引号引起来，也不是其它名字的一部分）都将用相应的替换文本替换。其中，名字与普通变量名的形式相同：它们都是以字母打头的字母和数字序列；替换文本可以是任何字符序列，而不仅限于数字。 符号常量名通常用大写字母拼写，这样可以很容易与用小写字母拼写的变量名相区别。注意，#define指令行的末尾没有分号。 运算符位运算符 按位与&amp; 按位或`` `` 按位异或^ 按位取反~ 左移运算符&lt;&lt; 左移1位相当于乘2 右移运算符&gt;&gt; 右移1位相当于除2 例题计算2^0 + 2^1 + 2^2 + 2^3 + 2^4 + … + 2^n的结果1234567int main()&#123; int n = 0; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%d&quot;,1 &lt;&lt; (n + 1) - 1); return 0;&#125; &amp;&amp;和||和!当&amp;&amp;前为0时不运行&amp;&amp;后面的 当||前不为0时不运行||后面的 12345678#include&lt;stdio.h&gt;int main()&#123; int a = 0, b = -1; printf(&quot;%d %d %d\\n&quot;, a++ &amp;&amp; b++, a, b); printf(&quot;%d %d %d&quot;, a++ || b++, a, b); return 0;&#125; 输出结果 120 1 -11 2 -1 三步运算符当a&gt;b成立返回1否则返回-1 1return a &gt; b ? 1 : -1 C语言运算符优先级 逻辑语句switch…case…break switch必须是整型 case必须是整型常量 case分支的值不能相同 break不可忽视 如果现在case分支中定义一个变量，加一个括号 所有case分支条件都不满足，那么执行default分支 12345678910111213141516171819#include&lt;stdio.h&gt;int main() &#123; int a; scanf(&quot;%d&quot;,&amp;a); switch(a) &#123; case 1: printf(&quot;%d&quot;,a); break; case 2: &#123; int b = 10; printf(&quot;%d&quot;,b); break; &#125; default: printf(&quot;输入有误&quot;)； break; &#125;&#125; goto用法C语言提供了可以随意滥用的goto语句以及标记跳转位置的标号。可以跳出多重循环。 例子求200以内的素数 12345678910111213141516171819202122#include&lt;stdio.h&gt;int main()&#123; int j = 0; for (int i = 2; i &lt;= 200; i++) &#123; int j = 2; while (j &lt; i) &#123; if (i % j == 0) //当i能被除自己和1意外的数字整除时跳出循环。 &#123; goto Tiaoguo; &#125; j++; &#125; printf(&quot;%d\\n&quot;,i); Tiaoguo: continue; &#125; return 0;&#125; 输出结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445462357111317192329313741434753596167717379838997101103107109113127131137139149151157163167173179181191193197199 指针基础房子理论变量的三大要素1.名字2.空间3.地址 两种操作1.读2.写 指针变量p中放的是谁的地址，*p就是谁 12345int a = 10;int* p = &amp;a;//指针变量:用来存储a的地址printf(&quot;%d\\n&quot;,*p);*p = 20;printf(&quot;%d\\n&quot;,a); 输出结果 121020 指针的运算1234567891011int main()&#123; int nums[10] = &#123;0, 1, 2, 3, 4, 5&#125;; int* p = nums; p++;//p = p + 1*sizeof(int); printf(&quot;%d &quot;, sizeof(int)); printf(&quot;%d &quot;, &amp;nums[0]); printf(&quot;%d &quot;, &amp;nums[1]); printf(&quot;%d &quot;, &amp;nums[2]); return 0;&#125; 指针变量的大小32位编译环境下是4个字节64位编译环境下是8个字节 函数 传入参数，传出参数，传入传出参数：只针对指针类型的形参区分传入、传出。 传入参数：传入的时候需要赋值，并且在函数内部不会对该参数进行修改。传入参数一般前面都有const。 传出参数：传入的时候可以不赋初值，在函数内部不会读取该参数的信息，而是会对该参数进行写操作（赋值）。 传入传出参数：传入的时候需要赋值，并且在函数内部也会对该参数进行写操作（赋值）。 函数指针 与数据项相似，函数也有地址。函数的地址是存储其机器语言代码的内存的开始地址。通常，这些地址对用户而言，既不重要，也没有什么用处，但对程序而言，却很有用。例如，可以编写将另一个函数的地址作为参数的函数。这样第-个函数将能够找到第二个函数，并运行它。与直接调用另一个函数相比，这种方法很笨拙，但它允许在不同的时间传递不同函数的地址，这意味着可以在不同的时间使用不同的函数。 123456789101112131415161718192021#include&lt;stdio.h&gt;int f1(float f) &#123;&#125;int* f2(char c,int i) &#123; printf(&quot;f2&quot;);&#125;int f3(float f) &#123;&#125;int f4(float f) &#123;&#125;typedef int*(*pFun)(char, int);int main() &#123; //函数指针 int(*pf)(float) = f1;//与f1,f3,f4匹配 int*(*pd)(char, int) = f2; f2(&#x27;1&#x27;, 1); (*pd)(&#x27;1&#x27;, 1); pFun p = &amp;f2;&#125; 输出结果 1f2f2 数组[]的意思*(nums + i) &lt;===&gt;nums[i] 数组的名字代表的是数组第一个元素的地址（首地址）。 12345678#include&lt;stdio.h&gt;int main() &#123; int a[4] = &#123; 1,2,3,4 &#125;; int *ptr = (int *)(&amp;a + 1); // 1 * 4 * 4 printf(&quot;%d&quot;, *(ptr - 1)); //a 数组首地址 //&amp;a 数组的地址&#125; 14 数组传参数组传参过程中，数组int nums[]会退化成指针int *nums。 12345678void fun(int* nums, int n)&#123;&#125;int main()&#123; int nums[] &#x3D; &#123;1,2,3,4&#125;; fun(nums,sizeof(nums)&#x2F;sizeof(int));&#125; 例题打乱顺序数组的顺序1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;void printArray (int *arry, int n)&#123; for (int i = 0; i&lt; n; i++)&#123; printf (&quot;%d &quot;, arry[i]); &#125;&#125;int main()&#123; int arry[11] = &#123; 1,2,3,4,5,6,7,8,9,10,11&#125;; srand(time(0));//种随机种子 for (int i = 0; i &lt; 11; i++) &#123; int r = rand() % 11; int t = arry[i]; arry[i] = arry[r]; arry[r] = t; &#125; printArray(arry, 11) ; return 0; &#125; 字符串 字符串用&quot;&quot; ASCII表 12345678#include&lt;stdio.h&gt;int main()&#123; printf(&quot;%d&quot;,&quot;abcdefghi&quot;); printf(&quot;\\n&quot;); printf(&quot;%d&quot;,*&quot;abcdefghi&quot;); return 0;&#125; 输出结果 12421068897 字符 char类型在内存中占1个字节字符用单引号&#39;&#39; 0，’0’,’\\0’1234567891011121314#include&lt;stdio.h&gt;int main()&#123; char c = &#x27;0&#x27;; printf(&quot;%c\\n&quot;,c); //0 printf(&quot;%d\\n&quot;,c); //48 c = 0; printf(&quot;%c\\n&quot;,c); // printf(&quot;%d\\n&quot;,c); //0 c = &#x27;\\0&#x27;; printf(&quot;%c\\n&quot;,c); // printf(&quot;%d\\n&quot;,c); //0 return 0;&#125; 转义字符1234567891011#include &lt;stdio.h&gt;int main ( )&#123; char c = &#x27;\\&#x27;&#x27;; c =&#x27;\\\\&#x27;; c =&#x27;\\n&#x27;; c = &#x27;\\t&#x27;; c = &#x27;\\a&#x27;; printf( &quot;%c&quot;, c); return 0;&#125; &quot;&quot;代表的是字符串中首个字符的地址1234567#include&lt;stdio.h&gt;int main()&#123; printf(&quot;%d\\n&quot;,&quot;abcdefghi&quot;);//字符串实际上时第一个字符的地址，即字符串的首地址 printf(&quot;%d\\n&quot;,*&quot;abcdefghi&quot;);//*&quot;abcdefghi&quot;即为a return 0;&#125; 输出结果 12421068897 为什么使用char*存储字符串12345678#include &lt;stdio.h&gt;int main()&#123; char* p = &quot;abcdefghi&quot;; p++;//p = p + sizeof(char)在遍历字符串的时候指针变量偏移一个字节 printf(&quot;%c&quot;, *p); return 0;&#125; 输出结果 1b 注意char array[] = &#123;&#39;c&#39;,&#39;h&#39;,&#39;i&#39;,&#39;n&#39;,&#39;a&#39;&#125;;和char array[] = &quot;china&quot;;不同，第一种数组大小是5，第二种数组大小是6比第一种多一个元素\\0 计算字符串长度 \\012:\\0后接八以内数字表示八进制 \\x12:\\x后接数字或abcdef表示十六进制 strlen()以\\0作为字符串结束标志 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char* p = &quot;a\\0\\n\\012ab0&quot;; printf (&quot;%d &quot;, sizeof(p)) ; //8 64位系统字符串占8个字节 printf (&quot;%d &quot;, sizeof (&quot;a\\0\\n\\012ab0&quot;)); //8 //a 0 \\n \\012 a b 0 \\0 int n = strlen(p); printf (&quot;%d &quot;, n); //1 //a \\0 strlen()以\\0作为字符串结束标志,其中\\0不计入长度 p++; p++; n=strlen (p) ; printf(&quot;%d &quot;, n); //5 // \\n \\012 a b 0 \\0 return 0;&#125; 输出结果 18 8 1 5 字符数组和字符串常量的区别常量 常量不可修改 整型常量 10 100 字符常量 ‘a’ ‘c’ 浮点常量 1.1 1.01 字符串常量 “asdfd” 地址常量 变量的地址 数组名字 函数名字 1234567891011121314151617#include&lt;stdio.h&gt;int main()&#123; char* p = &quot;a\\0\\n\\012ab0&quot;; //字符串常量 char b[10] = &quot;a\\0\\n\\012ab0&quot;; //字符数组 printf(&quot;%d &quot;,sizeof(p)); //8 printf(&quot;%d &quot;, sizeof(b)); //10 //p++; //b++; //b为数组名是常量不允许修改，该语句有错 //*p++; //*b++; //b++先执行后执行*，产量不允许修改，同上 //(*p)++; //p存储的是字符串中第一个字符的地址，字符串存放在常量区是常量，不允许修改 //(*b)++; return 0;&#125; gets函数 gets函数只有一个参数。参数类型为char*型，即str可以是一个字符指针变量名，也可以是一个字符数组名。 gets()函数的功能是从输入缓冲区中读取一个字符串存储到字符指针变量str所指向的内存空间。 gets()函数不仅比scanf简洁，而且，就算输入的字符串中有空格也可以直接输入，不用像scanf那样要定义多个字符数组。 gets(str);完全可以取代:scanf(&quot;%s&quot;, string); 12345678#include&lt;stdio.h&gt;int main()&#123; char *gets(char *str); char a[50]; gets(a); return 0;&#125; 123456789# include &lt;stdio.h&gt;int main(void)&#123; char str[20] = &quot;\\0&quot;; //字符数组初始化\\0 printf(&quot;请输入字符串：&quot;); gets(str); printf(&quot;%s\\n&quot;, str); return 0;&#125; 输出结果 12请输入字符串：hello the worldhello the world 字符数组的两种遍历方式不同点参考上面《字符数组和字符串常量的区别》 123456789101112131415161718192021#include&lt;stdio.h&gt;int main()&#123; char str[20] = &quot;&quot;; gets(str); int i = 0; while( str[i] != &#x27;\\0&#x27;) &#123; printf(&quot;%c&quot;,str[i]); i++; &#125; char *p = str; while ( *p != &#x27;\\0&#x27;) &#123; printf(&quot;%c&quot;,*p); p++; &#125; return 0;&#125; 字符串函数常见操作 指针变量判空 最后赋值&#39;\\0&#39; 返回值（目的地址）以便支持链式操作 例题1.字符串拷贝123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;char* m_strcpy(char* des, const char* src)&#123; //1.判断指针变量是否为NULL if (des == 0 || src == 0) &#123; return 0;//结束 &#125; //2.字符串拷贝 int i = 0; for (i = 0; src[i] != &#x27;\\0&#x27;; i++) &#123; des[i] = src[i]; &#125; //3.赋值&#x27;\\0&#x27; des[i] = &#x27;\\0&#x27;; //4.返回值目的地址 return des; //支持链式操作&#125;int main()&#123; char src[100] = &quot;&quot;; gets(src); char des[100] = &quot;&quot;; //strcpy(des,src); m_strcpy(des, src); printf(&quot;%s&quot;, des); return 0;&#125; 内存管理常量区特点： 军事管理区，不可修改 常量区空间没有名字 整型常量 10 20 -10 浮点常量 1.2 1.001 字符常量 &#39;a&#39; &#39;0&#39; &#39;\\0&#39; 字符串常量 &quot;adjkls&quot; &quot;56as&quot; 地址常量 int a; &amp;a 数组名 函数名 栈区特点： 租的房子，房子到期自动回收 访问速度快 空间少 作用域和生命周期从定义的位置开始到&#39;&#125;&#39; 常用于局部变量、函数参数 全局区全局变量 特点 局部大于全局（当局部变量和全局变量重名时局部变量优先） 初始化默认为0 生命周期为程序开始到程序结束 作用域为整个项目 引用其他文件中的全局变量 123456789101112131415/mian.c/#include&lt;stdio.h&gt;int g_value;int main()&#123; printf(&quot;%d&quot;,g_value); return 0;&#125;/*a.c*/extern int g_value;void print()&#123; g_value = 100; printf(&quot;%d&quot;,g_value);&#125; 静态区静态局部变量 生命周期从程序开始到程序结束 作用域到&#39;&#125;&#39; 函数结束不释放※ 只被初始化一次※ 123456789101112131415#include&lt;stdio.h&gt;int fun()&#123; int a = 10; static int s = 10; printf(&quot;%d &quot;, a++); printf(&quot;%d &quot;, s++);&#125;int main()&#123; fun();//10 10 fun();//10 11 return 0;&#125; 静态全局变量 生命周期从程序开始到程序结束 作用域为当前文件 堆区特点 买的房子，不会自动释放 不会自动释放 容量大 访问速度慢 堆区空间没有名字 用完需要释放 1234567891011121314#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main()&#123; char* p = malloc(400);//在堆区申请空间（买房子） //返回值为地址，不一定是char，但一定是* //char* 房子被分为400份，一份1个字节 //int* 房子被分为100份，一份4个字节 strcpy(p,&quot;123456&quot;); //房子不用是记得释放 free(p); return 0;&#125; 注意 不要访问越界 不要忘记释放空间 GetMemory笔试题Test112345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void GetMemory1(char *p) &#123; p = (char *)malloc(100);//强制类型转换&#125;void Test1() &#123; char *str = NULL; GetMemory1(str); strcpy(str, &quot;hello world&quot;); printf(str);&#125;int main() &#123; Test1(); return 0;&#125; 访问空指针，异常退出 解决办法1123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char *GetMemory1(char *p) &#123; p = (char *)malloc(100); return p;&#125;void Test1(void) &#123; char *str = NULL; str = GetMemory1(str); strcpy(str, &quot;hello world&quot;); printf(str); free(str);&#125;int main() &#123; Test1(); return 0;&#125; 解决办法21234567891011121314151617#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void GetMemory1(char **p) &#123; //二级指针变量**p *p = (char *)malloc(100);//强制类型转换&#125;//p存放的是str的地址void Test1() &#123; char *str = NULL; GetMemory1(&amp;str); strcpy(str, &quot;hello world&quot;); printf(str); free(str);&#125;int main() &#123; Test1(); return 0;&#125; Test212345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char *GetMemory2(void) &#123; char p[] = &quot;hello world&quot;; return p;&#125;void Test2(void) &#123; char *str = NULL; str = GetMemory2(); printf(str);&#125;int main() &#123; Test2(); return 0;&#125; 字符数组在栈区分配，函数结束被释放 Test312345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char *GetMemory3 (void) &#123; char *p = &quot;hello world&quot;;//字符串是常量，不会改变 故虽然p被释放但常量空间不释放 return p;&#125;void Test3 (void) &#123; char *str = NULL; str = GetMemory3(); printf(str);&#125;int main() &#123; Test3(); return 0;&#125; 输出结果 1hello world Test412345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char *GetMemory4 (void) &#123; static char p[] = &quot;hello world&quot;; return p;&#125;void Test4 (void) &#123; char *str = NULL; str = GetMemory4(); printf(str);&#125;int main() &#123; Test4(); return 0;&#125; 输出结果 1hello world 静态局部变量不会被释放空间，生命周期是全局的 Test5123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void Test5 (void) &#123; char *str = (char *)malloc(400); strcpy(str, &quot;hello&quot;); free(str); //str = NULL; if (str != NULL) &#123; strcpy(str, &quot;world&quot;); printf(str); &#125;&#125;int main() &#123; Test5(); return 0;&#125; 输出结果 1world str被free后变为野指针，空间被释放，但仍存储着房子的地址 free是剥夺变量房子的使用权，但变量仍记得房子地址 平时记得买完房子free记得置空str = NULL; 内存已经被释放，访问野指针造成内存泄漏 指针在free后未赋值 NULL，便会使人以为是合法的。它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。※ Test612345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void Test6 (void) &#123; char *str = (char *)malloc(400); strcpy(str, &quot;hello&quot;); str += 6; free(str); if (str != NULL) &#123; strcpy(str, &quot;world&quot;); printf(str); &#125;&#125;int main() &#123; Test6(); return 0;&#125; str += 6;后地址改变free卖的是别人的房子 出现异常，释放空间不对。 结构体结构体定义123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct STUDENT&#123; int number; int age; int weight; char s;&#125;student; //student为全局变量typedef struct STUDENT1&#123; char a; int weight; char s;&#125;student1; //student1等于STUDENT1int main()&#123; student.age = 10; struct STUDENT abc = &#123;1001, 22, 110, &#x27;M&#x27;&#125;; //初始化结构体 student1 bcd = &#123;1001, 22, 110, &#x27;M&#x27;&#125;; //等于struct student bcd = &#123;1001, 22, 110, &#x27;M&#x27;&#125;; //通常用typedef sturct,方便 printf(&quot;%d %d %d %c &quot;,abc.number,abc.age,abc.weight,abc.s); return 0;&#125; 输出结果 11001 22 110 M 字节对齐 按照最长的成员对齐 保证整数倍地址对齐（比如：short占两个字节不能放在奇数地址，char随便放奇偶都可以） 12345typedef struct STUDENT&#123; int a; char c;&#125;student; 123456typedef struct STUDENT&#123; char s; int a; char c;&#125;student; 1234567typedef struct STUDENT&#123; int a; char s; char c; short d; //short占两个字节&#125;student; 1234567typedef struct STUDENT&#123; int a; char s; short d; char c;&#125;student; 12345678typedef struct STUDENT&#123; int a; long long c; //long long占八个字节 char d; int b; short s;&#125;student; 1234567typedef struct STUDENT&#123; char a : 2;//2代表2比特bt，一个字节8bt char b : 2; char c : 2; char d : 2;&#125;student; 结构体定义的原则，保证结构体字节对齐 12345678### pragma pack(2)//控制结构体按2字节对齐typedef struct STUDENT&#123; int a; char c; char res[3];//跨平台时由于编译器不同，需强制对齐&#125;student;#pragma pack() 结构体数组p-&gt;score &lt;===&gt; (*p).score12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct STUDENT&#123; int number; int score;&#125;student;int main()&#123; int array[10]; char buffer[10]; student s[10] = &#123;&#123;1,10&#125;,&#123;2,30&#125;&#125;; printf(&quot;%d&quot;,s[0].number); student* p = s; printf(&quot;%d &quot;,s[0].score); printf(&quot;%d &quot;,(*p).score); printf(&quot;%d&quot;,p-&gt;score); //p-&gt;score &lt;===&gt; (*p).score return 0;&#125; 输出结果 11 10 10 10 链表特点 空间不连续 不支持随机访问 插入删除的效率高 创建链表 head-&gt;next要初始化为空，因为链表以节点next域为空判断链表是否接受 head在栈区，malloc在堆区分配一片空间给head，head存放的是这片空间的地址 带头结点的头插法123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct NODE&#123; int num; struct NODE* next;//不能用Node，因为编译顺序Node在这句话之后&#125;Node;int main()&#123; Node *head = (Node *)malloc(sizeof(Node)); //head-&gt;next要初始化为空，因为链表以节点next域为空判断链表是否结束 head-&gt;next = NULL; //head在栈区，malloc在堆区分配一片空间给head， //head存放的是这片空间的地址 int number; while (1) &#123; scanf(&quot;%d&quot;,&amp;number); if (number &lt;= 0) &#123; break; &#125; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;num = number; p-&gt;next = head-&gt;next; head-&gt;next = p; &#125; return 0;&#125; 打印链表12345678void printLink(Node* p)&#123; while (p) // &lt;===&gt; p != NULL &#123; printf(&quot;%d &quot;,p-&gt;num); p = p-&gt;next; //不能用p++，因为链表空间不是连续的 &#125;&#125; 释放链表123456789void freeLink(Node* p)&#123; Node *q = NULL; while (p) &#123; q = p; p = p-&gt;next; free(q); &#125;&#125; 查找节点1234567891011Node* searchLink(Node* p, int num)&#123; while (p) &#123; if(p-&gt;num == num) &#123; return p; &#125; p = p-&gt;next; &#125; return NULL;&#125; 修改节点123456789101112Node* modifyLink(Node* p, int num)&#123; while (p) &#123; if(p-&gt;num == num) &#123; p-&gt;num = 20; return p; &#125; p = p-&gt;next; &#125; return NULL;&#125; 删除节点12345678910111213141516171819int modifyLink(Node* p, int num)&#123; if(p == NULL) return; //默认带头节点 Node *q = p; p = p-&gt;next; while (p) &#123; if(p-&gt;num == num) &#123; q-&gt;next = p-&gt;next; free(p); return 0; &#125; q = p; p = p-&gt;next; &#125; return 1;&#125; 插入节点在findnum前插入一个num = newnum的节点 123456789101112131415161718192021int modifyLink(Node* p, int findnum, int newnum)&#123; if(p == NULL) return; //默认带头节点 Node *q = p; p = p-&gt;next; while (p) &#123; if(p-&gt;num == num) &#123; Node *r = (Node *)malloc(sizeof(Node)); r-&gt;num = findnum; q-&gt;next = r; r-&gt;next = p; return 0; &#125; q = p; p = p-&gt;next; &#125; return 1;&#125; 联合 所有成员共享一块空间 sizeof计算成员中字节最大的空间大小 各成员内存重叠 在使用时和结构体语法相同 优势 省空间 1234567891011121314#include&lt;stdio.h&gt;union UN&#123; int a; int c;&#125;;int main()&#123; printf(&quot;%d\\n&quot;,sizeof(union UN)); union UN u; u.a = 10; printf(&quot;%d %d\\n&quot;,u.a,u.c); return 0;&#125; 输出结果 123410 10 1234567891011121314#include&lt;stdio.h&gt;union UN&#123; int a; char c;&#125;;int main()&#123; printf(&quot;%d\\n&quot;,sizeof(union UN)); union UN u; u.c = 10; printf(&quot;%d %d&quot;,u.a,u.c); //a没有被赋值 return 0;&#125; 输出结果 12410 10 大小端小端存储高地址（数大的）放高位（如例子中的万位），低地址放低位 十进制 二进制 100000 0000 0000 0000 0001 1000 0110 1010 0000 0x1234 0x1235 0x1236 0x1237 1010 0000 1000 0110 0000 0001 0000 0000 大端存储低地址（数小的）放高位（如例子中的个位），高地址放低位 十进制 二进制 100000 0000 0000 0000 0001 1000 0110 1010 0000 0x1234 0x1235 0x1236 0x1237 0000 0000 0000 0001 1000 0110 1010 0000 例题：判断电脑cpu是什么架构，是大端存储还是小端存储常见电脑都是小端存储 12345678910111213141516#include&lt;stdio.h&gt;int checkSystem()&#123; union UN &#123; int a; char c; &#125;u; u.a = 1; return u.c == 1;&#125;int main()&#123; printf(&quot;%d&quot;,checkSystem()); return 0;&#125; 若是大端存储 十进制 二进制 1 0000 0000 0000 0000 0000 0000 0000 0001 0x1234 0x1235 0x1236 0x1237 0000 0000 0000 0000 0000 0000 0000 0001 输出结果 10 若是小端存储 十进制 二进制 1 0000 0000 0000 0000 0000 0000 0000 0001 0x1234 0x1235 0x1236 0x1237 0000 0001 0000 0000 0000 0000 0000 0000 输出结果 11 枚举用来屏蔽魔鬼数字，用来表示某种含义 1234567891011121314151617181920#include&lt;stdio.h&gt;//默认从0开始enum ENUM &#123; SUN, MON = 10, TUE, WED, THU, FRI, SAT&#125;;int main()&#123; int a = TUE; printf(&quot;%d &quot;,SUN); printf(&quot;%d&quot;,a); return 0;&#125; 输出结果 10 11 123456789101112int state;//存储一个状态//线程：拥有很多状态，启动，运行，阻塞，终止//游戏人物：静止，移动，攻击前摇，攻击后摇。enum hero &#123; stop, move, attack_f, attack_e &#125;;int main() &#123; hero state; state = stop; cout &lt;&lt; state &lt;&lt; endl; state = move; cout &lt;&lt; state &lt;&lt; endll cout &lt;&lt; sizeof(state) &lt;&lt; endl;&#125; 宏定义用来屏蔽魔鬼数字 1234567891011121314151617#include&lt;stdio.h&gt;#define NUM 10int main()&#123; int arry[NUM]; for (int i = 0; i &lt; NUM; i++) &#123; arry[i] = 10; &#125; for (int i = 0; i &lt; NUM; i++) &#123; printf(&quot;%d &quot;,arry[i]); &#125; return 0;&#125; 输出结果 110 10 10 10 10 10 10 10 10 10 宏定义只是单纯的字符串替换 12345678#include&lt;stdio.h&gt;#define NUM 5+2int main()&#123; printf(&quot;%d&quot;,NUM * 2); return 0;&#125; 输出结果 19 宏函数12345678#include&lt;stdio.h&gt;#define MAX(a,b) if (a &gt; b) &#123;printf(&quot;%d&quot;,a);&#125;else&#123;printf(&quot;%d&quot;,b);&#125;int main()&#123; MAX(20,30) //这句加不加;都不行。 return 0;&#125; 输出结果 130 宏只能在一行，如果换行要在最后加\\ 1234567891011121314#include&lt;stdio.h&gt;#define MAX(a,b)\\if (a &gt; b) &#123;\\ printf(&quot;%d&quot;,a);\\ &#125;\\else&#123;\\ printf(&quot;%d&quot;,b);\\ &#125;int main()&#123; MAX(20,30) return 0;&#125; 多文件编程 联合，枚举，宏定义，函数的声明放在.h文件中 .c文件要使用需要#include&quot;filename.h&quot; 注意 不能循环包含头文件 开头要加#pragma once,防止重复包含头文件或加 1234#ifndef __INC_FILENAME_#define __INC_FILENAME_//代码#endif eg 1234567891011121314151617#ifndef __INC_222_#define __INC_222_typedef struct NODE&#123; int num; struct NODE* next;&#125;;#endif#ifndef __INC_222_#define __INC_222_typedef struct NODE&#123; int num; struct NODE* next;&#125;;#endif 文件读写 12345678910111213141516171819202122#include&lt;stdio.h&gt;int main()&#123; //1.打开文件 FILE* fr = fopen(&quot;E:\\\\文档\\\\新建文本文档.c&quot;,&quot;r&quot;); FILE* fw = fopen(&quot;E:\\\\文档\\\\新建文本文档.c&quot;,&quot;w&quot;); if(fr == NULL || fw == NULL) &#123; printf(&quot;文件打开失败&quot;); return 0; &#125; //2.读写文件 char buffer[128]; fgets(buffer,128,fr); printf(&quot;%s&quot;,buffer); fputs(buffer,fw); //3.关闭文件 fclose(fr); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"笔记","slug":"C-C/笔记","permalink":"http://example.com/categories/C-C/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"测试1错题","slug":"测试1错题","date":"2021-01-03T22:50:02.000Z","updated":"2021-01-11T10:28:14.663Z","comments":true,"path":"2021/01/04/测试1错题/","link":"","permalink":"http://example.com/2021/01/04/%E6%B5%8B%E8%AF%951%E9%94%99%E9%A2%98/","excerpt":"1.计算2^0 + 2^1 + 2^2 + 2^3 + 2^4 + … + 2^n的结果","text":"1.计算2^0 + 2^1 + 2^2 + 2^3 + 2^4 + … + 2^n的结果 1234567int main()&#123; int n = 0; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%d&quot;,1 &lt;&lt; (n + 1) - 1); return 0;&#125; 2.任意一个大于2的偶数n都可以由两个素数的和组成，但是组成偶数的素数有很多种情况，输出所有情况。123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int n = 0; scanf(&quot;%d&quot;,&amp;n); int *nums = (int *)malloc(n*sizeof(int)); if (nums == NULL) &#123; return -1; //申请空间失败，返回异常状态 &#125; //初始化动态数组 for (int i = 0; i &lt; n; i++) &#123; nums[i] = 0; &#125; //厄拉多塞筛选法 for (int i = 2; i &lt; n; i++) &#123; if (nums[i] == 0) &#123; for (int j = i + i; j &lt; n; j += i) &#123; nums[j] = 1; &#125; &#125; &#125; for(int i = 2; i &lt; n / 2; i++) &#123; if (nums[i] == 0 &amp;&amp; nums[n - i] == 0) &#123; printf(&quot;%d %d\\n&quot;,i,n - i); &#125; &#125; free(nums); return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"习题","slug":"C-C/习题","permalink":"http://example.com/categories/C-C/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"C/C++习题","slug":"C-C-习题","permalink":"http://example.com/tags/C-C-%E4%B9%A0%E9%A2%98/"}]},{"title":"not done","slug":"not done","date":"2020-05-30T02:10:04.000Z","updated":"2021-03-02T17:39:05.991Z","comments":true,"path":"2020/05/30/not done/","link":"","permalink":"http://example.com/2020/05/30/not%20done/","excerpt":"","text":"1. C++链表12345struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;; main函数中如何创建链表 2. 友元函数私有函数指针3. B b();相当于函数声明，即返回值为B的名叫b的函数 类名(); //无名创造 strcat必须找到’\\0’ 4.考试错题 哈希测试leetcode32.3 leetcode 111 104更优解 图的建立 当名字很长不能用int保存时 5.linux系统编程实现cp指令功能 预读入缓输出 虚拟内存 blog整理C++11lambda表达式 本质是生成了一个函数对象，因为是函数对象，所以可以有成员变量，在创建该对象时捕获所有[]中表明的变量 123456789101112131415161718struct lambda_1 &#123; void operator() ()&#123; &#125;&#125;stuct lambda_2 &#123; void operator()(int a, int b)&#123; return a &gt; b; &#125;&#125;void lambda表达式() &#123; []()&#123;&#125;; /*相当于lambada_1 ();//匿名对象*/ auto f = []() &#123;&#125;; auto f2 = lambda_1(); vector&lt;int&gt; arr = &#123;12,52,255,33,122&#125;; sort(arr.begin(), arr.end(). [](int a, int b) &#123;return a &gt; b;&#125;); sort(arr.begin(), arr.end(), lambda_2());&#125; 最简单的lambda表达式[]&#123;&#125;; 相当于 123struct lambda_1 &#123; void operator()() &#123;&#125;;&#125; 无参，返回值类型void[]() &#123;&#125; 有参1[](int, int) &#123;&#125;; 显示定义返回值12auto c = [](double)-&gt;bool &#123;return false;&#125;;//显式定义返回值是bool类型，定义返回什么都可以c(35); 自动推导返回值类型 返回类型不能有歧义，即所有分支下的返回类型必须相同 12auto f2 = []() &#123;return 5;&#125;;f2(); 加()可以直接调用1auto f2 = []() &#123;return 5;&#125; (); 捕获功能 lambda可以捕获一些变量 捕获的本质是成员变量 123456int lambda表达式捕获功能() &#123; int a = 53; int b = 66; int c = 77; auto f = [a, b, &amp;c]() &#123; cout &lt;&lt; a + b &lt;&lt; endl; &#125;;&#125; 值捕获 a，b是值捕获 值捕获不允许修改内容，相当于字面值与原变量无关 加mutable就可以修改内容了，但与原变量无关 123auto f = [a, b, &amp;c]()mutable &#123; cout &lt;&lt; a + b &lt;&lt; endl;&#125; 只能捕获lambda语句之前就有的变量 引用捕获 c是引用捕获 引用捕获可以修改内容 捕获this指针 this指针只能值捕获 12345678910class tt &#123; int a; int b; void test() &#123; [this]() &#123; this-&gt;a = 35; b = 60 &#125; &#125;&#125; 方便的捕获 自动值捕获里边用的所有变量 123[=]() &#123; cout &lt;&lt; a + b &lt;&lt; endl;&#125; 自动引用捕获里边用的所有变量 123[&amp;]() &#123; cout &lt;&lt; a + b &lt;&lt; endl;&#125; 可执行体function对象 头文件是functional funtion&lt;void()&gt;就是一个接受可执行体。返回值是void，参数是()类型的可执行体才能传入 C++中常用可执行体包括：函数指针，成员函数指针，仿函体，lambda对象， function可以用于保存并调用任何可调用的东西，比如move函数、lambda函数、std::bind表达式、仿函体、指向对象成员的指针 function对象专门用于包装可执行体 1234function&lt;void()&gt; f = []()&#123; cout &lt;&lt; &quot;可以用function来存储对应类型的可执行体&quot; &lt;&lt; endl; &#125;;function&lt;int(int, int)&gt; f2 = [](int, int)-&gt;int &#123; return 0;&#125;; 12345678910111213141516171819202122void func(void(*p)()) &#123;&#125;void accpetFunction(std::function&lt;void()&gt; f)&#123; &#125;struct tn &#123; void run() &#123; cout &lt;&lt; &quot;成员函数&quot; &lt;&lt; endl; &#125;&#125;void function可执行体() &#123; accpetFunction([]() &#123; cout &lt;&lt; &quot;lambda表达式&quot; &lt;&lt; __FUNCTION__ &lt;&lt; endl; &#125;); int a = 4; int b = 35; //func([a, b]() &#123;&#125;); accpetFunction([a, b]() &#123;&#125;); //function存成员函数 function(void (tn)) f = &amp;tn::run; tn n; f(n);&#125; 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;functional&gt;#include&lt;vector&gt;using namespace std;void fun() &#123; cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot;运行&quot; &lt;&lt; endl;&#125;void f2() &#123; vector&lt;function&lt;void()&gt;&gt; arr; for (int i = 0; i &lt; 5; i++) &#123; arr.push_back(fun); &#125; for (auto i : arr) &#123; i(); &#125;&#125;function&lt;void()&gt; getlocalVal() &#123; int a = 5, b = 20; auto f = [a, &amp;b]() &#123; cout &lt;&lt; &quot;a&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b&quot; &lt;&lt; b &lt;&lt; endl; &#125;; return f;&#125;int main() &#123; cout &lt;&lt; &quot;开始运行&quot; &lt;&lt; endl; f2(); auto a = getlocalVal(); a();//引用捕获当局部变量消失后，就变成了野引用 return 0;&#125; bind可以将一个参数列表的函数适配成另一种 123456789101112131415161718192021222324252627282930313233#include&lt; iostream&gt;#include&lt;functional&gt;using namespace std;void socket1(int a) &#123; cout &lt;&lt;&quot; 参数a:&quot; &lt;&lt; a &lt;&lt; endl;&#125;void socket2(int a, int b) &#123; cout &lt;&lt; &quot;参数a:&quot; &lt;&lt; a &lt;&lt; &quot;参数b:&quot; &lt;&lt; b &lt;&lt; endl;&#125;void socket3(int a, int b, int c) &#123; cout &lt;&lt; &quot;参数a:&quot; &lt;&lt; a &lt;&lt; &quot;参数b:&quot; &lt;&lt; b &lt;&lt; &quot;参数c:&quot; &lt;&lt; C &lt;&lt; endl;&#125;void socket4(int a, int b, int c, int d) &#123; cout &lt;&lt; &quot;参数a:&quot; &lt;&lt; a &lt;&lt; &quot;参数b:&quot; &lt;&lt; b &lt;&lt; &quot;参数c:&quot; &lt;&lt; c &lt;&lt; &quot;参数d:&quot; &lt;&lt; d &lt;&lt; endl;&#125;void 充电(function&lt;void(int, int)&gt; sock) &#123; cout &lt;&lt; &quot;准备插入插槽&quot; &lt;&lt; endl; sock(2, 5);//传入2A，5V cout &lt;&lt; &quot;充电完毕”&lt;&lt; endl;&#125;int main() &#123; //函数适配器 //可以使用placeholder进行占位 //socket3接受3个int，第一个参数绑定31，第二个参数为第二个实参，第三个参数为第一个实参 function&lt;void(int,int)&gt; f = bind(socket3,31,placeholder::_2,placeholder::_1); f(7,9); //socket1绑定1个参数，第一个参数绑定为第一个实参 function&lt;void(int,int)&gt; f2 = bind(socket1,placeholder::_1); 充电(bind(socket1, placeholder::_1)); 充电(socket2); 充电(bind(socket3, placeholder::_1, placeholder::_2, 10)); return 0;&#125; 成员函数使用时需要加取地址符&amp; 123456789101112131415//将成员函数绑定为全局函数class BO &#123;public: void run(int) &#123; cout &lt;&lt; &quot;调用了run&quot; &lt;&lt; this &lt;&lt; endl; &#125;&#125;int main() &#123; BO b; function&lt;void()&gt; t = bind(&amp;BO::run, b, placeholder::_1); t(); return 0;&#125; 类型转换 c语言风格的强制转换功能强大，但它把多种本质区别很大的类型转换用同一种写法表示 C++11引入了四种类型转换来替代C风格的强制转换 123456789void C风格强制转换() &#123; double a = 53.156; short f = (short)a; cout &lt;&lt; f &lt;&lt; endl; char *p = (char*)malloc(700); const int d = 5; const int* cpd = &amp;d; int *pd = (int*)cpd;//将const类型指针赋值给一个非const型指针也需要强制转换&#125; 静态类型转换 static_cast&lt;&gt;()：用于在基本类型之间转换以及编译期间确定的指针类型转换 子类指针转换成父类指针安全，父类指针转换成子类指针不一定安全 不同类型指针转换不一定安全 可以转换数据，也可以转换指针类型，不能用来去掉const 1234567void test静态类型转换() &#123; int c = static_cast&lt;int&gt;(35.3); char *p = static_cast&lt;char*&gt;(malloc(700)); const int d = 5; const int *cpd = &amp;d; //int *pd = static_cast&lt;int*&gt;(cpd);&#125; const类型转换 const_cast&lt;&gt;()：专门用于去掉const和volatile，只能用于操作指针 123456void const类型转换() &#123; const int d = 5; const int *cpd = &amp;d; int *pd = const_cast&lt;int*&gt;(cpd); int *pd2 = const_cast&lt;int*&gt;(&amp;vd);&#125; 动态类型转换 dynamic_cast&lt;&gt;() 可以尝试性的将父类指针转换为子类指针，如果安全，就正常转换。转换指针时如果不安全，就返回空指针；转换应用时如果不安全，就抛出bad_cast异常 要转换的指针对应的类必须有虚函数 12345678910111213141516171819202122232425262728293031323334353637class A &#123; virtual void run() &#123;&#125;;&#125;;class B : public A &#123;&#125;;class C : public A &#123;&#125;;void 动态类型转换() &#123; B b; A* a = &amp;b;//子类对象父类指针安全 //把父类指针强转成子类指针不一定安全 B *b2 = (B*)a;//因为a指向的对象本质是B类对象，安全 C *c2 = (C*)a;//因为a指向的对象本质是B类对象，所以不安全 B *b3 = dynamic_cast&lt;B*&gt;(a); C *c3 = dynamic_cast&lt;C*&gt;(a); cout &lt;&lt; &quot;b3：&quot; &lt;&lt; b3 &lt;&lt; &quot;和c3：&quot; &lt;&lt; c3 &lt;&lt; endl; if (b3) &#123; //如果b3不是空指针，说明转换成功，这时再使用b3 &#125; A&amp; ra = b; try &#123; B&amp; b3 = dynamic_cast&lt;B&amp;&gt;(ra); &#125; catch (bad_cast bc) &#123; cout &lt;&lt; bc.what() &lt;&lt; __LINE__ &lt;&lt; endl; &#125; try &#123; C&amp; c3 = dynamic_cast&lt;C&amp;&gt;(ra); &#125; catch (bad_cast bc) &#123; cout &lt;&lt; bc.what() &lt;&lt; __LINE__ &lt;&lt; endl; &#125;&#125; 重新解释转换 reinterpret_cast&lt;&gt;()使用的很少，用来将指针的二进制数据转换成新类型的指针，不会改变二进制内容 1234567void 重新解释转换() &#123; A a; A *pa = &amp;a; B *b = reinterpret_cast&lt;B*&gt;(pa); C *c = reinterpret_cast&lt;C*&gt;(pa); cout &lt;&lt; &quot;b3：&quot; &lt;&lt; b3 &lt;&lt; &quot;和c3：&quot; &lt;&lt; c3 &lt;&lt; endl;&#125; typeid 在运行时检验一个对象的类型 常用的有 .name()类名 .raw_name()原始类名 对象有虚指针，但对象是空指针指向的对象，就会抛出异常 123456789101112131415161718192021222324252627282930class A &#123; virtual void run() &#123;&#125;;&#125;;class B : public A &#123;&#125;;int main() &#123; int a; auto&amp; o = typeid(a);//这里必须用引用 cout &lt;&lt; o.name() &lt;&lt; endl; cout &lt;&lt; o.raw_name() &lt;&lt; endl; B b; A* pa = &amp;b; auto&amp; i = typeid(b); cout &lt;&lt; i.name() &lt;&lt; endl; cout &lt;&lt; i.raw_name() &lt;&lt; endl; cout &lt;&lt; typeid(pa).name() &lt;&lt; endl; cout &lt;&lt; typeid(pa).raw_name() &lt;&lt; endl; //对象有虚指针，但对象是空指针指向的对象，就会抛出异常 A *p2 = nullptr; try &#123; cout &lt;&lt; typeid(*p2).name() &lt;&lt; endl; &#125; catch (bad_typeid bt) &#123; cout &lt;&lt; bt.what() &lt;&lt; endl; &#125; return 0;&#125; assert.h断言 判断当前状态是否出错 123456789101112131415#define NDEBUG 0//开发完成后写这个可以使所有assert失效#include&lt;assert.h&gt;//动态断言，c语言中用来调试代码的//c语言中，用来辅助程序员定位bug的一个工具//assert(表达式);void setAge(int age) &#123; //合法的年龄范围应该是0~150 assert(age &gt;= 0 &amp;&amp; age &lt;= 150);//当表达式为假时，退出程序 cout &lt;&lt; &quot;设置年龄位&quot; &lt;&lt; age &lt;&lt; &quot;岁&quot; &lt;&lt; endl;&#125;int main() &#123; setAge(25); setAge(88); setAge(-20);&#125; 容器std::array1234567891011121314151617#include&lt;array&gt;class vector &#123;public: int *data; int size;&#125;;int main() &#123; array&lt;int, 20&gt; a;//类型，长度，是一个对象，存放在栈中 for (auto i : a) &#123; cout &lt;&lt; i &lt;&lt; &quot;\\t&quot;; &#125;cout &lt;&lt; endl; //不可以动态扩容 //相对于int arr[]的优点事，有很多方法可以直接使用 //vector的数据全存在堆区，并且vector可以动态扩容 return 0;&#125; 无序容器unordered_set unordered_map 平衡二叉树：旋转后中序遍历序列不变 哈希表平均查找时间O(1)，用空间来换时间 1234567891011121314151617181920212223242526class student &#123; friend class cmpStudent; friend ostream&amp; operator&lt;&lt;(ostream&amp; o, student&amp; s); string sno;public: student(string _sno) &#123; sno = _sno; &#125;&#125;;class cmpStudent &#123;public: bool operator()(const student&amp; a, const student&amp; b)const &#123; a.sno &lt; b.sno; &#125;&#125;;ostream&amp; operator&lt;&lt;(const ostream&amp; o, const student&amp; s) &#123; o &lt;&lt; s.sno; return o;&#125;int main() &#123; set&lt;student, cmpStudent&gt; s; s.insert(student(&quot;28&quot;)); s.insert(student(&quot;33&quot;)); s.insert(student(&quot;50&quot;)); &#125; 左值&amp;右值 C++中 可以放到=左边的值叫左值。比如普通变量、引用 不能放到=左边，只能放在=右边的值叫右值。比如字面量或一些临时变量 可以理解为，能获取地址的值就是左值，不能获取地址的值就是右值 在C++11中，明确了左值和右值的概念，左值还是之前的概念，右值的概念分成了两种 右值： 纯右值：C++中定义的右值 将亡值：C++11的某些新语法得到的一类右值 C++将变量的引用分成两类引用，左值引用、右值引用 类型 左值 可以取地址，有名字的是左值 右值 不可以取地址，没名字就是右值 将亡值：xvalue，eXpiring Vlue，右值引用的函数返回值，std::move的返回值 纯右值：prvalue,Pure Rvalue，临时变量和不跟对象关联的值 左值引用 普通引用T&amp;类型 右值引用 匿名变量的别名，延长将亡值的生命周期 常量左值引用 万能类型，可以绑定左值，也可以绑定右值将优质生命周期延长，当只能是只读 产量右值引用 只能存右值，但不可更改 引用类型 非常量左值 常量左值 非常量右值 常量右值 注记 非常量左值引用 Y N N N 常量左值引用 Y Y Y Y 全能 非常量右值引用 N N Y N 用来移动语义，完美转发 产量右值引用 N N Y Y 暂无用途，可被常量左值引用替代 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;class Node &#123;public: int value;&#125;;void LRefTest() &#123; int a = 25; //普通的引用就是左值引用，只能引用左值 int &amp;ra = a; const int ca = 66; const int &amp;ra2 = ca; const int &amp;clr = 65; //常量左值引用，既可以引用左值也可以引用右值&#125;void RRefTest() &#123; int a = 77; //右值引用，只能引用右值 //int &amp;&amp;ra = a; int &amp;&amp;r2 = 5; //右值引用变量本身，是一个左值 &amp;r2;//可以取地址 Node &amp;&amp;n = Node();//Node()是临时变量，故是右值 const Node &amp;&amp;n3 = Node(); const Node &amp;&amp;n2 = const Node();&#125;void func(int &amp;&amp;) &#123;&#125;void func(int &amp;) &#123;&#125;void testLR() &#123; int a = 3; func(a);//左值引用 func(6);//右值引用 int &amp;&amp;rr = 6;//右值 func(rr);//左值引用 func(move(a));//move(a)的返回值是一个右值也是一种将亡值&#125;int main() &#123; LRefTest(); RRefTest(); return 0;&#125; 将亡值 C++11的某些新语法得到的一类右值，引入的在几种特殊情况下，把表达式视为右值的情况 move函数返回值就是将亡值 如果函数返回值是右值引用，那这个返回值是将亡值 将左值强制转换为右值类型，该强制转换的返回值是将亡值 移动构造移动构造：专门用于将o对应的对象指针数据管理权转移到本对象中 ※一个类中会有默认构造、拷贝构造、拷贝赋值、移动构造、移动赋值、析构 其中默认构造无参什么也不做 默认拷贝构造为浅拷贝 默认拷贝赋值为浅拷贝 默认移动构造为浅拷贝 默认移动复制为浅拷贝 默认析构什么也不做 拷贝构造分为浅拷贝和深拷贝 如果有指针成员一定小心浅拷贝很可能出现重复释放问题 但深拷贝需要复制一份指针成员对应的数据，有一些对象转瞬即逝，使用拷贝构造浪费时间、空间，所以C++11引用了移动构造机制 T(T&amp;&amp; o) {}移动构造函数的格式。内部一般o中的指针对应数据移动到this对象中的指针中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Node &#123; char *name;public: Node(const char* _n) &#123; cout &lt;&lt; &quot;构造一个&quot; &lt;&lt; _n &lt;&lt; &quot;对象&quot; &lt;&lt; endl; name = (char*)malloc(sizeof(_n) + 1); strcpy(name, _n); &#125; ~Node() &#123; cout &lt;&lt; &quot;析构一个&quot; &lt;&lt; (name == nullptr? &quot; &quot; : name) &lt;&lt; &quot;对象&quot; &lt;&lt; endl; free(name); &#125; //默认为浅拷贝 //深拷贝 Node(const Node &amp;o) &#123; cout &lt;&lt; &quot;拷贝构造一个&quot; &lt;&lt; o.name &lt;&lt; &quot;对象&quot; &lt;&lt; endl; name = (char*)malloc(sizeof(o.name) + 1); strcpy(name, o.name); &#125; //移动构造：专门用于将o对应的对象指针数据管理权转移到本对象中 Node(Node &amp;&amp;o) &#123; cout &lt;&lt; &quot;移动构造一个&quot; &lt;&lt; o.name &lt;&lt; &quot;对象&quot; &lt;&lt; endl; name = o.name; o.name = nullptr; &#125; //深拷贝版本的拷贝赋值 Node &amp;operator=(const Node &amp;o) &#123; cout &lt;&lt; &quot;拷贝赋值一个&quot; &lt;&lt; o.name &lt;&lt; &quot;对象&quot; &lt;&lt; endl; free(name); name = (char*)malloc(sizeof(o.name) + 1); strcpy(name, o.name); &#125; //移动赋值 Node&amp; operator=(Node &amp;o) &#123; free(name); cout &lt;&lt; &amp;o &lt;&lt; &quot;移动赋值一个&quot; &lt;&lt; o.name &lt;&lt; &quot;对象&quot; &lt;&lt; endl; name = o.name; o.name = nullptr; &#125;&#125;;Node getNode() &#123; Node a(&quot;小赵&quot;); return a;&#125;int main() &#123; /*Node a(&quot;小明&quot;); const Node ca(&quot;小芳&quot;); Node b(a); Node b2(ca); getNode();//没有移动构造时在函数中，返回值会自动拷贝出一份a(&quot;小赵&quot;)，浪费空间 */ getNode(); Node n(&quot;小刚&quot;); Node n2(move(n));//这么写,move(n)的返回值就代表n的一个右值 n = n2;//拷贝赋值 //n.operator=(n2); return 0;&#125;","categories":[],"tags":[]},{"title":"shell学习笔记01：两个简单的shell脚本","slug":"shell学习笔记01：两个简单的shell脚本","date":"2020-05-30T02:10:04.000Z","updated":"2021-01-08T10:06:06.093Z","comments":true,"path":"2020/05/30/shell学习笔记01：两个简单的shell脚本/","link":"","permalink":"http://example.com/2020/05/30/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001%EF%BC%9A%E4%B8%A4%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84shell%E8%84%9A%E6%9C%AC/","excerpt":"","text":"1.添加用户user1-10，但要求只有用户不存在的情况下才能添加。 2.切换工作目录至/var；统计/var目录下共有多个文件，并显示出来。 注意运行shell时如果提示权限不够时需先运行chmod 764 test.sh。 1.添加用户user1-10123456789101112131415161718192021222324#!/bin/sh#添加用户user1-10,只有用户不存在时才添加。psw=&quot;1&quot;for i in `seq 1 10` do name=&quot;user&quot;$i&quot;&quot;; sudo useradd $name; #判断该用户是否存在。 if [ $? -eq 0 ];then echo &quot;user $&#123;name&#125; is created successfully!&quot; else echo &quot;user $&#123;name&#125; is existed!&quot; continue fi #判断密码设置是否成功。 echo $password | sudo password --stdin $name; if [$? -eq 0 ];then echo &quot;$&#123;name&#125;&#x27;s password is set successfully&quot; else echo &quot;$&#123;name&#125;&#x27;s password is set failly!&quot; fidone 定义变量时等号不能加空格。 #!是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。 拼接字符串，可以使用单引号或双引号拼接。 12name=&quot;user&quot;user_name=&quot;&quot;$name&quot;1&quot; #user_name=&quot;$&#123;name&#125;1&quot; 2.统计/var目录下共有多个文件1234567891011#!/bin/sh#切换工作目录至/ver;#依次向/var目录下的每个文件或子目录问好;#统计/var目录下共有多少个文件，并显示出来。i=0cd /varfor FILE in /var/*do i=`expr $i + 1`;doneecho $i “`”的作用是将”``”中间的语句当成命令执行","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"shell","slug":"Linux/shell","permalink":"http://example.com/categories/Linux/shell/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"http://example.com/tags/shell/"}]},{"title":"解决microsoft应用商店开启代理后无法连接问题","slug":"解决microsoft应用商店开启代理后无法连接问题","date":"2020-05-16T11:28:27.000Z","updated":"2021-01-08T10:09:38.303Z","comments":true,"path":"2020/05/16/解决microsoft应用商店开启代理后无法连接问题/","link":"","permalink":"http://example.com/2020/05/16/%E8%A7%A3%E5%86%B3microsoft%E5%BA%94%E7%94%A8%E5%95%86%E5%BA%97%E5%BC%80%E5%90%AF%E4%BB%A3%E7%90%86%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/","excerpt":"问题Microsoft的全部应用在中国区的设置默认都是直连，所以当打开网络代理之后就无法使用应用商店。","text":"问题Microsoft的全部应用在中国区的设置默认都是直连，所以当打开网络代理之后就无法使用应用商店。 解决办法使用Fiddler，点击左上角winconfig，将需要更改的Microso应用打勾✔。","categories":[{"name":"日常问题","slug":"日常问题","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"},{"name":"Microsoft","slug":"日常问题/Microsoft","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Microsoft/"}],"tags":[{"name":"日常问题","slug":"日常问题","permalink":"http://example.com/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"title":"Linux基本操作","slug":"Linux基本操作","date":"2020-04-25T04:30:42.000Z","updated":"2021-01-08T10:07:00.825Z","comments":true,"path":"2020/04/25/Linux基本操作/","link":"","permalink":"http://example.com/2020/04/25/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"Linux的目录 /root：根目录/bin：包含供每个人使用的可执行程序/sbin：包含仅供管理员使用的可执行程序/lib：包含库文件/boot：包括了内核镜像和其它相关内容/dev：包含着代表硬件设备的设备文件/etc：包含着整个系统的各种配置文件/home：包含各用户的主目录/root：是root的主目录/mnt：包含装载其它非标准文件系统的装载点/proc:是个虚拟目录，里面保存内核和进程的信息/tmp：是为程序和用户提供放置临时空间的目录/usr：包含UNIX系统的众多资源，较占空间/var：目录包含了一些文件大小比较特殊的文件，如日志文件，锁文件等，还包括各种用途的文件，如：邮件、计划、打印文件等/lost+found：存在于所有的文件系统中，保存文件碎片/opt：是由一些外部应用程序使用的目录 其它一些用户自己建的目录 工作目录：用户在登录到Linux系统中之后，每时每刻都”处在”某个目录之中，此目录被称作工作目录或当前目录（Working Directory）。工作目录是可以随时改变的。工作目录用.表示，其父目录用..表示。 主目录：是系统管理员增加用户时建立起来的（以后也可以改变），每个用户都有自己的主目录用于保存信息，不同用户的主目录一般互不相同。 用户初始登录到系统中时，其主目录（Home Directory）就成为其工作目录，通常与用户的登录名相同。 用户可以通过一个~字符来引用自己的主目录。例如命令：$ cat ~/file1 Linux常用命令最常用的几个命令可用pwd命令查看用户的当前目录可用cd命令来切换目录.表示当前目录..表示当前目录的上一级目录（父目录）-表示用cd命令切换目录前所在的目录~表示用户主目录的绝对路径名--help查看该操作的帮助信息--version显示版本信息并退出clear清除屏幕 修改口令passwd对用户口令进行操作 who命令who显示当前已登录的用户信息who am i：等价于who -mwhoami：显示当前“操作用户”的用户名 echo命令显示输出字符串 用法：/bin/echo [短选项]... [字符串]... 或：`/bin/echo 长选项`` ​ echo将 STRING 回显到标准输出。 ​ -n不尾随换行符 ​ -e启用解释反斜杠的转义功能 ​ -E禁用解释反斜杠的转义功能(默认) 注意：echo的帮助信息需要输入/bin/echo --help date命令显示或设置系统的日期和时间 用法：date [选项]... [+格式] 或：date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]] cal命令cal显示日历 文件和目录操作相关命令cat命令连接文件并打印到标准输出设备上 用法：cat [选项]... [文件]... more命令用于显示内容超过一屏的文件 用法：more [选项] &lt;文件&gt;...more 内部命令键:Space、Enter、/、h、 b、q。 less的作用与more十分相似，都可以用来浏览文字档案的内容，不同的是less允许使用者往回卷动。 Head/Tail命令用来显示开头或结尾某个数量的文字区块 用法：head [选项]... [文件]... 用法：tail [选项]... [文件]... od命令以指定格式显示文件，默认为八进制 用法：od [选项]... [文件]... 或：od [-abcdfilosx]... [文件] [[+]偏移量[.][b]] 或：od --traditional [选项]... [文件] [[+]偏移量[.][b] [+][标签][.][b]] file命令辨识文件类型 用法：file[选项]... [文件]... touch命令改变档案的时间记录 用法：touch[选项]... [文件]... grep命令查找文件里符合条件的字符串 用法：grep[选项]... [查找模式]... [文件]... 其中-n选项可输出匹配行的行号，-r选项表示在目录中递归查找符合的文件名。 find命令文件查找命令 用法：find[路径]... [选项]... 其中-name选项用于通过文件名查找，-size选项用于通过文件大小查找等。 locate命令快速文件查找命令，该命令在运行时需要后台索引的数据库支撑，可以执行sudo updatedb来手动更新。 用法：Locate[选项]... [文件]... sort命令对文件中的各行进行排序。默认以升序词典顺序排序文件的内容。每一列的字符，包括空格、数字和特殊字符都经一一比较。 用法：sort[选项]... [文件列表]... -d选项：只比较字母、数字和空格，其他忽略。 uniq命令将相邻的重复行从输出文件中删除，只留下每条记录的唯一样本。可结合sort命令使用。 用法：uniq[选项]... [文件]... wc命令统计指定文件中的行数、字数、字节数， 并将统计结果显示输出。 用法：wc[选项]... [文件]... comm命令该命令是对两个已经排好序的文件进行比较。其中file1和file2是已排序的文件。comm读取这两个文件，然后生成三列输出。仅在 file1中出现的行；仅在file2中出现的行；在两个文件中都存在的行。其中- 123选项为选择哪列显示。 用法：comm [- 123 ] file1 file2 diff命令该命令的功能为逐行比较两个文本文件，列出其不同之处。 用法：diff[选项]... [文件1]... [文件名2]... cp命令文件复制 用法：cp[选项]... [源文件名或目录]... [目标文件名或目录]... -r若给出的源文件是一目录文件，此时cp将递归复制该目录下所有的子目录和文件。此时目标文件必须为一个目录名。 -a该选项通常在拷贝目录时使用。它保留链接、文件属性，并递归地拷贝目录。 -f删除已经存在的目标文件而不提示。 rm命令删除文件命令 用法：rm[选项]... [文件列表]... -f忽略不存在的文件，从不给出提示。 -r指示rm将参数中列出的全部目录和子目录均递归地删除。 -i进行交互式删除。 mv命令移动文件命令 用法：mv[选项]... [源文件/目录名]... [目标文件/目录名]... -f覆盖前不询问 -i覆盖前询问 -n不覆盖已存在文件 ln命令文件链接命令，包括硬链接和软链接两种。其中硬链接使得链接数加1，不能链接目录，不能跨文件系统。 用法：ln[选项]... [源文件]... [目标文件]... mkdir/rmdir命令创建目录、删除空目录。 用法：mkdir/rmdir[选项]... [目录名]... rmdir的-p选项，表示当删除目录的父目录为空时，父目录也一并删除。 ls 命令列出目录内容 用法：ls[选项]... [文件或目录]... -a显示所有文件，包括隐藏文件 -R显示所有文件，包括子目录下的文件 -l显示文件的详细信息 -d显示目录的信息而不是目录所含的内容 -i显示文件的inode数 命令的输入和输出 标准I/O文件 标准输入(stdin) 0 标准输出(stdout) 1 标准错误输出(stderr) 2 输出重定向：&gt; 1&gt; 2&gt; &amp;&gt; （含1和2） 附加重定向：&gt;&gt; 输入重定向：&lt;，0&lt; 管道：上一个命令的stdout接到下一个命令的stdin;管道符号| 过滤器：用来接收标准输入，经过一定的转化，再写到标准输出。所以，过滤器一般放在管道符中间。如：ls | sort | more 联机帮助命令help：显示bash shell内置命令的简单信息。使用help命令不带任何参数将显示bash shell所有内置的命令。 用法：help[命令]...man：显示对应命令系统的帮助手册。 用法：man[选项]... [章节数字]... [命令]...whatis:描述一个命令执行什么功能。等同于使用man -f命令 用法：whatis [命令]...whereis：从环境变量的路径中查找符合条件的文件。 用法：whereis[选项]... [文件]... 网络管理命令ifconfig程序设置，检查以及监控网络接口的配置值。 用法：ifconfig [interface_name] [ip_address] [up|down] route路由显示及配置网络路由 netstat 程序显示网络连接、路由表和网络接口信息，可以让用户得知目前都有哪些网络连接正在运作。 用法：netstat［选项］... -a所有连接 -r路由表 -tTCP协议（-u） ping程序用于查看网络上的主机是否在工作，它向该主机发送ICMP ECHO_REQUEST包。当想从网络上的某台主机上下载文件，可是又不知道那台主机是否开着，就需要使用ping命令查看。 用法：ping［选项］ [主机名/IP地址] -c数目 在发送指定数目的包后停止。 -d设定SO_DEBUG的选项。 -f大量且快速地送网络封包给一台机器，看它的回应。 -I秒数 设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"使用Github PicGo搭建图床","slug":"使用Github-PicGo搭建图床","date":"2020-03-22T05:50:16.000Z","updated":"2021-01-08T10:08:43.371Z","comments":true,"path":"2020/03/22/使用Github-PicGo搭建图床/","link":"","permalink":"http://example.com/2020/03/22/%E4%BD%BF%E7%94%A8Github-PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"在github中搭建图床1.创建Repository一定要选择public,private的仓库，图片链接会带token，这个token又存在过期的问题。 这里因为我已经有一个叫Figurebed的仓库所以”Repository name”不可用. README.md可选可不选。 2.创建一个token 选择最下方Developer setting 选择左下方Personal access tokens 右上角generate generate token 新生成的token一定要先复制到其他地方留作备用 配置PicGo1.下载PicGohttps://github.com/Molunerfinn/PicGo 2.配置PicGo 设定仓库名，按照“用户名/仓库名”的格式 分支名填写“master” 将之前留作备用的token粘贴在这里 img/存储路径，会在repository中创建一个img文件夹 设定自定义域名后，上传图片成功后，PicGo会自动生成该图片的访问链接 https://raw.githubusercontent.com/用户名/RepositoryName/分支名 3.相关设置我习惯关闭自动更新，开启开机自启 快捷键可自己设置，我是参考别人用的ctrl+shift+c","categories":[{"name":"Github","slug":"Github","permalink":"http://example.com/categories/Github/"}],"tags":[{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"},{"name":"图床","slug":"图床","permalink":"http://example.com/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"hexo常用指令","slug":"hexo常用指令","date":"2020-03-21T08:50:02.000Z","updated":"2021-01-08T09:03:17.774Z","comments":true,"path":"2020/03/21/hexo常用指令/","link":"","permalink":"http://example.com/2020/03/21/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","excerpt":"","text":"hexo常用指令12345678910hexo new &quot;postName&quot; &#x2F;&#x2F;新建文章hexo new page &quot;pageName&quot; &#x2F;&#x2F;新建页面hexo g &#x2F;&#x2F;生成静态页面至public目录hexo server &#x2F;&#x2F;开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）hexo deploy &#x2F;&#x2F;将.deploy目录部署到GitHubhexo cleanhexo ghexo dhexo d -g #生成部署hexo s -g #生成预览 文件信息123456---title: xxx &#x2F;&#x2F;在此处添加你的标题。date: 2016-10-07 13:38:49 &#x2F;&#x2F;在此处输入编辑这篇文章的时间。tags: xxx &#x2F;&#x2F;在此处输入这篇文章的标签。categories: xxx &#x2F;&#x2F;在此处输入这篇文章的分类。--- 文件编辑完成后发布12hexo ghexo d","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"设置hexo首页只显示博文摘要","slug":"设置hexo首页只显示博文摘要","date":"2020-03-21T01:36:03.000Z","updated":"2021-01-08T08:55:39.110Z","comments":true,"path":"2020/03/21/设置hexo首页只显示博文摘要/","link":"","permalink":"http://example.com/2020/03/21/%E8%AE%BE%E7%BD%AEhexo%E9%A6%96%E9%A1%B5%E5%8F%AA%E6%98%BE%E7%A4%BA%E5%8D%9A%E6%96%87%E6%91%98%E8%A6%81/","excerpt":"","text":"修改配置我使用的Volantis主题默认是开启只显示文章摘要的。该选项可以在blog\\themes\\主题名\\_config.yml文件中找到。 # When there is no description in the article’s front-matter, use excerpt as the description. use_excerpt_as_description: true 在其他主题中变量名可能会变，但一般都会有excerpt和description这两个单词。 对文章的处理方法一：Description在文章的front-matter中添加description，首页会只显示description的内容。下面是本文front-matter title: 设置hexo首页只显示博文摘要date: 2020-03-24 12:10:54 tags: hexodescription: 针对Volantis主题，主题默认显示摘要是开启的，但需要在博文中加一些内容，使其只显示前面一部分。 方法二：文章截断在需要截断的地方加入下列语句。 &lt;!--more--&gt; 首页就会只显示这条以上的所有内容。 法二比法一方便一些，如果感觉文章开头写的不错就直接用法二更方便一点。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/categories/LeetCode/"},{"name":"双指针","slug":"LeetCode/双指针","permalink":"http://example.com/categories/LeetCode/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数组","slug":"LeetCode/数组","permalink":"http://example.com/categories/LeetCode/%E6%95%B0%E7%BB%84/"},{"name":"字符串","slug":"LeetCode/字符串","permalink":"http://example.com/categories/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"习题","slug":"C-C/习题","permalink":"http://example.com/categories/C-C/%E4%B9%A0%E9%A2%98/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"学习路线","slug":"学习路线","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"name":"笔记","slug":"C-C/笔记","permalink":"http://example.com/categories/C-C/%E7%AC%94%E8%AE%B0/"},{"name":"shell","slug":"Linux/shell","permalink":"http://example.com/categories/Linux/shell/"},{"name":"日常问题","slug":"日常问题","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"},{"name":"Microsoft","slug":"日常问题/Microsoft","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/Microsoft/"},{"name":"Github","slug":"Github","permalink":"http://example.com/categories/Github/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/categories/Hexo/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://example.com/tags/LeetCode/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"C/C++","slug":"C-C","permalink":"http://example.com/tags/C-C/"},{"name":"C/C++习题","slug":"C-C-习题","permalink":"http://example.com/tags/C-C-%E4%B9%A0%E9%A2%98/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"学习路线","slug":"学习路线","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"shell","slug":"shell","permalink":"http://example.com/tags/shell/"},{"name":"日常问题","slug":"日常问题","permalink":"http://example.com/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"},{"name":"github","slug":"github","permalink":"http://example.com/tags/github/"},{"name":"图床","slug":"图床","permalink":"http://example.com/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]}