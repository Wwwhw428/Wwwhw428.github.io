{"meta":{"title":"Wwwhw's BLOG","subtitle":"","description":"","author":"Wang Haowen","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"C++学习笔记","slug":"C-学习笔记","date":"2021-01-06T01:45:56.000Z","updated":"2021-01-06T01:46:13.759Z","comments":true,"path":"2021/01/06/C-学习笔记/","link":"","permalink":"http://example.com/2021/01/06/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"C++学习笔记头文件12345678910#include&lt;iostream&gt; //input output streamusing namespace std;int main()&#123; int a = 100; int b = 100; cout &lt;&lt; a &lt;&lt; &#x27; &#x27; &lt;&lt; b &lt;&lt; &quot;hello&quot;; //泛型 return 0;&#125; 命名空间1using namespace std; 优势12345678910111213141516171819202122232425#include&lt;iostream&gt; //input output streamusing namespace std;namespace my1&#123; int a = 100; void print() &#123; printf(&quot;%d&quot;,a); &#125;&#125;namespace my2&#123; int a = 100; void print() &#123; printf(&quot;%d&quot;,a); &#125;&#125;using namespace my1;int main()&#123; print();&#125; cout是一个对象&lt;&lt;是cout的成员函数","categories":[],"tags":[]},{"title":"C语言学习笔记","slug":"C语言学习笔记","date":"2021-01-05T08:50:02.000Z","updated":"2021-01-06T01:45:22.210Z","comments":true,"path":"2021/01/05/C语言学习笔记/","link":"","permalink":"http://example.com/2021/01/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"C语言学习笔记运算符位运算符按位与&amp;按位或|按位异或^按位取反~左移运算符&lt;&lt;左移1位相当于乘2 右移运算符&gt;&gt;右移1位相当于除2 例题010计算2^0 + 2^1 + 2^2 + 2^3 + 2^4 + … + 2^n的结果1234567int main()&#123; int n = 0; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%d&quot;,1 &lt;&lt; (n + 1) - 1); return 0;&#125; ![](https://raw.githubusercontent.com/Wwwhw428/Figurebed/main/img/测试1_15题 .png “测试1_15”) 三步运算符当a&gt;b成立返回1否则返回-1 1return a &gt; b ? 1 : -1 C语言运算符优先级 逻辑语句switch…case…break switch必须是整型 case必须是整型常量 case分支的值不能相同 break不可忽视 如果现在case分支中定义一个变量，加一个括号 所有case分支条件都不满足，那么执行default分支 12345678910111213141516171819#include&lt;stdio.h&gt;int main() &#123; int a; scanf(&quot;%d&quot;,&amp;a); switch(a) &#123; case 1: printf(&quot;%d&quot;,a); break; case 2: &#123; int b = 10; printf(&quot;%d&quot;,b); break; &#125; default: printf(&quot;输入有误&quot;)； break; &#125;&#125; 指针基础房子理论变量的三大要素1.名字2.空间3.地址 两种操作1.读2.写 指针变量p中放的是谁的地址，*p就是谁 12345int a = 10;int* p = &amp;a;//指针变量:用来存储a的地址printf(&quot;%d\\n&quot;,*p);*p = 20;printf(&quot;%d\\n&quot;,a); 输出结果 121020 指针的运算1234567891011int main()&#123; int nums[10] = &#123;0, 1, 2, 3, 4, 5&#125;; int* p = nums; p++;//p = p + 1*sizeof(int); printf(&quot;%d &quot;, sizeof(int)); printf(&quot;%d &quot;, &amp;nums[0]); printf(&quot;%d &quot;, &amp;nums[1]); printf(&quot;%d &quot;, &amp;nums[2]); return 0;&#125; 指针变量的大小32位编译环境下是4个字节64位编译环境下是8个字节 函数 数组[]的意思*(nums + i) &lt;===&gt;nums[i] 数组的名字代表的是数组第一个元素的地址（首地址）。 数组传参数组传参过程中，数组int nums[]会退化成指针int *nums。 12345678void fun(int* nums, int n)&#123;&#125;int main()&#123; int nums[] &#x3D; &#123;1,2,3,4&#125;; fun(nums,sizeof(nums)&#x2F;sizeof(int));&#125; 例题打乱顺序数组的顺序1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;void printArray (int *arry, int n)&#123; for (int i = 0; i&lt; n; i++)&#123; printf (&quot;%d &quot;, arry[i]); &#125;&#125;int main()&#123; int arry[11] = &#123; 1,2,3,4,5,6,7,8,9,10,11&#125;; srand(time(0));//种随机种子 for (int i = 0; i &lt; 11; i++) &#123; int r = rand() % 11; int t = arry[i]; arry[i] = arry[r]; arry[r] = t; &#125; printArray(arry, 11) ; return 0; &#125; 字符串 字符串用&quot;&quot; ASCII表 12345678#include&lt;stdio.h&gt;int main()&#123; printf(&quot;%d&quot;,&quot;abcdefghi&quot;); printf(&quot;\\n&quot;); printf(&quot;%d&quot;,*&quot;abcdefghi&quot;); return 0;&#125; 输出结果 12421068897 字符 char类型在内存中占1个字节字符用单引号&#39;&#39; 0，’0’,’\\0’1234567891011121314#include&lt;stdio.h&gt;int main()&#123; char c = &#x27;0&#x27;; printf(&quot;%c\\n&quot;,c); //0 printf(&quot;%d\\n&quot;,c); //48 c = 0; printf(&quot;%c\\n&quot;,c); // printf(&quot;%d\\n&quot;,c); //0 c = &#x27;\\0&#x27;; printf(&quot;%c\\n&quot;,c); // printf(&quot;%d\\n&quot;,c); //0 return 0;&#125; 转义字符1234567891011#include &lt;stdio.h&gt;int main ( )&#123; char c = &#x27;\\&#x27;&#x27;; c =&#x27;\\\\&#x27;; c =&#x27;\\n&#x27;; c = &#x27;\\t&#x27;; c = &#x27;\\a&#x27;; printf( &quot;%c&quot;, c); return 0;&#125; &quot;&quot;代表的是字符串中首个字符的地址1234567#include&lt;stdio.h&gt;int main()&#123; printf(&quot;%d\\n&quot;,&quot;abcdefghi&quot;);//字符串实际上时第一个字符的地址，即字符串的首地址 printf(&quot;%d\\n&quot;,*&quot;abcdefghi&quot;);//*&quot;abcdefghi&quot;即为a return 0;&#125; 输出结果 12421068897 为什么使用char*存储字符串12345678#include &lt;stdio.h&gt;int main()&#123; char* p = &quot;abcdefghi&quot;; p++;//p = p + sizeof(char)在遍历字符串的时候指针变量偏移一个字节 printf(&quot;%c&quot;, *p); return 0;&#125; 输出结果 1b 计算字符串长度 \\012:\\0后接八以内数字表示八进制 \\x12:\\x后接数字或abcdef表示十六进制 strlen()以\\0作为字符串结束标志 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char* p = &quot;a\\0\\n\\012ab0&quot;; printf (&quot;%d &quot;, sizeof(p)) ; //8 64位系统字符串占8个字节 printf (&quot;%d &quot;, sizeof (&quot;a\\0\\n\\012ab0&quot;)); //8 //a 0 \\n \\012 a b 0 \\0 int n = strlen(p); printf (&quot;%d &quot;, n); //1 //a \\0 strlen()以\\0作为字符串结束标志,其中\\0不计入长度 p++; p++; n=strlen (p) ; printf(&quot;%d &quot;, n); //5 // \\n \\012 a b 0 \\0 return 0;&#125; 输出结果 18 8 1 5 字符数组和字符串常量的区别常量 常量不可修改 整型常量 10 100 字符常量 ‘a’ ‘c’ 浮点常量 1.1 1.01 字符串常量 “asdfd” 地址常量 变量的地址 数组名字 函数名字 1234567891011121314151617#include&lt;stdio.h&gt;int main()&#123; char* p = &quot;a\\0\\n\\012ab0&quot;; //字符串常量 char b[10] = &quot;a\\0\\n\\012ab0&quot;; //字符数组 printf(&quot;%d &quot;,sizeof(p)); //8 printf(&quot;%d &quot;, sizeof(b)); //10 //p++; //b++; //b为数组名是常量不允许修改，该语句有错 //*p++; //*b++; //b++先执行后执行*，产量不允许修改，同上 //(*p)++; //p存储的是字符串中第一个字符的地址，字符串存放在常量区是常量，不允许修改 //(*b)++; return 0;&#125; gets函数 gets函数只有一个参数。参数类型为char*型，即str可以是一个字符指针变量名，也可以是一个字符数组名。 gets()函数的功能是从输入缓冲区中读取一个字符串存储到字符指针变量str所指向的内存空间。 gets()函数不仅比scanf简洁，而且，就算输入的字符串中有空格也可以直接输入，不用像scanf那样要定义多个字符数组。 gets(str);完全可以取代:scanf(&quot;%s&quot;, string); 12345678#include&lt;stdio.h&gt;int main()&#123; char *gets(char *str); char a[50]; gets(a); return 0;&#125; 123456789# include &lt;stdio.h&gt;int main(void)&#123; char str[20] = &quot;\\0&quot;; //字符数组初始化\\0 printf(&quot;请输入字符串：&quot;); gets(str); printf(&quot;%s\\n&quot;, str); return 0;&#125; 输出结果 12请输入字符串：hello the worldhello the world 字符数组的两种遍历方式不同点参考上面《字符数组和字符串常量的区别》 123456789101112131415161718192021#include&lt;stdio.h&gt;int main()&#123; char str[20] = &quot;&quot;; gets(str); int i = 0; while( str[i] != &#x27;\\0&#x27;) &#123; printf(&quot;%c&quot;,str[i]); i++; &#125; char *p = str; while ( *p != &#x27;\\0&#x27;) &#123; printf(&quot;%c&quot;,*p); p++; &#125; return 0;&#125; 字符串函数常见操作 指针变量判空 最后赋值&#39;\\0&#39; 返回值（目的地址）以便支持链式操作 例题1.字符串拷贝123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;char* m_strcpy(char* des, const char* src)&#123; //1.判断指针变量是否为NULL if (des == 0 || src == 0) &#123; return 0;//结束 &#125; //2.字符串拷贝 int i = 0; for (i = 0; src[i] != &#x27;\\0&#x27;; i++) &#123; des[i] = src[i]; &#125; //3.赋值&#x27;\\0&#x27; des[i] = &#x27;\\0&#x27;; //4.返回值目的地址 return des; //支持链式操作&#125;int main()&#123; char src[100] = &quot;&quot;; gets(src); char des[100] = &quot;&quot;; //strcpy(des,src); m_strcpy(des, src); printf(&quot;%s&quot;, des); return 0;&#125; 内存管理常量区特点： 军事管理区，不可修改 常量区空间没有名字 整型常量 10 20 -10 浮点常量 1.2 1.001 字符常量 &#39;a&#39; &#39;0&#39; &#39;\\0&#39; 字符串常量 &quot;adjkls&quot; &quot;56as&quot; 地址常量 int a; &amp;a 数组名 函数名 栈区特点： 租的房子，房子到期自动回收 访问速度快 空间少 作用域和生命周期从定义的位置开始到&#39;&#125;&#39; 常用于局部变量、函数参数 全局区全局变量 特点 局部大于全局（当局部变量和全局变量重名时局部变量优先） 初始化默认为0 生命周期为程序开始到程序结束 作用域为整个项目 引用其他文件中的全局变量 123456789101112131415/mian.c/#include&lt;stdio.h&gt;int g_value;int main()&#123; printf(&quot;%d&quot;,g_value); return 0;&#125;/*a.c*/extern int g_value;void print()&#123; g_value = 100; printf(&quot;%d&quot;,g_value);&#125; 静态区静态局部变量 生命周期从程序开始到程序结束 作用域到&#39;&#125;&#39; 函数结束不释放※ 只被初始化一次※ 123456789101112131415#include&lt;stdio.h&gt;int fun()&#123; int a = 10; static int s = 10; printf(&quot;%d &quot;, a++); printf(&quot;%d &quot;, s++);&#125;int main()&#123; fun();//10 10 fun();//10 11 return 0;&#125; 静态全局变量 生命周期从程序开始到程序结束 作用域为当前文件 堆区特点 买的房子，不会自动释放 不会自动释放 容量大 访问速度慢 堆区空间没有名字 用完需要释放 1234567891011121314#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main()&#123; char* p = malloc(400);//在堆区申请空间（买房子） //返回值为地址，不一定是char，但一定是* //char* 房子被分为400份，一份1个字节 //int* 房子被分为100份，一份4个字节 strcpy(p,&quot;123456&quot;); //房子不用是记得释放 free(p); return 0;&#125; 注意 不要访问越界 不要忘记释放空间 GetMemory笔试题Test112345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void GetMemory1(char *p) &#123; p = (char *)malloc(100);//强制类型转换&#125;void Test1() &#123; char *str = NULL; GetMemory1(str); strcpy(str, &quot;hello world&quot;); printf(str);&#125;int main() &#123; Test1(); return 0;&#125; 访问空指针，异常退出 解决办法1123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char *GetMemory1(char *p) &#123; p = (char *)malloc(100); return p;&#125;void Test1(void) &#123; char *str = NULL; str = GetMemory1(str); strcpy(str, &quot;hello world&quot;); printf(str); free(str);&#125;int main() &#123; Test1(); return 0;&#125; 解决办法21234567891011121314151617#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void GetMemory1(char **p) &#123; //二级指针变量**p *p = (char *)malloc(100);//强制类型转换&#125;//p存放的是str的地址void Test1() &#123; char *str = NULL; GetMemory1(&amp;str); strcpy(str, &quot;hello world&quot;); printf(str); free(str);&#125;int main() &#123; Test1(); return 0;&#125; Test212345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char *GetMemory2(void) &#123; char p[] = &quot;hello world&quot;; return p;&#125;void Test2(void) &#123; char *str = NULL; str = GetMemory2(); printf(str);&#125;int main() &#123; Test2(); return 0;&#125; 字符数组在栈区分配，函数结束被释放 Test312345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char *GetMemory3 (void) &#123; char *p = &quot;hello world&quot;;//字符串是常量，不会改变 故虽然p被释放但常量空间不释放 return p;&#125;void Test3 (void) &#123; char *str = NULL; str = GetMemory3(); printf(str);&#125;int main() &#123; Test3(); return 0;&#125; 输出结果 1hello world Test412345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;char *GetMemory4 (void) &#123; static char p[] = &quot;hello world&quot;; return p;&#125;void Test4 (void) &#123; char *str = NULL; str = GetMemory4(); printf(str);&#125;int main() &#123; Test4(); return 0;&#125; 输出结果 1hello world 静态局部变量不会被释放空间，生命周期是全局的 Test5123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void Test5 (void) &#123; char *str = (char *)malloc(400); strcpy(str, &quot;hello&quot;); free(str); //str = NULL; if (str != NULL) &#123; strcpy(str, &quot;world&quot;); printf(str); &#125;&#125;int main() &#123; Test5(); return 0;&#125; 输出结果 1world str被free后变为野指针，空间被释放，但仍存储着房子的地址 free是剥夺变量房子的使用权，但变量仍记得房子地址 平时记得买完房子free记得置空str = NULL; 内存已经被释放，访问野指针造成内存泄漏 指针在free后未赋值 NULL，便会使人以为是合法的。它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。※ Test612345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void Test6 (void) &#123; char *str = (char *)malloc(400); strcpy(str, &quot;hello&quot;); str += 6; free(str); if (str != NULL) &#123; strcpy(str, &quot;world&quot;); printf(str); &#125;&#125;int main() &#123; Test6(); return 0;&#125; str += 6;后地址改变free卖的是别人的房子 出现异常，释放空间不对。 结构体结构体定义123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct STUDENT&#123; int number; int age; int weight; char s;&#125;student; //student为全局变量typedef struct STUDENT1&#123; char a; int weight; char s;&#125;student1; //student1等于STUDENT1int main()&#123; student.age = 10; struct STUDENT abc = &#123;1001, 22, 110, &#x27;M&#x27;&#125;; //初始化结构体 student1 bcd = &#123;1001, 22, 110, &#x27;M&#x27;&#125;; //等于struct student bcd = &#123;1001, 22, 110, &#x27;M&#x27;&#125;; //通常用typedef sturct,方便 printf(&quot;%d %d %d %c &quot;,abc.number,abc.age,abc.weight,abc.s); return 0;&#125; 输出结果 11001 22 110 M 字节对齐 按照最长的成员对齐 保证整数倍地址对齐（比如：short占两个字节不能放在奇数地址，char随便放奇偶都可以） 12345typedef struct STUDENT&#123; int a; char c;&#125;student; 123456typedef struct STUDENT&#123; char s; int a; char c;&#125;student; 1234567typedef struct STUDENT&#123; int a; char s; char c; short d; //short占两个字节&#125;student; 1234567typedef struct STUDENT&#123; int a; char s; short d; char c;&#125;student; 12345678typedef struct STUDENT&#123; int a; long long c; //long long占八个字节 char d; int b; short s;&#125;student; 1234567typedef struct STUDENT&#123; char a : 2;//2代表2比特bt，一个字节8bt char b : 2; char c : 2; char d : 2;&#125;student; 结构体定义的原则，保证结构体字节对齐 12345678## pragma pack(2)//控制结构体按2字节对齐typedef struct STUDENT&#123; int a; char c; char res[3];//跨平台时由于编译器不同，需强制对齐&#125;student;#pragma pack() 结构体数组12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct STUDENT&#123; int number; int score;&#125;student;int main()&#123; int array[10]; char buffer[10]; student s[10] = &#123;&#123;1,10&#125;,&#123;2,30&#125;&#125;; printf(&quot;%d&quot;,s[0].number); student* p = s; printf(&quot;%d &quot;,s[0].score); printf(&quot;%d &quot;,(*p).score); printf(&quot;%d&quot;,p-&gt;score); //p-&gt;score &lt;===&gt; (*p).score return 0;&#125; 输出结果 11 10 10 10","categories":[],"tags":[]},{"title":"hexo常用指令","slug":"hexo常用指令","date":"2021-01-04T08:50:02.000Z","updated":"2021-01-04T08:55:43.830Z","comments":true,"path":"2021/01/04/hexo常用指令/","link":"","permalink":"http://example.com/2021/01/04/hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","excerpt":"","text":"hexo常用指令12345hexo new &quot;postName&quot; &#x2F;&#x2F;新建文章hexo new page &quot;pageName&quot; &#x2F;&#x2F;新建页面hexo g &#x2F;&#x2F;生成静态页面至public目录hexo server &#x2F;&#x2F;开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）hexo deploy &#x2F;&#x2F;将.deploy目录部署到GitHub 常用指令12345hexo cleanhexo ghexo dhexo d -g #生成部署hexo s -g #生成预览 文件信息123456---title: xxx &#x2F;&#x2F;在此处添加你的标题。date: 2016-10-07 13:38:49 &#x2F;&#x2F;在此处输入编辑这篇文章的时间。tags: xxx &#x2F;&#x2F;在此处输入这篇文章的标签。categories: xxx &#x2F;&#x2F;在此处输入这篇文章的分类。--- 文件编辑完成后发布12hexo ghexo d","categories":[],"tags":[]},{"title":"测试1错题","slug":"测试1错题","date":"2021-01-03T22:50:02.000Z","updated":"2021-01-06T01:50:37.101Z","comments":true,"path":"2021/01/04/测试1错题/","link":"","permalink":"http://example.com/2021/01/04/%E6%B5%8B%E8%AF%951%E9%94%99%E9%A2%98/","excerpt":"","text":"1.计算2^0 + 2^1 + 2^2 + 2^3 + 2^4 + … + 2^n的结果1234567int main()&#123; int n = 0; scanf(&quot;%d&quot;,&amp;n); printf(&quot;%d&quot;,1 &lt;&lt; (n + 1) - 1); return 0;&#125; ![](https://raw.githubusercontent.com/Wwwhw428/Figurebed/main/img/测试1_15题 .png “测试1_15”) 2.任意一个大于2的偶数n都可以由两个素数的和组成，但是组成偶数的素数有很多种情况，输出所有情况。123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int n = 0; scanf(&quot;%d&quot;,&amp;n); int *nums = (int *)malloc(n*sizeof(int)); if (nums == NULL) &#123; return -1; //申请空间失败，返回异常状态 &#125; //初始化动态数组 for (int i = 0; i &lt; n; i++) &#123; nums[i] = 0; &#125; //厄拉多塞筛选法 for (int i = 2; i &lt; n; i++) &#123; if (nums[i] == 0) &#123; for (int j = i + i; j &lt; n; j += i) &#123; nums[j] = 1; &#125; &#125; &#125; for(int i = 2; i &lt; n / 2; i++) &#123; if (nums[i] == 0 &amp;&amp; nums[n - i] == 0) &#123; printf(&quot;%d %d\\n&quot;,i,n - i); &#125; &#125; free(nums); return 0;&#125; ![](https://raw.githubusercontent.com/Wwwhw428/Figurebed/main/img/测试1_17题 .png “测试1_17”)","categories":[],"tags":[]},{"title":"解决microsoft应用商店开启代理后无法连接问题","slug":"解决microsoft应用商店开启代理后无法连接问题","date":"2020-05-16T11:28:27.000Z","updated":"2021-01-06T01:45:18.818Z","comments":true,"path":"2020/05/16/解决microsoft应用商店开启代理后无法连接问题/","link":"","permalink":"http://example.com/2020/05/16/%E8%A7%A3%E5%86%B3microsoft%E5%BA%94%E7%94%A8%E5%95%86%E5%BA%97%E5%BC%80%E5%90%AF%E4%BB%A3%E7%90%86%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题Microsoft的全部应用在中国区的设置默认都是直连，所以当打开网络代理之后就无法使用应用商店。 解决办法使用Fiddler，点击左上角winconfig，将需要更改的Microso应用打勾✔。","categories":[],"tags":[{"name":"日常问题","slug":"日常问题","permalink":"http://example.com/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"}]},{"title":"设置hexo首页只显示博文摘要","slug":"设置hexo首页只显示博文摘要","date":"2020-05-06T01:36:03.000Z","updated":"2021-01-06T01:45:19.597Z","comments":true,"path":"2020/05/06/设置hexo首页只显示博文摘要/","link":"","permalink":"http://example.com/2020/05/06/%E8%AE%BE%E7%BD%AEhexo%E9%A6%96%E9%A1%B5%E5%8F%AA%E6%98%BE%E7%A4%BA%E5%8D%9A%E6%96%87%E6%91%98%E8%A6%81/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Linux基本操作","slug":"Linux基本操作","date":"2020-04-25T04:30:42.000Z","updated":"2021-01-04T11:32:12.527Z","comments":true,"path":"2020/04/25/Linux基本操作/","link":"","permalink":"http://example.com/2020/04/25/Linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"","text":"Linux的目录","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"使用Github PicGo搭建图床","slug":"使用Github-PicGo搭建图床","date":"2020-03-22T05:50:16.000Z","updated":"2021-01-06T01:45:20.166Z","comments":true,"path":"2020/03/22/使用Github-PicGo搭建图床/","link":"","permalink":"http://example.com/2020/03/22/%E4%BD%BF%E7%94%A8Github-PicGo%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/","excerpt":"","text":"在github中搭建图床1.创建Repository一定要选择public,private的仓库，图片链接会带token，这个token又存在过期的问题。 这里因为我已经有一个叫Figurebed的仓库所以”Repository name”不可用. README.md可选可不选。 2.创建一个token 选择最下方Developer setting 选择左下方Personal access tokens 右上角generate generate token 新生成的token一定要先复制到其他地方留作备用 配置PicGo1.下载PicGohttps://github.com/Molunerfinn/PicGo 2.配置PicGo 设定仓库名，按照“用户名/仓库名”的格式 分支名填写“master” 将之前留作备用的token粘贴在这里 img/存储路径，会在repository中创建一个img文件夹 设定自定义域名后，上传图片成功后，PicGo会自动生成该图片的访问链接 https://raw.githubusercontent.com/用户名/RepositoryName/分支名 3.相关设置我习惯关闭自动更新，开启开机自启 快捷键可自己设置，我是参考别人用的ctrl+shift+c","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"日常问题","slug":"日常问题","permalink":"http://example.com/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]}